0000 |          |             | ORG = $C000
0000 |          |             | 
0000 |          |             | #INCLUDE pssupermon64.asm
0000 |          |             | ; Start Including 'pssupermon64.asm'
0000 |          |             | ; -----------------------------------------------------------------------------
0000 |          |             | ; temporary pointers
0000 |          |             | TMP0    = $C1               ; used to return input, often holds end address
0000 |          |             | TMP2    = $C3               ; usually holds start address
0000 |          |             | 
0000 |          |             | ; -----------------------------------------------------------------------------
0000 |          |             | ; kernal variables
0000 |          |             | SATUS   = $90               ; kernal i/o status word
0000 |          |             | FNLEN   = $B7               ; length of current filename
0000 |          |             | SADD    = $B9               ; current secondary address (official name SA)
0000 |          |             | FA      = $BA               ; current device number
0000 |          |             | FNADR   = $BB               ; pointer to current filename
0000 |          |             | NDX     = $C6               ; number of characters in keyboard buffer
0000 |          |             | KEYD    = $0277             ; keyboard buffer
0000 |          |             | BKVEC   = $0316             ; BRK instruction vector (official name CBINV)
0000 |          |             | 
0100 |          |             |         *= $0100            ; store variables in tape error buffer
0100 |          |             | 
0100 |          |             | ; -----------------------------------------------------------------------------
0100 |          |             | ; variables
0100 |          |             | ACMD:    FILL 1             ; addressing command
0101 |          |             | LENGTH:  FILL 1             ; length of operand
0102 |          |             | MNEMW:   FILL 3             ; 3 letter mnemonic buffer
0105 |          |             | SAVX:    FILL 1             ; 1 byte temp storage, often to save X register
0106 |          |             | OPCODE:  FILL 1             ; current opcode for assembler/disassembler
0107 |          |             | UPFLG:   FILL 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
0108 |          |             | DIGCNT:  FILL 1             ; digit count
0109 |          |             | INDIG:   FILL 1             ; numeric value of single digit
010A |          |             | NUMBIT:  FILL 1             ; numeric base of input
010B |          |             | STASH:   FILL 2             ; 2-byte temp storage
010D |          |             | U0AA0:   FILL 10            ; work buffer
0117 |          |             | U0AAE:                     ; end of work buffer
0117 |          |             | STAGE:   FILL 30            ; staging buffer for filename, search, etc.
0135 |          |             | ESTAGE:                    ; end of staging buffer
0135 |          |             | 
0200 |          |             |         *= $0200            ; store more variables in basic line editor buffer
0200 |          |             | 
0200 |          |             | INBUFF:  FILL 40            ; 40-character input buffer
0228 |          |             | ENDIN:                     ; end of input buffer
0228 |          |             | 
0228 |          |             | ; the next 7 locations are used to store the registers when
0228 |          |             | ; entering the monitor and restore them when exiting.
0228 |          |             | 
0228 |          |             | PCH:     FILL 1             ; program counter high byte
0229 |          |             | PCL:     FILL 1             ; program counter low byte
022A |          |             | SR:      FILL 1             ; status register
022B |          |             | ACC:     FILL 1             ; accumulator
022C |          |             | XR:      FILL 1             ; X register
022D |          |             | YR:      FILL 1             ; Y register
022E |          |             | SP:      FILL 1             ; stack pointer
022F |          |             | 
022F |          |             | STORE:   FILL 2             ; 2-byte temp storage
0231 |          |             | CHRPNT:  FILL 1             ; current position in input buffer
0232 |          |             | SAVY:    FILL 1             ; temp storage, often to save Y register
0233 |          |             | U9F:     FILL 1             ; index into assembler work buffer
0234 |          |             | 
0234 |          |             | ; -----------------------------------------------------------------------------
0234 |          |             | ; kernal entry points
0234 |          |             | SETMSG  = $FF90             ; set kernel message control flag
0234 |          |             | SECOND  = $FF93             ; set secondary address after LISTEN
0234 |          |             | TKSA    = $FF96             ; send secondary address after TALK
0234 |          |             | LISTEN  = $FFB1             ; command serial bus device to LISTEN
0234 |          |             | TALK    = $FFB4             ; command serial bus device to TALK
0234 |          |             | SETLFS  = $FFBA             ; set logical file parameters
0234 |          |             | SETNAM  = $FFBD             ; set filename
0234 |          |             | ACPTR   = $FFA5             ; input byte from serial bus
0234 |          |             | CIOUT   = $FFA8             ; output byte to serial bus
0234 |          |             | UNTLK   = $FFAB             ; command serial bus device to UNTALK
0234 |          |             | UNLSN   = $FFAE             ; command serial bus device to UNLISTEN
0234 |          |             | CHKIN   = $FFC6             ; define input channel
0234 |          |             | CLRCHN  = $FFCC             ; restore default devices
0234 |          |             | INPUT   = $FFCF             ; input a character (official name CHRIN)
0234 |          |             | CHROUT  = $FFD2             ; output a character
0234 |          |             | LOAD    = $FFD5             ; load from device
0234 |          |             | SAVE    = $FFD8             ; save to device
0234 |          |             | STOP    = $FFE1             ; check the STOP key
0234 |          |             | GETIN   = $FFE4             ; get a character
0234 |          |             | 
0234 |          |             | ; -----------------------------------------------------------------------------
0234 |          |             | ; set up origin
0234 |          |             | 
C000 |          |             | *       = ORG
C000 |          |             | 
C000 |          |             | ; -----------------------------------------------------------------------------
C000 |          |             | ; initial entry point
C000 | A0 20    | LDY #$20    | SUPER:  LDY.# MSG4-MSGBAS    ; display "..SYS "
C002 | 20 84 C9 | JSR $C984   |         JSR SNDMSG
C005 | AD E5 CA | LDA $CAE5   |         LDA SUPAD           ; store entry point address in tmp0
C008 | 85 C1    | STA $C1     |         STA.zp TMP0
C00A | AD E6 CA | LDA $CAE6   |         LDA SUPAD+1
C00D | 85 C2    | STA $C2     |         STA.zp TMP0+1
C00F | 20 0E C8 | JSR $C80E   |         JSR CVTDEC          ; convert address to decimal
C012 | A9 00    | LDA #$00    |         LDA.# 0
C014 | A2 06    | LDX #$06    |         LDX.# 6
C016 | A0 03    | LDY #$03    |         LDY.# 3
C018 | 20 48 C8 | JSR $C848   |         JSR NMPRNT          ; print entry point address
C01B | 20 DD C6 | JSR $C6DD   |         JSR CRLF
C01E | AD E3 CA | LDA $CAE3   |         LDA LINKAD          ; set BRK vector
C021 | 8D 16 03 | STA $0316   |         STA BKVEC
C024 | AD E4 CA | LDA $CAE4   |         LDA LINKAD+1
C027 | 8D 17 03 | STA $0317   |         STA BKVEC+1
C02A | A9 80    | LDA #$80    |         LDA.# $80            ; disable kernel control messages
C02C | 20 90 FF | JSR $FF90   |         JSR SETMSG          ; and enable error messages
C02F | 00       | BRK         |         BRK
C030 |          |             | 
C030 |          |             | ; -----------------------------------------------------------------------------
C030 |          |             | ; BRK handler
C030 | A2 05    | LDX #$05    | BREAK:  LDX.# $05            ; pull registers off the stack
C032 | 68       | PLA         | BSTACK: PLA                 ; order: Y,X,A,SR,PCL,PCH
C033 | 9D 28 02 | STA $0228,X |         STA,X PCH           ; store in memory
C036 | CA       | DEX         |         DEX 
C037 | 10 F9    | BPL $F9     |         BPL BSTACK
C039 | D8       | CLD         |         CLD                 ; disable bcd mode
C03A | BA       | TSX         |         TSX                 ; store stack pointer in memory 
C03B | 8E 2E 02 | STX $022E   |         STX SP
C03E | 58       | CLI         |         CLI                 ; enable interupts
C03F |          |             | 
C03F |          |             | ; -----------------------------------------------------------------------------
C03F |          |             | ; display registers [R]
C03F | A0 00    | LDY #$00    | DSPLYR:  LDY.# MSG2-MSGBAS    ; display headers
C041 | 20 71 C9 | JSR $C971   |         JSR SNDCLR
C044 | A9 3B    | LDA #$3B    |         LDA.# $3B            ; prefix registers with "; " to allow editing
C046 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C049 | A9 20    | LDA #$20    |         LDA.# $20
C04B | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C04E | AD 28 02 | LDA $0228   |         LDA PCH             ; print 2-byte program counter
C051 | 20 F6 C6 | JSR $C6F6   |         JSR WRTWO
C054 | A0 01    | LDY #$01    |         LDY.# 1              ; start 1 byte after PC high byte
C056 | B9 28 02 | LDA $0228,Y | DISJ:    LDA,Y PCH           ; loop through rest of the registers
C059 | 20 D2 C6 | JSR $C6D2   |         JSR WRBYTE          ; print 1-byte register value
C05C | C8       | INY         |         INY 
C05D | C0 07    | CPY #$07    |         CPY.# 7              ; there are a total of 5 registers to print
C05F | 90 F5    | BCC $F5     |         BCC DISJ
C061 |          |             | 
C061 |          |             | ; -----------------------------------------------------------------------------
C061 |          |             | ; main loop
C061 | 20 DD C6 | JSR $C6DD   | STRT:    JSR CRLF            ; new line
C064 | A2 00    | LDX #$00    |         LDX.# 0              ; point at start of input buffer
C066 | 8E 31 02 | STX $0231   |         STX CHRPNT 
C069 | 20 CF FF | JSR $FFCF   | SMOVE:   JSR INPUT           ; CHRIN kernal call to input a character
C06C | 9D 00 02 | STA $0200,X |         STA,X INBUFF        ; store in input buffer
C06F | E8       | INX         |         INX 
C070 | E0 28    | CPX #$28    |         CPX.# ENDIN-INBUFF   ; error if buffer is full
C072 | B0 1C    | BCS $1C     |         BCS ERROR
C074 | C9 0D    | CMP #$0D    |         CMP.# $0D            ; keep reading until CR
C076 | D0 F1    | BNE $F1     |         BNE SMOVE
C078 | A9 00    | LDA #$00    |         LDA.# 0              ; null-terminate input buffer
C07A | 9D FF 01 | STA $01FF,X |         STA,X INBUFF-1      ; (replacing the CR)
C07D | 20 1E C7 | JSR $C71E   | ST1:     JSR GETCHR          ; get a character from the buffer
C080 | F0 DF    | BEQ $DF     |         BEQ STRT            ; start over if buffer is empty
C082 | C9 20    | CMP #$20    |         CMP.# $20            ; skip leading spaces
C084 | F0 F7    | BEQ $F7     |         BEQ ST1
C086 | A2 16    | LDX #$16    | S0:      LDX.# KEYTOP-KEYW    ; loop through valid command characters
C088 | DD A7 CA | CMP $CAA7,X | S1:      CMP,X KEYW          ; see if input character matches
C08B | F0 0B    | BEQ $0B     |         BEQ S2              ; command matched, dispatch it
C08D | CA       | DEX         |         DEX                 ; no match, check next command
C08E | 10 F8    | BPL $F8     |         BPL S1              ; keep trying until we've checked them all
C090 |          |             |                             ; then fall through to error handler
C090 |          |             | 
C090 |          |             | ; -----------------------------------------------------------------------------
C090 |          |             | ; handle error
C090 | A0 1E    | LDY #$1E    | ERROR:   LDY.# MSG3-MSGBAS    ; display "?" to indicate error and go to new line
C092 | 20 84 C9 | JSR $C984   |         JSR SNDMSG
C095 | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to main loop
C098 |          |             | 
C098 |          |             | ; -----------------------------------------------------------------------------
C098 |          |             | ; dispatch command
C098 | E0 13    | CPX #$13    | S2:      CPX.# $13            ; last 3 commands in table are load/save/validate
C09A | B0 12    | BCS $12     |         BCS LSV             ;   which are handled by the same subroutine
C09C | E0 0F    | CPX #$0F    |         CPX.# $0F            ; next 4 commands are base conversions
C09E | B0 14    | BCS $14     |         BCS CNVLNK          ;   which are handled by the same subroutine
C0A0 | 8A       | TXA         |         TXA                 ; remaining commands dispatch through vector table
C0A1 | 0A       | ASL A       |         ASL.A               ; multiply index of command by 2
C0A2 | AA       | TAX         |         TAX                 ;   since table contains 2-byte addresses
C0A3 | BD BE CA | LDA $CABE,X |         LDA,X KADDR+1       ; push address from vector table onto stack
C0A6 | 48       | PHA         |         PHA                 ;   so that the RTS from GETPAR will jump there
C0A7 | BD BD CA | LDA $CABD,X |         LDA,X KADDR
C0AA | 48       | PHA         |         PHA
C0AB | 4C FF C5 | JMP $C5FF   |         JMP GETPAR          ; get the first parameter for the command
C0AE | 8D 32 02 | STA $0232   | LSV:     STA SAVY            ; handle load/save/validate
C0B1 | 4C 81 C2 | JMP $C281   |         JMP LD
C0B4 | 4C C3 C7 | JMP $C7C3   | CNVLNK:  JMP CONVRT          ; handle base conversion
C0B7 |          |             | 
C0B7 |          |             | ; -----------------------------------------------------------------------------
C0B7 |          |             | ; exit monitor [X]
C0B7 | 6C 02 A0 | JMP ($A002) | EXIT:    JMP.i $A002         ; jump to warm-start vector to reinitialize BASIC
C0BA |          |             | 
C0BA |          |             | ; -----------------------------------------------------------------------------
C0BA |          |             | ; display memory [M]
C0BA | B0 08    | BCS $08     | DSPLYM:  BCS DSPM11          ; start from previous end addr if no address given
C0BC | 20 38 C7 | JSR $C738   |         JSR COPY12          ; save start address in TMP2
C0BF | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get end address in TMP0
C0C2 | 90 06    | BCC $06     |         BCC DSMNEW          ; did user specify one?
C0C4 | A9 0B    | LDA #$0B    | DSPM11:  LDA.# $0B            ; if not, show 12 lines by default
C0C6 | 85 C1    | STA $C1     |         STA.zp TMP0
C0C8 | D0 0E    | BNE $0E     |         BNE DSPBYT          ; always true, but BNE uses 1 byte less than JMP
C0CA | 20 41 C7 | JSR $C741   | DSMNEW:  JSR SUB12           ; end addr given, calc bytes between start and end
C0CD | 90 1E    | BCC $1E     |         BCC MERROR          ; error if start is after end
C0CF | A2 03    | LDX #$03    |         LDX.# 3              ; divide by 8 (shift right 3 times)
C0D1 | 46 C2    | LSR $C2     | DSPM01:  LSR.zp TMP0+1
C0D3 | 66 C1    | ROR $C1     |         ROR.zp TMP0
C0D5 | CA       | DEX         |         DEX 
C0D6 | D0 F9    | BNE $F9     |         BNE DSPM01
C0D8 | 20 E1 FF | JSR $FFE1   | DSPBYT:  JSR STOP            ; check for stop key
C0DB | F0 0D    | BEQ $0D     |         BEQ DSPMX           ; exit early if pressed
C0DD | 20 5D C1 | JSR $C15D   |         JSR DISPMEM         ; display 1 line containing 8 bytes
C0E0 | A9 08    | LDA #$08    |         LDA.# 8              ; increase start address by 8 bytes
C0E2 | 20 77 C7 | JSR $C777   |         JSR BUMPAD2
C0E5 | 20 4F C7 | JSR $C74F   |         JSR SUBA1           ; decrement line counter
C0E8 | B0 EE    | BCS $EE     |         BCS DSPBYT          ; show another line until it's < 0
C0EA | 4C 61 C0 | JMP $C061   | DSPMX:   JMP STRT            ; back to main loop
C0ED | 4C 90 C0 | JMP $C090   | MERROR:  JMP ERROR           ; handle error
C0F0 |          |             | 
C0F0 |          |             | ; -----------------------------------------------------------------------------
C0F0 |          |             | ; alter registers [;]
C0F0 | 20 8F C7 | JSR $C78F   | ALTR:   JSR COPY1P          ; store first parameter in PC
C0F3 | A0 00    | LDY #$00    |         LDY.# 0              ; init counter
C0F5 | 20 FF C5 | JSR $C5FF   | ALTR1:  JSR GETPAR          ; get value for next register
C0F8 | B0 0A    | BCS $0A     |         BCS ALTRX           ; exit early if no more values given
C0FA | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; store in memory, offset from SR
C0FC | 99 2A 02 | STA $022A,Y |         STA,Y SR            ; these locations will be transferred to the
C0FF | C8       | INY         |         INY                 ;   actual registers before exiting the monitor
C100 | C0 05    | CPY #$05    |         CPY.# $05            ; have we updated all 5 yet?
C102 | 90 F1    | BCC $F1     |         BCC ALTR1           ; if not, get next
C104 | 4C 61 C0 | JMP $C061   | ALTRX:  JMP STRT            ; back to main loop
C107 |          |             | 
C107 |          |             | ; -----------------------------------------------------------------------------
C107 |          |             | ; alter memory [>]
C107 | B0 13    | BCS $13     | ALTM:   BCS ALTMX           ; exit if no parameter provided
C109 | 20 38 C7 | JSR $C738   |         JSR COPY12          ; copy parameter to start address
C10C | A0 00    | LDY #$00    |         LDY.# 0
C10E | 20 FF C5 | JSR $C5FF   | ALTM1:  JSR GETPAR          ; get value for next byte of memory
C111 | B0 09    | BCS $09     |         BCS ALTMX           ; if none given, exit early
C113 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; poke value into memory at start address + Y
C115 | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2
C117 | C8       | INY         |         INY                 ; next byte
C118 | C0 08    | CPY #$08    |         CPY.# 8              ; have we read 8 bytes yet?
C11A | 90 F2    | BCC $F2     |         BCC ALTM1           ; if not, read the next one
C11C | A9 91    | LDA #$91    | ALTMX:  LDA.# $91            ; move cursor up
C11E | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C121 | 20 5D C1 | JSR $C15D   |         JSR DISPMEM         ; re-display line to make ascii match hex
C124 | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to main loop
C127 |          |             | 
C127 |          |             | ; -----------------------------------------------------------------------------
C127 |          |             | ; goto (run) [G]
C127 | AE 2E 02 | LDX $022E   | GOTO:   LDX SP              ; load stack pointer from memory
C12A | 9A       | TXS         |         TXS                 ; save in SP register
C12B | 20 8F C7 | JSR $C78F   | GOTO2:  JSR COPY1P          ; copy provided address to PC
C12E | 78       | SEI         |         SEI                 ; disable interrupts
C12F | AD 28 02 | LDA $0228   |         LDA PCH             ; push PC high byte on stack
C132 | 48       | PHA         |         PHA
C133 | AD 29 02 | LDA $0229   |         LDA PCL             ; push PC low byte on stack
C136 | 48       | PHA         |         PHA
C137 | AD 2A 02 | LDA $022A   |         LDA SR              ; push status byte on stack
C13A | 48       | PHA         |         PHA
C13B | AD 2B 02 | LDA $022B   |         LDA ACC             ; load accumulator from memory
C13E | AE 2C 02 | LDX $022C   |         LDX XR              ; load X from memory
C141 | AC 2D 02 | LDY $022D   |         LDY YR              ; load Y from memory
C144 | 40       | RTI         |         RTI                 ; return from interrupt (pops PC and SR)
C145 |          |             | 
C145 |          |             | ; jump to subroutine [J]
C145 | AE 2E 02 | LDX $022E   | JSUB:   LDX SP              ; load stack pointer from memory
C148 | 9A       | TXS         |         TXS                 ; save value in SP register
C149 | 20 2B C1 | JSR $C12B   |         JSR GOTO2           ; same as goto command
C14C | 8C 2D 02 | STY $022D   |         STY YR              ; save Y to memory
C14F | 8E 2C 02 | STX $022C   |         STX XR              ; save X to memory
C152 | 8D 2B 02 | STA $022B   |         STA ACC             ; save accumulator to memory
C155 | 08       | PHP         |         PHP                 ; push processor status on stack
C156 | 68       | PLA         |         PLA                 ; pull processor status into A
C157 | 8D 2A 02 | STA $022A   |         STA SR              ; save processor status to memory
C15A | 4C 3F C0 | JMP $C03F   |         JMP DSPLYR          ; display registers
C15D |          |             | 
C15D |          |             | ; -----------------------------------------------------------------------------
C15D |          |             | ; display 8 bytes of memory
C15D | 20 DD C6 | JSR $C6DD   | DISPMEM: JSR CRLF            ; new line
C160 | A9 3E    | LDA #$3E    |         LDA.# '>'            ; prefix > so memory can be edited in place
C162 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C165 | 20 C8 C6 | JSR $C6C8   |         JSR SHOWAD          ; show address of first byte on line
C168 | A0 00    | LDY #$00    |         LDY.# 0
C16A | F0 03    | BEQ $03     |         BEQ DMEMGO          ; SHOWAD already printed a space after the address
C16C | 20 D5 C6 | JSR $C6D5   | DMEMLP: JSR SPACE           ; print space between bytes
C16F | B1 C3    | LDA ($C3),Y | DMEMGO: LDA.i,Y TMP2        ; load byte from start address + Y
C171 | 20 F6 C6 | JSR $C6F6   |         JSR WRTWO           ; output hex digits for byte
C174 | C8       | INY         |         INY                 ; next byte
C175 | C0 08    | CPY #$08    |         CPY.# 8              ; have we output 8 bytes yet?
C177 | 90 F3    | BCC $F3     |         BCC DMEMLP          ; if not, output next byte
C179 | A0 26    | LDY #$26    |         LDY.# MSG5-MSGBAS    ; if so, output : and turn on reverse video
C17B | 20 84 C9 | JSR $C984   |         JSR SNDMSG          ;   before displaying ascii representation
C17E | A0 00    | LDY #$00    |         LDY.# 0              ; back to first byte in line
C180 | B1 C3    | LDA ($C3),Y | DCHAR:  LDA.i,Y TMP2        ; load byte at start address + Y
C182 | AA       | TAX         |         TAX                 ; stash in X
C183 | 29 BF    | AND #$BF    |         AND.# $BF            ; clear 6th bit
C185 | C9 22    | CMP #$22    |         CMP.# $22            ; is it a quote (")?
C187 | F0 08    | BEQ $08     |         BEQ DDOT            ; if so, print . instead
C189 | 8A       | TXA         |         TXA                 ; if not, restore character
C18A | 29 7F    | AND #$7F    |         AND.# $7F            ; clear top bit
C18C | C9 20    | CMP #$20    |         CMP.# $20            ; is it a printable character (>= $20)?
C18E | 8A       | TXA         |         TXA                 ; restore character
C18F | B0 02    | BCS $02     |         BCS DCHROK          ; if printable, output character
C191 | A9 2E    | LDA #$2E    | DDOT:   LDA.# $2E            ; if not, output '.' instaed
C193 | 20 D2 FF | JSR $FFD2   | DCHROK: JSR CHROUT
C196 | C8       | INY         |         INY                 ; next byte
C197 | C0 08    | CPY #$08    |         CPY.# 8              ; have we output 8 bytes yet?
C199 | 90 E5    | BCC $E5     |         BCC DCHAR           ; if not, output next byte
C19B | 60       | RTS         |         RTS 
C19C |          |             | 
C19C |          |             | ; -----------------------------------------------------------------------------
C19C |          |             | ; compare memory [C]
C19C | A9 00    | LDA #$00    | COMPAR: LDA.# 0              ; bit 7 clear signals compare
C19E | 2C       |             |         DATA.b $2C           ; absolute BIT opcode consumes next word (LDA #$80)
C19F |          |             | 
C19F |          |             | ; transfer memory [T]
C19F | A9 80    | LDA #$80    | TRANS:  LDA.# $80            ; bit 7 set signals transfer
C1A1 | 8D 32 02 | STA $0232   |         STA SAVY            ; save compare/transfer flag in SAVY
C1A4 | A9 00    | LDA #$00    |         LDA.# 0              ; assume we're counting up (bit 7 clear)
C1A6 | 8D 07 01 | STA $0107   |         STA UPFLG           ; save direction flag
C1A9 | 20 9C C7 | JSR $C79C   |         JSR GETDIF          ; get two addresses and calculate difference
C1AC |          |             |                             ;   TMP2 = source start
C1AC |          |             |                             ;   STASH = source end
C1AC |          |             |                             ;   STORE = length
C1AC | B0 05    | BCS $05     |         BCS TERROR          ; carry set indicates error
C1AE | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get destination address in TMP0
C1B1 | 90 03    | BCC $03     |         BCC TOKAY           ; carry set indicates error
C1B3 | 4C 90 C0 | JMP $C090   | TERROR: JMP ERROR           ; handle error
C1B6 | 2C 32 02 | BIT $0232   | TOKAY:  BIT SAVY            ; transfer or compare?
C1B9 | 10 27    | BPL $27     |         BPL COMPAR1         ; high bit clear indicates compare
C1BB | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; if it's a transfer, we must take steps
C1BD | C5 C1    | CMP $C1     |         CMP.zp TMP0            ;   to avoid overwriting the source bytes before 
C1BF | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ;   they have been transferred
C1C1 | E5 C2    | SBC $C2     |         SBC.zp TMP0+1          ; compare source (TMP2) to destination (TMP0)
C1C3 | B0 1D    | BCS $1D     |         BCS COMPAR1         ; and count up if source is before than desitnation
C1C5 | AD 2F 02 | LDA $022F   |         LDA STORE           ; otherwise, start at end and count down...
C1C8 | 65 C1    | ADC $C1     |         ADC.zp TMP0            ; add length (STORE) to desintation (TMP0)
C1CA | 85 C1    | STA $C1     |         STA.zp TMP0            ; to calculate end of destination
C1CC | AD 30 02 | LDA $0230   |         LDA STORE+1
C1CF | 65 C2    | ADC $C2     |         ADC.zp TMP0+1
C1D1 | 85 C2    | STA $C2     |         STA.zp TMP0+1
C1D3 | A2 01    | LDX #$01    |         LDX.# 1              ; change source pointer from beginning to end
C1D5 | BD 0B 01 | LDA $010B,X | TDOWN:  LDA,X STASH         ; TMP2 = source end (STASH)
C1D8 | 95 C3    | STA $C3,X   |         STA.zp,X TMP2
C1DA | CA       | DEX         |         DEX 
C1DB | 10 F8    | BPL $F8     |         BPL TDOWN
C1DD | A9 80    | LDA #$80    |         LDA.# $80            ; high bit set in UPFLG means count down
C1DF | 8D 07 01 | STA $0107   |         STA UPFLG
C1E2 | 20 DD C6 | JSR $C6DD   | COMPAR1: JSR CRLF            ; new line
C1E5 | A0 00    | LDY #$00    |         LDY.# 0              ; no offset from pointer
C1E7 | 20 E1 FF | JSR $FFE1   | TCLOOP: JSR STOP            ; check for stop key
C1EA | F0 31    | BEQ $31     |         BEQ TEXIT           ; exit if pressed
C1EC | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; load byte from source
C1EE | 2C 32 02 | BIT $0232   |         BIT SAVY            ; transfer or compare?
C1F1 | 10 02    | BPL $02     |         BPL COMPAR2         ; skip store if comparing
C1F3 | 91 C1    | STA ($C1),Y |         STA.i,Y TMP0        ; otherwise, store in destination
C1F5 | D1 C1    | CMP ($C1),Y | COMPAR2: CMP.i,Y TMP0        ; compare to destination
C1F7 | F0 03    | BEQ $03     |         BEQ TMVAD           ; don't show address if equal
C1F9 | 20 C8 C6 | JSR $C6C8   |         JSR SHOWAD          ; show address
C1FC | 2C 07 01 | BIT $0107   | TMVAD:  BIT UPFLG           ; counting up or down?
C1FF | 30 0B    | BMI $0B     |         BMI TDECAD          ; high bit set means we're counting down
C201 | E6 C1    | INC $C1     |         INC.zp TMP0            ; increment destination low byte
C203 | D0 10    | BNE $10     |         BNE TINCOK
C205 | E6 C2    | INC $C2     |         INC.zp TMP0+1          ; carry to high byte if necessary
C207 | D0 0C    | BNE $0C     |         BNE TINCOK
C209 | 4C 90 C0 | JMP $C090   |         JMP ERROR           ; error if high byte overflowed
C20C | 20 4F C7 | JSR $C74F   | TDECAD: JSR SUBA1           ; decrement destination (TMP0)
C20F | 20 81 C7 | JSR $C781   |         JSR SUB21           ; decrement source (TMP2)
C212 | 4C 18 C2 | JMP $C218   |         JMP TMOR
C215 | 20 75 C7 | JSR $C775   | TINCOK: JSR ADDA2           ; increment source (TMP2)
C218 | 20 63 C7 | JSR $C763   | TMOR:   JSR SUB13           ; decrement length
C21B | B0 CA    | BCS $CA     |         BCS TCLOOP          ; loop until length is 0
C21D | 4C 61 C0 | JMP $C061   | TEXIT:  JMP STRT            ; back to main loop
C220 |          |             | 
C220 |          |             | ; -----------------------------------------------------------------------------
C220 |          |             | ; hunt memory [H]
C220 | 20 9C C7 | JSR $C79C   | HUNT:   JSR GETDIF          ; get start (TMP2) and end (TMP0) of haystack
C223 | B0 59    | BCS $59     |         BCS HERROR          ; carry indicates error
C225 | A0 00    | LDY #$00    |         LDY.# 0
C227 | 20 1E C7 | JSR $C71E   |         JSR GETCHR          ; get a single character
C22A | C9 27    | CMP #$27    |         CMP.# 39 ; "'"            ; is it a single quote?
C22C | D0 16    | BNE $16     |         BNE NOSTRH          ; if not, input needle as hex bytes
C22E | 20 1E C7 | JSR $C71E   |         JSR GETCHR          ; if so, input needle as string
C231 | C9 00    | CMP #$00    |         CMP.# 0
C233 | F0 49    | BEQ $49     |         BEQ HERROR          ; error if needle isn't at least one byte
C235 | 99 17 01 | STA $0117,Y | HPAR:   STA,Y STAGE         ; save char in staging area
C238 | C8       | INY         |         INY 
C239 | 20 1E C7 | JSR $C71E   |         JSR GETCHR          ; get another char
C23C | F0 18    | BEQ $18     |         BEQ HTGO            ; if it's null start searching
C23E | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; have we filled up the needle staging area?
C240 | D0 F3    | BNE $F3     |         BNE HPAR            ; if not, get another character
C242 | F0 12    | BEQ $12     |         BEQ HTGO            ; if so, start searching
C244 | 20 FC C5 | JSR $C5FC   | NOSTRH: JSR RDPAR           ; read hex bytes if string not indicated
C247 | A5 C1    | LDA $C1     | HLP:    LDA.zp TMP0            ; save last read byte in staging area
C249 | 99 17 01 | STA $0117,Y |         STA,Y STAGE
C24C | C8       | INY         |         INY                 ; get another hex byte
C24D | 20 FF C5 | JSR $C5FF   |         JSR GETPAR
C250 | B0 04    | BCS $04     |         BCS HTGO            ; if there is none, start searching
C252 | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; have we filled up the needle staging area?
C254 | D0 F1    | BNE $F1     |         BNE HLP             ; if not, get another byte
C256 | 8C 32 02 | STY $0232   | HTGO:   STY SAVY            ; save length of needle
C259 | 20 DD C6 | JSR $C6DD   |         JSR CRLF            ; new line
C25C | A0 00    | LDY #$00    | HSCAN:  LDY.# 0
C25E | B1 C3    | LDA ($C3),Y | HLP3:   LDA.i,Y TMP2        ; get first byte in haystack
C260 | D9 17 01 | CMP $0117,Y |         CMP,Y STAGE         ; compare it to first byte of needle
C263 | D0 09    | BNE $09     |         BNE HNOFT           ; if it doesn't match, we haven't found anything
C265 | C8       | INY         |         INY                 ; if it does, check the next byte
C266 | CC 32 02 | CPY $0232   |         CPY SAVY            ; have we reached the end of the needle?
C269 | D0 F3    | BNE $F3     |         BNE HLP3            ; if not, keep comparing bytes
C26B | 20 C8 C6 | JSR $C6C8   |         JSR SHOWAD          ; match found, show address
C26E | 20 E1 FF | JSR $FFE1   | HNOFT:  JSR STOP            ; no match, check for stop key
C271 | F0 08    | BEQ $08     |         BEQ HEXIT           ; exit prematurely if pressed
C273 | 20 75 C7 | JSR $C775   |         JSR ADDA2           ; increment haystack pointer
C276 | 20 63 C7 | JSR $C763   |         JSR SUB13           ; decrement haystack length
C279 | B0 E1    | BCS $E1     |         BCS HSCAN           ; still more haystack? keep searching
C27B | 4C 61 C0 | JMP $C061   | HEXIT:  JMP STRT            ; back to main loop
C27E | 4C 90 C0 | JMP $C090   | HERROR: JMP ERROR           ; handle error
C281 |          |             | 
C281 |          |             | ; -----------------------------------------------------------------------------
C281 |          |             | ; load, save, or verify [LSV]
C281 | A0 01    | LDY #$01    | LD:     LDY.# 1              ; default to reading from tape, device #1
C283 | 84 BA    | STY $BA     |         STY.zp FA
C285 | 84 B9    | STY $B9     |         STY.zp SADD            ; default to secondary address #1
C287 | 88       | DEY         |         DEY
C288 | 84 B7    | STY $B7     |         STY.zp FNLEN           ; start with an empty filename
C28A | 84 90    | STY $90     |         STY.zp SATUS           ; clear status
C28C | A9 01    | LDA #$01    |         LDA.# STAGE >> 8        ; set filename pointer to staging buffer
C28E | 85 BC    | STA $BC     |         STA.zp FNADR+1
C290 | A9 17    | LDA #$17    |         LDA.# STAGE & 0x00ff 
C292 | 85 BB    | STA $BB     |         STA.zp FNADR
C294 | 20 1E C7 | JSR $C71E   | L1:     JSR GETCHR          ; get a character
C297 | F0 59    | BEQ $59     |         BEQ LSHORT          ; no filename given, try load or verify from tape
C299 | C9 20    | CMP #$20    |         CMP.# $20            ; skip leading spaces
C29B | F0 F7    | BEQ $F7     |         BEQ L1
C29D | C9 22    | CMP #$22    |         CMP.# $22            ; error if filename doesn't start with a quote
C29F | D0 16    | BNE $16     |         BNE LERROR
C2A1 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; load current char pointer into index reg
C2A4 | BD 00 02 | LDA $0200,X | L3:     LDA,X INBUFF        ; load current char from buffer to accumulator
C2A7 | F0 49    | BEQ $49     |         BEQ LSHORT          ; no filename given, try load or verify from tape
C2A9 | E8       | INX         |         INX                 ; next char
C2AA | C9 22    | CMP #$22    |         CMP.# $22            ; is it a quote?
C2AC | F0 0C    | BEQ $0C     |         BEQ L8              ; if so, we've reached the end of the filename
C2AE | 91 BB    | STA ($BB),Y |         STA.i,Y FNADR       ; if not, save character in filename buffer
C2B0 | E6 B7    | INC $B7     |         INC.zp FNLEN           ; increment filename length
C2B2 | C8       | INY         |         INY 
C2B3 | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; check whether buffer is full
C2B5 | 90 ED    | BCC $ED     |         BCC L3              ; if not, get another character
C2B7 | 4C 90 C0 | JMP $C090   | LERROR: JMP ERROR           ; if so, handle error
C2BA | 8E 31 02 | STX $0231   | L8:     STX CHRPNT          ; set character pointer to the current index
C2BD | 20 1E C7 | JSR $C71E   |         JSR GETCHR          ; eat separator between filename and device #
C2C0 | F0 30    | BEQ $30     |         BEQ LSHORT          ; no separator, try to load or verify from tape
C2C2 | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get device number
C2C5 | B0 2B    | BCS $2B     |         BCS LSHORT          ; no device # given, try load or verify from tape
C2C7 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; set device number for kernal routines
C2C9 | 85 BA    | STA $BA     |         STA.zp FA
C2CB | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get start address for load or save in TMP0
C2CE | B0 22    | BCS $22     |         BCS LSHORT          ; no start address, try to load or verify
C2D0 | 20 38 C7 | JSR $C738   |         JSR COPY12          ; transfer start address to TMP2
C2D3 | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get end address for save in TMP0
C2D6 | B0 3D    | BCS $3D     |         BCS LDADDR          ; no end address, try to load to given start addr
C2D8 | 20 DD C6 | JSR $C6DD   |         JSR CRLF            ; new line
C2DB | A6 C1    | LDX $C1     |         LDX.zp TMP0            ; put low byte of end address in X
C2DD | A4 C2    | LDY $C2     |         LDY.zp TMP0+1          ; put high byte of end address in Y
C2DF | AD 32 02 | LDA $0232   |         LDA SAVY            ; confirm that we're doing a save
C2E2 | C9 53    | CMP #$53    |         CMP.# 'S'
C2E4 | D0 D1    | BNE $D1     |         BNE LERROR          ; if not, error due to too many params
C2E6 | A9 00    | LDA #$00    |         LDA.# 0
C2E8 | 85 B9    | STA $B9     |         STA.zp SADD            ; set secondary address to 0
C2EA | A9 C3    | LDA #$C3    |         LDA.# TMP2           ; put addr of zero-page pointer to data in A
C2EC | 20 D8 FF | JSR $FFD8   |         JSR SAVE            ; call kernal save routine
C2EF | 4C 61 C0 | JMP $C061   | LSVXIT: JMP STRT            ; back to mainloop
C2F2 | AD 32 02 | LDA $0232   | LSHORT: LDA SAVY            ; check which command we received
C2F5 | C9 56    | CMP #$56    |         CMP.# 'V'
C2F7 | F0 06    | BEQ $06     |         BEQ LOADIT          ; we're doing a verify so don't set A to 0
C2F9 | C9 4C    | CMP #$4C    |         CMP.# 'L'
C2FB | D0 BA    | BNE $BA     |         BNE LERROR          ; error due to not enough params for save
C2FD | A9 00    | LDA #$00    |         LDA.# 0              ; 0 in A signals load, anything else is verify
C2FF | 20 D5 FF | JSR $FFD5   | LOADIT: JSR LOAD            ; call kernal load routine
C302 | A5 90    | LDA $90     |         LDA.zp SATUS           ; get i/o status
C304 | 29 10    | AND #$10    |         AND.# $10            ; check bit 5 for checksum error
C306 | F0 E7    | BEQ $E7     |         BEQ LSVXIT          ; if no error go back to mainloop
C308 | AD 32 02 | LDA $0232   |         LDA SAVY            ; ?? not sure what these two lines are for...
C30B | F0 AA    | BEQ $AA     |         BEQ LERROR          ; ?? SAVY will never be 0, so why check?
C30D | A0 28    | LDY #$28    |         LDY.# MSG6-MSGBAS    ; display "ERROR" if checksum didn't match
C30F | 20 84 C9 | JSR $C984   |         JSR SNDMSG
C312 | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to mainloop
C315 | A6 C3    | LDX $C3     | LDADDR: LDX.zp TMP2            ; load address low byte in X
C317 | A4 C4    | LDY $C4     |         LDY.zp TMP2+1          ; load address high byte in Y
C319 | A9 00    | LDA #$00    |         LDA.# 0              ; 0 in A signals load
C31B | 85 B9    | STA $B9     |         STA.zp SADD            ; secondary addr 0 means load to addr in X and Y
C31D | F0 D3    | BEQ $D3     |         BEQ LSHORT          ; execute load
C31F |          |             | 
C31F |          |             | ; -----------------------------------------------------------------------------
C31F |          |             | ; fill memory [F]
C31F | 20 9C C7 | JSR $C79C   | FILL:   JSR GETDIF          ; start in TMP2, end in STASH, length in STORE
C322 | B0 59    | BCS $59     |         BCS AERROR          ; carry set indicates error
C324 | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get value to fill in TMP0
C327 | B0 54    | BCS $54     |         BCS AERROR          ; carry set indicates error
C329 | 20 1E C7 | JSR $C71E   |         JSR GETCHR          ; any more characters triggers an error
C32C | D0 4F    | BNE $4F     |         BNE AERROR
C32E | A0 00    | LDY #$00    |         LDY.# 0              ; no offset
C330 | A5 C1    | LDA $C1     | FILLP:  LDA.zp TMP0            ; load value to fill in accumulator
C332 | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2        ; store fill value in current address
C334 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
C337 | F0 08    | BEQ $08     |         BEQ FSTART          ; if pressed, back to main loop
C339 | 20 75 C7 | JSR $C775   |         JSR ADDA2           ; increment address
C33C | 20 63 C7 | JSR $C763   |         JSR SUB13           ; decrement length
C33F | B0 EF    | BCS $EF     |         BCS FILLP           ; keep going until length reaches 0
C341 | 4C 61 C0 | JMP $C061   | FSTART: JMP STRT            ; back to main loop
C344 |          |             | 
C344 |          |             | ; -----------------------------------------------------------------------------
C344 |          |             | ; assemble [A.]
C344 |          |             | 
C344 |          |             | ; read in mnemonic
C344 | B0 37    | BCS $37     | ASSEM:  BCS AERROR          ; error if no address given
C346 | 20 38 C7 | JSR $C738   |         JSR COPY12          ; copy address to TMP2
C349 | A2 00    | LDX #$00    | AGET1:  LDX.# 0
C34B | 8E 0E 01 | STX $010E   |         STX U0AA0+1         ; clear byte that mnemonic gets shifted into
C34E | 8E 08 01 | STX $0108   |         STX DIGCNT          ; clear digit count
C351 | 20 1E C7 | JSR $C71E   | AGET2:  JSR GETCHR          ; get a char
C354 | D0 04    | BNE $04     |         BNE ALMOR           ; proceed if the character isn't null
C356 | E0 00    | CPX #$00    |         CPX.# 0              ; it's null, have read a mnemonic yet?
C358 | F0 E7    | BEQ $E7     |         BEQ FSTART          ; if not, silently go back to main loop
C35A | C9 20    | CMP #$20    | ALMOR:  CMP.# $20            ; skip leading spaces
C35C | F0 EB    | BEQ $EB     |         BEQ AGET1
C35E | 9D 02 01 | STA $0102,X |         STA,X MNEMW         ; put character in mnemonic buffer
C361 | E8       | INX         |         INX
C362 | E0 03    | CPX #$03    |         CPX.# 3              ; have we read 3 characters yet?
C364 | D0 EB    | BNE $EB     |         BNE AGET2           ; if not, get next character
C366 |          |             | 
C366 |          |             | ; compress mnemonic into two bytes
C366 | CA       | DEX         | ASQEEZ: DEX                 ; move to previous char
C367 | 30 17    | BMI $17     |         BMI AOPRND          ; if we're done with mnemonic, look for operand
C369 | BD 02 01 | LDA $0102,X |         LDA,X MNEMW         ; get current character
C36C | 38       | SEC         |         SEC                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
C36D | E9 3F    | SBC #$3F    |         SBC.# $3F            ; subtract $3F from ascii code so A-Z = 2 to 27
C36F | A0 05    | LDY #$05    |         LDY.# $05            ; letters now fit in 5 bits; shift them out
C371 | 4A       | LSR A       | ASHIFT: LSR.A               ;   into the first two bytes of the inst buffer
C372 | 6E 0E 01 | ROR $010E   |         ROR U0AA0+1         ; catch the low bit from accumulator in right byte
C375 | 6E 0D 01 | ROR $010D   |         ROR U0AA0           ; catch the low bit from right byte in left byte
C378 | 88       | DEY         |         DEY                 ; count down bits
C379 | D0 F6    | BNE $F6     |         BNE ASHIFT          ; keep looping until we reach zero
C37B | F0 E9    | BEQ $E9     |         BEQ ASQEEZ          ; unconditional branch to handle next char
C37D | 4C 90 C0 | JMP $C090   | AERROR: JMP ERROR           ; handle error
C380 |          |             | 
C380 |          |             | ; parse operand
C380 | A2 02    | LDX #$02    | AOPRND: LDX.# 2              ; mnemonic is in first two bytes so start at third
C382 | AD 08 01 | LDA $0108   | ASCAN:  LDA DIGCNT          ; did we find address digits last time?
C385 | D0 2D    | BNE $2D     |         BNE AFORM1          ; if so, look for mode chars
C387 | 20 27 C6 | JSR $C627   |         JSR RDVAL           ; otherwise, look for an address
C38A | F0 25    | BEQ $25     |         BEQ AFORM0          ; we didn't find an address, look for characters
C38C | B0 EF    | BCS $EF     |         BCS AERROR          ; carry flag indicates error
C38E | A9 24    | LDA #$24    |         LDA.# 0x24  ; "$"
C390 | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; prefix addresses with $
C393 | E8       | INX         |         INX                 ; next position in buffer
C394 | A0 04    | LDY #$04    |         LDY.# 4              ; non-zero page addresses are 4 hex digits
C396 | AD 0A 01 | LDA $010A   |         LDA NUMBIT          ; check numeric base in which address was given
C399 | C9 08    | CMP #$08    |         CMP.# 8              ; for addresses given in octal or binary
C39B | 90 05    | BCC $05     |         BCC AADDR           ;   use only the high byte to determine page
C39D | CC 08 01 | CPY $0108   |         CPY DIGCNT          ; for decimal or hex, force non-zero page addressing
C3A0 | F0 06    | BEQ $06     |         BEQ AFILL0          ;   if address was given with four digits or more 
C3A2 | A5 C2    | LDA $C2     | AADDR:  LDA.zp TMP0+1          ; check whether high byte of address is zero
C3A4 | D0 02    | BNE $02     |         BNE AFILL0          ; non-zero high byte means we're not in zero page
C3A6 | A0 02    | LDY #$02    |         LDY.# 2              ; if it's in zero page, addr is 2 hex digits
C3A8 | A9 30    | LDA #$30    | AFILL0: LDA.# $30            ; use 0 as placeholder for each hex digit in addr
C3AA | 9D 0D 01 | STA $010D,X | AFIL0L: STA,X U0AA0         ; put placeholder in assembly buffer
C3AD | E8       | INX         |         INX                 ; move to next byte in buffer
C3AE | 88       | DEY         |         DEY                 ; decrement number of remaining digits
C3AF | D0 F9    | BNE $F9     |         BNE AFIL0L          ; loop until all digits have been placed
C3B1 | CE 31 02 | DEC $0231   | AFORM0: DEC CHRPNT          ; non-numeric input; back 1 char to see what it was
C3B4 | 20 1E C7 | JSR $C71E   | AFORM1: JSR GETCHR          ; get next character
C3B7 | F0 0E    | BEQ $0E     |         BEQ AESCAN          ; if there is none, we're finished scanning
C3B9 | C9 20    | CMP #$20    |         CMP.# $20            ; skip spaces
C3BB | F0 C5    | BEQ $C5     |         BEQ ASCAN
C3BD | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; store character in assembly buffer
C3C0 | E8       | INX         |         INX                 ; move to next byte in buffer
C3C1 | E0 0A    | CPX #$0A    |         CPX.# U0AAE-U0AA0    ; is instruction buffer full?
C3C3 | 90 BD    | BCC $BD     |         BCC ASCAN           ; if not, keep scanning
C3C5 | B0 B6    | BCS $B6     |         BCS AERROR          ; error if buffer is full
C3C7 |          |             | 
C3C7 |          |             | 
C3C7 |          |             | ; find matching opcode
C3C7 | 8E 2F 02 | STX $022F   | AESCAN: STX STORE           ; save number of bytes in assembly buffer
C3CA | A2 00    | LDX #$00    |         LDX.# 0              ; start at opcode $00 and check every one until
C3CC | 8E 06 01 | STX $0106   |         STX OPCODE          ;   we find one that matches our criteria
C3CF | A2 00    | LDX #$00    | ATRYOP: LDX.# 0
C3D1 | 8E 33 02 | STX $0233   |         STX U9F             ; reset index into work buffer
C3D4 | AD 06 01 | LDA $0106   |         LDA OPCODE
C3D7 | 20 8E C5 | JSR $C58E   |         JSR INSTXX          ; look up instruction format for current opcode
C3DA | AE 00 01 | LDX $0100   |         LDX ACMD            ; save addressing command for later
C3DD | 8E 30 02 | STX $0230   |         STX STORE+1
C3E0 | AA       | TAX         |         TAX                 ; use current opcode as index
C3E1 | BD 63 CA | LDA $CA63,X |         LDA,X MNEMR         ; check right byte of compressed mnemonic
C3E4 | 20 B5 C4 | JSR $C4B5   |         JSR CHEKOP
C3E7 | BD 23 CA | LDA $CA23,X |         LDA,X MNEML         ; check left byte of compressed mnemonic
C3EA | 20 B5 C4 | JSR $C4B5   |         JSR CHEKOP
C3ED | A2 06    | LDX #$06    |         LDX.# 6              ; 6 possible characters to check against operand
C3EF | E0 03    | CPX #$03    | TRYIT:  CPX.# 3              ; are we on character 3?
C3F1 | D0 14    | BNE $14     |         BNE TRYMOD          ; if not, check operand characters
C3F3 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; otherwise, check number of bytes in operand
C3F6 | F0 0F    | BEQ $0F     |         BEQ TRYMOD          ; if zero, check operand characters
C3F8 | AD 00 01 | LDA $0100   | TRYAD:  LDA ACMD            ; otherwise, look for an address
C3FB | C9 E8    | CMP #$E8    |         CMP.# $E8            ; special case for relative addressing mode
C3FD |          |             |                             ;   since it's specified with 4 digits in assembly
C3FD |          |             |                             ;   but encoded with only 1 byte in object code
C3FD | A9 30    | LDA #$30    |         LDA.# $30            ; '0' is the digit placeholder we're looking for
C3FF | B0 1E    | BCS $1E     |         BCS TRY4B           ; ACMD >= $E8 indicates relative addressing
C401 | 20 B2 C4 | JSR $C4B2   |         JSR CHEK2B          ; ACMD < $E8 indicates normal addressing
C404 | 88       | DEY         |         DEY                 ; consume byte
C405 | D0 F1    | BNE $F1     |         BNE TRYAD           ; check for 2 more digits if not zero-page
C407 | 0E 00 01 | ASL $0100   | TRYMOD: ASL ACMD            ; shift a bit out of the addressing command
C40A | 90 0E    | BCC $0E     |         BCC UB4DF           ; if it's zero, skip checking current character
C40C | BD 16 CA | LDA $CA16,X |         LDA,X CHAR1-1
C40F | 20 B5 C4 | JSR $C4B5   |         JSR CHEKOP          ; otherwise first character against operand
C412 | BD 1C CA | LDA $CA1C,X |         LDA,X CHAR2-1       ; get second character to check
C415 | F0 03    | BEQ $03     |         BEQ UB4DF           ; if it's zero, skip checking it
C417 | 20 B5 C4 | JSR $C4B5   |         JSR CHEKOP          ; otherwise check it against hte operand
C41A | CA       | DEX         | UB4DF:  DEX                 ; move to next character
C41B | D0 D2    | BNE $D2     |         BNE TRYIT           ; repeat tests
C41D | F0 06    | BEQ $06     |         BEQ TRYBRAN
C41F | 20 B2 C4 | JSR $C4B2   | TRY4B:  JSR CHEK2B          ; check for 4 digit address placeholder
C422 | 20 B2 C4 | JSR $C4B2   |         JSR CHEK2B          ;   by checking for 2 digits twice
C425 | AD 2F 02 | LDA $022F   | TRYBRAN: LDA STORE           ; get number of bytes in assembly buffer
C428 | CD 33 02 | CMP $0233   |         CMP U9F             ; more bytes left to check?
C42B | F0 03    | BEQ $03     |         BEQ ABRAN           ; if not, we've found a match; build instruction
C42D | 4C C2 C4 | JMP $C4C2   |         JMP BUMPOP          ; if so, this opcode doesn't match; try the next
C430 |          |             | 
C430 |          |             | ; convert branches to relative address
C430 | AC 01 01 | LDY $0101   | ABRAN:  LDY LENGTH          ; get number of bytes in operand
C433 | F0 32    | BEQ $32     |         BEQ A1BYTE          ; if none, just output the opcode
C435 | AD 30 02 | LDA $0230   |         LDA STORE+1         ; otherwise check the address format
C438 | C9 9D    | CMP #$9D    |         CMP.# $9D            ; is it a relative branch?
C43A | D0 23    | BNE $23     |         BNE OBJPUT          ; if not, skip relative branch calculation
C43C | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; calculate the difference between the current
C43E | E5 C3    | SBC $C3     |         SBC.zp TMP2            ;   address and the branch target (low byte)
C440 | AA       | TAX         |         TAX                 ; save it in X
C441 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; borrow from the high byte if necessary
C443 | E5 C4    | SBC $C4     |         SBC.zp TMP2+1
C445 | 90 08    | BCC $08     |         BCC ABBACK          ; if result is negative, we're branching back
C447 | D0 66    | BNE $66     |         BNE SERROR          ; high bytes must be equal when branching forward
C449 | E0 82    | CPX #$82    |         CPX.# $82            ; difference between low bytes must be < 130
C44B | B0 62    | BCS $62     |         BCS SERROR          ; error if the address is too far away
C44D | 90 08    | BCC $08     |         BCC ABRANX
C44F | A8       | TAY         | ABBACK: TAY                 ; when branching backward high byte of target must
C450 | C8       | INY         |         INY                 ;   be 1 less than high byte of current address
C451 | D0 5C    | BNE $5C     |         BNE SERROR          ; if not, it's too far away
C453 | E0 82    | CPX #$82    |         CPX.# $82            ; difference between low bytes must be < 130
C455 | 90 58    | BCC $58     |         BCC SERROR          ; if not, it's too far away
C457 | CA       | DEX         | ABRANX: DEX                 ; adjust branch target relative to the 
C458 | CA       | DEX         |         DEX                 ;   instruction following this one
C459 | 8A       | TXA         |         TXA
C45A | AC 01 01 | LDY $0101   |         LDY LENGTH          ; load length of operand
C45D | D0 03    | BNE $03     |         BNE OBJP2           ; don't use the absolute address
C45F |          |             | 
C45F |          |             | ; assemble machine code
C45F | B9 C0 00 | LDA $00C0,Y | OBJPUT: LDA,Y TMP0-1        ; get the operand
C462 | 91 C3    | STA ($C3),Y | OBJP2:  STA.i,Y TMP2        ; store it after the opcode
C464 | 88       | DEY         |         DEY
C465 | D0 F8    | BNE $F8     |         BNE OBJPUT          ; copy the other byte of operand if there is one
C467 | AD 06 01 | LDA $0106   | A1BYTE: LDA OPCODE          ; put opcode into instruction
C46A | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2
C46C | 20 DD C6 | JSR $C6DD   |         JSR CRLF            ; carriage return
C46F | A9 91    | LDA #$91    |         LDA.# $91            ; back up one line
C471 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C474 | A0 2E    | LDY #$2E    |         LDY.# MSG7-MSGBAS    ; "A " prefix
C476 | 20 71 C9 | JSR $C971   |         JSR SNDCLR          ; clear line
C479 | 20 10 C5 | JSR $C510   |         JSR DISLIN          ; disassemble the instruction we just assembled
C47C | EE 01 01 | INC $0101   |         INC LENGTH          ; instruction length = operand length + 1 byte
C47F | AD 01 01 | LDA $0101   |         LDA LENGTH          ;   for the opcode
C482 | 20 77 C7 | JSR $C777   |         JSR BUMPAD2         ; increment address by length of instruction
C485 | A9 41    | LDA #$41    |         LDA.# 'A'            ; stuff keyboard buffer with next assemble command:
C487 | 8D 77 02 | STA $0277   |         STA KEYD            ;   "A XXXX " where XXXX is the next address
C48A | A9 20    | LDA #$20    |         LDA.# ' '            ;   after the previously assembled instruction
C48C | 8D 78 02 | STA $0278   |         STA KEYD+1
C48F | 8D 7D 02 | STA $027D   |         STA KEYD+6
C492 | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ; convert high byte of next address to hex
C494 | 20 06 C7 | JSR $C706   |         JSR ASCTWO
C497 | 8D 79 02 | STA $0279   |         STA KEYD+2          ; put it in the keyboard buffer
C49A | 8E 7A 02 | STX $027A   |         STX KEYD+3
C49D | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; convert low byte of next address to hex
C49F | 20 06 C7 | JSR $C706   |         JSR ASCTWO
C4A2 | 8D 7B 02 | STA $027B   |         STA KEYD+4          ; put it in the keyboard buffer
C4A5 | 8E 7C 02 | STX $027C   |         STX KEYD+5
C4A8 | A9 07    | LDA #$07    |         LDA.# 7              ; set number of chars in keyboard buffer
C4AA | 85 C6    | STA $C6     |         STA.zp NDX
C4AC | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to main loop
C4AF | 4C 90 C0 | JMP $C090   | SERROR: JMP ERROR           ; handle error
C4B2 |          |             | 
C4B2 |          |             | ; check characters in operand
C4B2 | 20 B5 C4 | JSR $C4B5   | CHEK2B: JSR CHEKOP          ; check two bytes against value in accumulator
C4B5 | 8E 05 01 | STX $0105   | CHEKOP: STX SAVX            ; stash X
C4B8 | AE 33 02 | LDX $0233   |         LDX U9F             ; get current index into work buffer
C4BB | DD 0D 01 | CMP $010D,X |         CMP,X U0AA0         ; check whether this opcode matches the buffer
C4BE | F0 0A    | BEQ $0A     |         BEQ OPOK            ;   matching so far, check the next criteria
C4C0 | 68       | PLA         |         PLA                 ; didn't match, so throw away return address
C4C1 | 68       | PLA         |         PLA                 ;   on the stack because we're starting over
C4C2 | EE 06 01 | INC $0106   | BUMPOP: INC OPCODE          ; check the next opcode
C4C5 | F0 E8    | BEQ $E8     |         BEQ SERROR          ; error if we tried every opcode and none fit
C4C7 | 4C CF C3 | JMP $C3CF   |         JMP ATRYOP          ; start over with new opcode
C4CA | EE 33 02 | INC $0233   | OPOK:   INC U9F             ; opcode matches so far; check the next criteria
C4CD | AE 05 01 | LDX $0105   |         LDX SAVX            ; restore X
C4D0 | 60       | RTS         |         RTS
C4D1 |          |             | 
C4D1 |          |             | ; -----------------------------------------------------------------------------
C4D1 |          |             | ; disassemble [D]
C4D1 | B0 08    | BCS $08     | DISASS: BCS DIS0AD          ; if no address was given, start from last address
C4D3 | 20 38 C7 | JSR $C738   |         JSR COPY12          ; copy start address to TMP2
C4D6 | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get end address in TMP0
C4D9 | 90 06    | BCC $06     |         BCC DIS2AD          ; if one was given, skip default
C4DB | A9 14    | LDA #$14    | DIS0AD: LDA.# $14            ; disassemble 14 bytes by default
C4DD | 85 C1    | STA $C1     |         STA.zp TMP0            ; store length in TMP0
C4DF | D0 05    | BNE $05     |         BNE DISGO           ; skip length calculation
C4E1 | 20 41 C7 | JSR $C741   | DIS2AD: JSR SUB12           ; calculate number of bytes between start and end
C4E4 | 90 1F    | BCC $1F     |         BCC DERROR          ; error if end address is before start address
C4E6 | 20 6B C9 | JSR $C96B   | DISGO:  JSR CLINE           ; clear the current line
C4E9 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
C4EC | F0 14    | BEQ $14     |         BEQ DISEXIT         ; exit early if pressed
C4EE | 20 08 C5 | JSR $C508   |         JSR DSOUT1          ; output disassembly prefix ". "
C4F1 | EE 01 01 | INC $0101   |         INC LENGTH
C4F4 | AD 01 01 | LDA $0101   |         LDA LENGTH          ; add length of last instruction to start address
C4F7 | 20 77 C7 | JSR $C777   |         JSR BUMPAD2
C4FA | AD 01 01 | LDA $0101   |         LDA LENGTH          ; subtract length of last inst from end address
C4FD | 20 51 C7 | JSR $C751   |         JSR SUBA2
C500 | B0 E4    | BCS $E4     |         BCS DISGO
C502 | 4C 61 C0 | JMP $C061   | DISEXIT: JMP STRT            ; back to mainloop
C505 | 4C 90 C0 | JMP $C090   | DERROR: JMP ERROR
C508 |          |             | 
C508 | A9 2E    | LDA #$2E    | DSOUT1: LDA.# '.'            ; output ". " prefix to allow edit and reassemble
C50A | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C50D | 20 D5 C6 | JSR $C6D5   |         JSR SPACE
C510 |          |             | 
C510 | 20 C8 C6 | JSR $C6C8   | DISLIN: JSR SHOWAD          ; show the address of the instruction
C513 | 20 D5 C6 | JSR $C6D5   |         JSR SPACE           ; insert a space
C516 | A0 00    | LDY #$00    |         LDY.# 0              ; no offset
C518 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; load operand of current instruction
C51A | 20 8E C5 | JSR $C58E   |         JSR INSTXX          ; get mnemonic and addressing mode for opcode
C51D | 48       | PHA         |         PHA                 ; save index into mnemonic table
C51E | AE 01 01 | LDX $0101   |         LDX LENGTH          ; get length of operand
C521 | E8       | INX         |         INX                 ; add 1 byte for opcode
C522 | CA       | DEX         | DSBYT:  DEX                 ; decrement index
C523 | 10 0E    | BPL $0E     |         BPL DSHEX           ; show hex for byte being disassembled
C525 | 8C 32 02 | STY $0232   |         STY SAVY            ; save index
C528 | A0 30    | LDY #$30    |         LDY.# MSG8-MSGBAS    ; skip 3 spaces
C52A | 20 84 C9 | JSR $C984   |         JSR SNDMSG
C52D | AC 32 02 | LDY $0232   |         LDY SAVY            ; restore index
C530 | 4C 38 C5 | JMP $C538   |         JMP NXBYT
C533 | B1 C3    | LDA ($C3),Y | DSHEX:  LDA.i,Y TMP2        ; show hex for byte
C535 | 20 D2 C6 | JSR $C6D2   |         JSR WRBYTE
C538 |          |             | 
C538 | C8       | INY         | NXBYT:  INY                 ; next byte
C539 | C0 03    | CPY #$03    |         CPY.# 3              ; have we output 3 bytes yet?
C53B | 90 E5    | BCC $E5     |         BCC DSBYT           ; if not, loop
C53D | 68       | PLA         |         PLA                 ; restore index into mnemonic table
C53E | A2 03    | LDX #$03    |         LDX.# 3              ; 3 letters in mnemonic
C540 | 20 D6 C5 | JSR $C5D6   |         JSR PROPXX          ; print mnemonic
C543 | A2 06    | LDX #$06    |         LDX.# 6              ; 6 possible address mode character combos
C545 | E0 03    | CPX #$03    | PRADR1: CPX.# 3              ; have we checked the third combo yet?
C547 | D0 16    | BNE $16     |         BNE PRADR3          ; if so, output the leading characters
C549 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; get the length of the operand
C54C | F0 11    | BEQ $11     |         BEQ PRADR3          ; if it's zero, there's no operand to print
C54E | AD 00 01 | LDA $0100   | PRADR2: LDA ACMD            ; otherwise, get the addressing mode
C551 | C9 E8    | CMP #$E8    |         CMP.# $E8            ; check for relative addressing
C553 | 08       | PHP         |         PHP                 ; save result of check
C554 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; get the operand
C556 | 28       | PLP         |         PLP                 ; restore result of check
C557 | B0 1D    | BCS $1D     |         BCS RELAD           ; handle a relative address
C559 | 20 F6 C6 | JSR $C6F6   |         JSR WRTWO           ; output digits from address
C55C | 88       | DEY         |         DEY
C55D | D0 EF    | BNE $EF     |         BNE PRADR2          ; repeat for next byte of operand, if there is one
C55F | 0E 00 01 | ASL $0100   | PRADR3: ASL ACMD            ; check whether addr mode uses the current char
C562 | 90 0E    | BCC $0E     |         BCC PRADR4          ; if not, skip it
C564 | BD 16 CA | LDA $CA16,X |         LDA,X CHAR1-1       ; look up the first char in the table
C567 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print first char
C56A | BD 1C CA | LDA $CA1C,X |         LDA,X CHAR2-1       ; look up the second char in the table
C56D | F0 03    | BEQ $03     |         BEQ PRADR4          ; if there's no second character, skip it
C56F | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print second char
C572 | CA       | DEX         | PRADR4: DEX                 ; next potential address mode character
C573 | D0 D0    | BNE $D0     |         BNE PRADR1          ; loop if we haven't checked them all yet
C575 | 60       | RTS         |         RTS                 ; back to caller
C576 | 20 82 C5 | JSR $C582   | RELAD:  JSR UB64D           ; calculate absolute address from relative
C579 | 18       | CLC         |         CLC
C57A | 69 01    | ADC #$01    |         ADC.# 1              ; adjust address relative to next instruction
C57C | D0 01    | BNE $01     |         BNE RELEND          ; don't increment high byte unless we overflowed
C57E | E8       | INX         |         INX                 ; increment high byte
C57F | 4C CC C6 | JMP $C6CC   | RELEND: JMP WRADDR          ; print address
C582 |          |             | 
C582 | A6 C4    | LDX $C4     | UB64D:  LDX.zp TMP2+1          ; get high byte of current address
C584 | A8       | TAY         |         TAY                 ; is relative address positive or negative?
C585 | 10 01    | BPL $01     |         BPL RELC2           ; if positive, leave high byte alone
C587 | CA       | DEX         |         DEX                 ; if negative, decrement high byte
C588 | 65 C3    | ADC $C3     | RELC2:  ADC.zp TMP2            ; add relative address to low byte
C58A | 90 01    | BCC $01     |         BCC RELC3           ; if there's no carry, we're done
C58C | E8       | INX         |         INX                 ; if there's a carry, increment the high byte
C58D | 60       | RTS         | RELC3:  RTS
C58E |          |             | 
C58E |          |             | ; -----------------------------------------------------------------------------
C58E |          |             | ; get opcode mode and length
C58E |          |             | 
C58E |          |             | ; Note: the labels are different, but the code of this subroutine is almost
C58E |          |             | ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
C58E |          |             | ; the Apple II Red Book. I'm not sure exactly where this code originated
C58E |          |             | ; (MOS or Apple) but it's clear that this part of Supermon64 and the 
C58E |          |             | ; Mini-Asssembler share a common heritage.  The comments showing the way the 
C58E |          |             | ; opcodes are transformed into indexes for the mnemonic lookup table come
C58E |          |             | ; from the Mini-Assembler source.
C58E |          |             | 
C58E | A8       | TAY         | INSTXX: TAY                 ; stash opcode in accumulator in Y for later
C58F | 4A       | LSR A       |         LSR.A               ; is opcode even or odd?
C590 | 90 0B    | BCC $0B     |         BCC IEVEN
C592 | 4A       | LSR A       |         LSR.A
C593 | B0 17    | BCS $17     |         BCS ERR             ; invalid opcodes XXXXXX11
C595 | C9 22    | CMP #$22    |         CMP.# $22
C597 | F0 13    | BEQ $13     |         BEQ ERR             ; invalid opcode 10001001
C599 | 29 07    | AND #$07    |         AND.# $07            ; mask bits to 10000XXX
C59B | 09 80    | ORA #$80    |         ORA.# $80
C59D | 4A       | LSR A       | IEVEN:  LSR.A               ; LSB determines whether to use left/right nybble
C59E | AA       | TAX         |         TAX                 ; get format index using remaining high bytes
C59F | BD C5 C9 | LDA $C9C5,X |         LDA,X MODE
C5A2 | B0 04    | BCS $04     |         BCS RTMODE          ; look at left or right nybble based on carry bit
C5A4 | 4A       | LSR A       |         LSR.A               ; if carry = 0, use left nybble
C5A5 | 4A       | LSR A       |         LSR.A
C5A6 | 4A       | LSR A       |         LSR.A
C5A7 | 4A       | LSR A       |         LSR.A
C5A8 | 29 0F    | AND #$0F    | RTMODE: AND.# $0F            ; if carry = 1, use right nybble
C5AA | D0 04    | BNE $04     |         BNE GETFMT
C5AC | A0 80    | LDY #$80    | ERR:    LDY.# $80            ; substitute 10000000 for invalid opcodes
C5AE | A9 00    | LDA #$00    |         LDA.# 0
C5B0 | AA       | TAX         | GETFMT: TAX
C5B1 | BD 09 CA | LDA $CA09,X |         LDA,X MODE2         ; lookup operand format using selected nybble
C5B4 | 8D 00 01 | STA $0100   |         STA ACMD            ; save for later use
C5B7 | 29 03    | AND #$03    |         AND.# $03            ; lower 2 bits indicate number of bytes in operand
C5B9 | 8D 01 01 | STA $0101   |         STA LENGTH
C5BC | 98       | TYA         |         TYA                 ; restore original opcode
C5BD | 29 8F    | AND #$8F    |         AND.# $8F            ; mask bits to X000XXXX
C5BF | AA       | TAX         |         TAX                 ; save it
C5C0 | 98       | TYA         |         TYA                 ; restore original opcode
C5C1 | A0 03    | LDY #$03    |         LDY.# 3
C5C3 | E0 8A    | CPX #$8A    |         CPX.# $8A            ; check if opcode = 1XXX1010
C5C5 | F0 0B    | BEQ $0B     |         BEQ GTFM4
C5C7 | 4A       | LSR A       | GTFM2:  LSR.A               ; transform opcode into index for mnemonic table
C5C8 | 90 08    | BCC $08     |         BCC GTFM4
C5CA | 4A       | LSR A       |         LSR.A               ; opcodes transformed as follows:
C5CB | 4A       | LSR A       | GTFM3:  LSR.A               ; 1XXX1010->00101XXX
C5CC | 09 20    | ORA #$20    |         ORA.# $20            ; XXXYYY01->00111XXX
C5CE | 88       | DEY         |         DEY                 ; XXXYYY10->00111XXX
C5CF | D0 FA    | BNE $FA     |         BNE GTFM3           ; XXXYY100->00110XXX
C5D1 | C8       | INY         |         INY                 ; XXXXX000->000XXXXX
C5D2 | 88       | DEY         | GTFM4:  DEY
C5D3 | D0 F2    | BNE $F2     |         BNE GTFM2
C5D5 | 60       | RTS         |         RTS
C5D6 |          |             | 
C5D6 |          |             | ; -----------------------------------------------------------------------------
C5D6 |          |             | ; extract and print packed mnemonics
C5D6 | A8       | TAY         | PROPXX: TAY                 ; use index in accumulator to look up mnemonic
C5D7 | B9 23 CA | LDA $CA23,Y |         LDA,Y MNEML         ;   and place a temporary copy in STORE
C5DA | 8D 2F 02 | STA $022F   |         STA STORE
C5DD | B9 63 CA | LDA $CA63,Y |         LDA,Y MNEMR
C5E0 | 8D 30 02 | STA $0230   |         STA STORE+1
C5E3 | A9 00    | LDA #$00    | PRMN1:  LDA.# 0              ; clear accumulator
C5E5 | A0 05    | LDY #$05    |         LDY.# $05            ; shift 5 times
C5E7 | 0E 30 02 | ASL $0230   | PRMN2:  ASL STORE+1         ; shift right byte
C5EA | 2E 2F 02 | ROL $022F   |         ROL STORE           ; rotate bits from right byte into left byte
C5ED | 2A       | ROL A       |         ROL.A               ; rotate bits from left byte into accumulator
C5EE | 88       | DEY         |         DEY                 ; next bit
C5EF | D0 F6    | BNE $F6     |         BNE PRMN2           ; loop until all bits shifted
C5F1 | 69 3F    | ADC #$3F    |         ADC.# $3F            ; calculate ascii code for letter by adding to '?'
C5F3 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output letter
C5F6 | CA       | DEX         |         DEX                 ; next letter
C5F7 | D0 EA    | BNE $EA     |         BNE PRMN1           ; loop until all 3 letters are output
C5F9 | 4C D5 C6 | JMP $C6D5   |         JMP SPACE           ; output space
C5FC |          |             | 
C5FC |          |             | ; -----------------------------------------------------------------------------
C5FC |          |             | ; read parameters
C5FC | CE 31 02 | DEC $0231   | RDPAR:  DEC CHRPNT          ; back up one char
C5FF | 20 27 C6 | JSR $C627   | GETPAR: JSR RDVAL           ; read the value
C602 | B0 17    | BCS $17     |         BCS GTERR           ; carry set indicates error
C604 | 20 1B C7 | JSR $C71B   |         JSR GOTCHR          ; check previous character
C607 | D0 0A    | BNE $0A     |         BNE CKTERM          ; if it's not null, check if it's a valid separator
C609 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up one char
C60C | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; get number of digits read
C60F | D0 11    | BNE $11     |         BNE GETGOT          ; found some digits
C611 | F0 0D    | BEQ $0D     |         BEQ GTNIL           ; didn't find any digits
C613 | C9 20    | CMP #$20    | CKTERM: CMP.# $20            ; space or comma are valid separators
C615 | F0 0B    | BEQ $0B     |         BEQ GETGOT          ; anything else is an error
C617 | C9 2C    | CMP #$2C    |         CMP.# ','
C619 | F0 07    | BEQ $07     |         BEQ GETGOT
C61B | 68       | PLA         | GTERR:  PLA                 ; encountered error
C61C | 68       | PLA         |         PLA                 ; get rid of command vector pushed on stack
C61D | 4C 90 C0 | JMP $C090   |         JMP ERROR           ; handle error
C620 | 38       | SEC         | GTNIL:  SEC                 ; set carry to indicate no parameter found
C621 | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (CLC)
C622 | 18       | CLC         | GETGOT: CLC                 ; clear carry to indicate paremeter returned
C623 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; return number of digits in A
C626 | 60       | RTS         |         RTS                 ; return to address pushed from vector table
C627 |          |             | 
C627 |          |             | ; -----------------------------------------------------------------------------
C627 |          |             | ; read a value in the specified base
C627 | A9 00    | LDA #$00    | RDVAL:  LDA.# 0              ; clear temp
C629 | 85 C1    | STA $C1     |         STA.zp TMP0
C62B | 85 C2    | STA $C2     |         STA.zp TMP0+1
C62D | 8D 08 01 | STA $0108   |         STA DIGCNT          ; clear digit counter
C630 | 8A       | TXA         |         TXA                 ; save X and Y
C631 | 48       | PHA         |         PHA
C632 | 98       | TYA         |         TYA
C633 | 48       | PHA         |         PHA
C634 | 20 1E C7 | JSR $C71E   | RDVMOR: JSR GETCHR          ; get next character from input buffer
C637 | F0 1E    | BEQ $1E     |         BEQ RDNILK          ; null at end of buffer
C639 | C9 20    | CMP #$20    |         CMP.# $20            ; skip spaces
C63B | F0 F7    | BEQ $F7     |         BEQ RDVMOR
C63D | A2 03    | LDX #$03    |         LDX.# 3              ; check numeric base [$+&%]
C63F | DD B6 CA | CMP $CAB6,X | GNMODE: CMP,X HIKEY
C642 | F0 07    | BEQ $07     |         BEQ GOTMOD          ; got a match, set up base
C644 | CA       | DEX         |         DEX
C645 | 10 F8    | BPL $F8     |         BPL GNMODE          ; check next base
C647 | E8       | INX         |         INX                 ; default to hex
C648 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up one character
C64B | BC DB CA | LDY $CADB,X | GOTMOD: LDY,X MODTAB        ; get base value
C64E | BD DF CA | LDA $CADF,X |         LDA,X LENTAB        ; get bits per digit
C651 | 8D 0A 01 | STA $010A   |         STA NUMBIT          ; store bits per digit 
C654 | 20 1E C7 | JSR $C71E   | NUDIG:  JSR GETCHR          ; get next char in A
C657 | F0 63    | BEQ $63     | RDNILK: BEQ RDNIL           ; end of number if no more characters
C659 | 38       | SEC         |         SEC
C65A | E9 30    | SBC #$30    |         SBC.# $30            ; subtract ascii value of 0 to get numeric value
C65C | 90 5E    | BCC $5E     |         BCC RDNIL           ; end of number if character was less than 0
C65E | C9 0A    | CMP #$0A    |         CMP.# $0A
C660 | 90 06    | BCC $06     |         BCC DIGMOR          ; not a hex digit if less than A
C662 | E9 07    | SBC #$07    |         SBC.# $07            ; 7 chars between ascii 9 and A, so subtract 7
C664 | C9 10    | CMP #$10    |         CMP.# $10            ; end of number if char is greater than F
C666 | B0 54    | BCS $54     |         BCS RDNIL
C668 | 8D 09 01 | STA $0109   | DIGMOR: STA INDIG           ; store the digit
C66B | CC 09 01 | CPY $0109   |         CPY INDIG           ; compare base with the digit
C66E | 90 4A    | BCC $4A     |         BCC RDERR           ; error if the digit >= the base
C670 | F0 48    | BEQ $48     |         BEQ RDERR
C672 | EE 08 01 | INC $0108   |         INC DIGCNT          ; increment the number of digits
C675 | C0 0A    | CPY #$0A    |         CPY.# 10
C677 | D0 0A    | BNE $0A     |         BNE NODECM          ; skip the next part if not using base 10
C679 | A2 01    | LDX #$01    |         LDX.# 1
C67B | B5 C1    | LDA $C1,X   | DECLP1: LDA.zp,X TMP0          ; stash the previous 16-bit value for later use
C67D | 9D 0B 01 | STA $010B,X |         STA,X STASH
C680 | CA       | DEX         |         DEX
C681 | 10 F8    | BPL $F8     |         BPL DECLP1
C683 | AE 0A 01 | LDX $010A   | NODECM: LDX NUMBIT          ; number of bits to shift
C686 | 06 C1    | ASL $C1     | TIMES2: ASL.zp TMP0            ; shift 16-bit value by specified number of bits
C688 | 26 C2    | ROL $C2     |         ROL.zp TMP0+1
C68A | B0 2E    | BCS $2E     |         BCS RDERR           ; error if we overflowed 16 bits
C68C | CA       | DEX         |         DEX
C68D | D0 F7    | BNE $F7     |         BNE TIMES2          ; shift remaining bits
C68F | C0 0A    | CPY #$0A    |         CPY.# 10
C691 | D0 18    | BNE $18     |         BNE NODEC2          ; skip the next part if not using base 10
C693 | 0E 0B 01 | ASL $010B   |         ASL STASH           ; shift the previous 16-bit value one bit left
C696 | 2E 0C 01 | ROL $010C   |         ROL STASH+1
C699 | B0 1F    | BCS $1F     |         BCS RDERR           ; error if we overflowed 16 bits
C69B | AD 0B 01 | LDA $010B   |         LDA STASH           ; add shifted previous value to current value
C69E | 65 C1    | ADC $C1     |         ADC.zp TMP0
C6A0 | 85 C1    | STA $C1     |         STA.zp TMP0
C6A2 | AD 0C 01 | LDA $010C   |         LDA STASH+1
C6A5 | 65 C2    | ADC $C2     |         ADC.zp TMP0+1
C6A7 | 85 C2    | STA $C2     |         STA.zp TMP0+1
C6A9 | B0 0F    | BCS $0F     |         BCS RDERR           ; error if we overflowed 16 bits
C6AB | 18       | CLC         | NODEC2: CLC 
C6AC | AD 09 01 | LDA $0109   |         LDA INDIG           ; load current digit
C6AF | 65 C1    | ADC $C1     |         ADC.zp TMP0            ; add current digit to low byte
C6B1 | 85 C1    | STA $C1     |         STA.zp TMP0            ; and store result back in low byte
C6B3 | 8A       | TXA         |         TXA                 ; A=0
C6B4 | 65 C2    | ADC $C2     |         ADC.zp TMP0+1          ; add carry to high byte
C6B6 | 85 C2    | STA $C2     |         STA.zp TMP0+1          ; and store result back in high byte
C6B8 | 90 9A    | BCC $9A     |         BCC NUDIG           ; get next digit if we didn't overflow
C6BA | 38       | SEC         | RDERR:  SEC                 ; set carry to indicate error
C6BB | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (CLC)
C6BC | 18       | CLC         | RDNIL:  CLC                 ; clear carry to indicate success
C6BD | 8C 0A 01 | STY $010A   |         STY NUMBIT          ; save base of number
C6C0 | 68       | PLA         |         PLA                 ; restore X and Y
C6C1 | A8       | TAY         |         TAY
C6C2 | 68       | PLA         |         PLA
C6C3 | AA       | TAX         |         TAX
C6C4 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; return number of digits in A
C6C7 | 60       | RTS         |         RTS
C6C8 |          |             | 
C6C8 |          |             | ; -----------------------------------------------------------------------------
C6C8 |          |             | ; print address
C6C8 | A5 C3    | LDA $C3     | SHOWAD: LDA.zp TMP2
C6CA | A6 C4    | LDX $C4     |         LDX.zp TMP2+1
C6CC |          |             | 
C6CC | 48       | PHA         | WRADDR: PHA                 ; save low byte
C6CD | 8A       | TXA         |         TXA                 ; put high byte in A
C6CE | 20 F6 C6 | JSR $C6F6   |         JSR WRTWO           ; output high byte
C6D1 | 68       | PLA         |         PLA                 ; restore low byte
C6D2 |          |             | 
C6D2 | 20 F6 C6 | JSR $C6F6   | WRBYTE: JSR WRTWO           ; output byte in A
C6D5 |          |             | 
C6D5 | A9 20    | LDA #$20    | SPACE:  LDA.# $20            ; output space
C6D7 | D0 0F    | BNE $0F     |         BNE FLIP
C6D9 |          |             | 
C6D9 | C9 0D    | CMP #$0D    | CHOUT:  CMP.# $0D            ; output char with special handling of CR
C6DB | D0 0B    | BNE $0B     |         BNE FLIP
C6DD | A9 0D    | LDA #$0D    | CRLF:   LDA.# $0D            ; load CR in A
C6DF | 24 13    | BIT $13     |         BIT.zp $13             ; check default channel
C6E1 | 10 05    | BPL $05     |         BPL FLIP            ; if high bit is clear output CR only
C6E3 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; otherwise output CR+LF
C6E6 | A9 0A    | LDA #$0A    |         LDA.# $0A            ; output LF
C6E8 | 4C D2 FF | JMP $FFD2   | FLIP:   JMP CHROUT
C6EB |          |             | 
C6EB | 20 DD C6 | JSR $C6DD   | FRESH:  JSR CRLF            ; output CR
C6EE | A9 20    | LDA #$20    |         LDA.# $20            ; load space in A
C6F0 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C6F3 | 4C 74 C9 | JMP $C974   |         JMP SNCLR
C6F6 |          |             | 
C6F6 |          |             | ; -----------------------------------------------------------------------------
C6F6 |          |             | ; output two hex digits for byte
C6F6 | 8E 05 01 | STX $0105   | WRTWO:  STX SAVX            ; save X
C6F9 | 20 06 C7 | JSR $C706   |         JSR ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
C6FC | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output upper nybble
C6FF | 8A       | TXA         |         TXA                 ; transfer lower to A
C700 | AE 05 01 | LDX $0105   |         LDX SAVX            ; restore X
C703 | 4C D2 FF | JMP $FFD2   |         JMP CHROUT          ; output lower nybble
C706 |          |             | 
C706 |          |             | ; -----------------------------------------------------------------------------
C706 |          |             | ; convert byte in A to hex digits
C706 | 48       | PHA         | ASCTWO: PHA                 ; save byte
C707 | 20 10 C7 | JSR $C710   |         JSR ASCII           ; do low nybble
C70A | AA       | TAX         |         TAX                 ; save in X
C70B | 68       | PLA         |         PLA                 ; restore byte
C70C | 4A       | LSR A       |         LSR.A               ; shift upper nybble down
C70D | 4A       | LSR A       |         LSR.A
C70E | 4A       | LSR A       |         LSR.A
C70F | 4A       | LSR A       |         LSR.A
C710 |          |             | 
C710 |          |             | ; convert low nybble in A to hex digit
C710 | 29 0F    | AND #$0F    | ASCII:  AND.# $0F            ; clear upper nibble
C712 | C9 0A    | CMP #$0A    |         CMP.# $0A            ; if less than A, skip next step
C714 | 90 02    | BCC $02     |         BCC ASC1
C716 | 69 06    | ADC #$06    |         ADC.# 6              ; skip ascii chars between 9 and A
C718 | 69 30    | ADC #$30    | ASC1:   ADC.# $30            ; add ascii char 0 to value
C71A | 60       | RTS         |         RTS
C71B |          |             | 
C71B |          |             | ; -----------------------------------------------------------------------------
C71B |          |             | ; get prev char from input buffer
C71B | CE 31 02 | DEC $0231   | GOTCHR: DEC CHRPNT
C71E |          |             | 
C71E |          |             | ; get next char from input buffer
C71E | 8E 05 01 | STX $0105   | GETCHR: STX SAVX
C721 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; get pointer to next char
C724 | BD 00 02 | LDA $0200,X |         LDA,X INBUFF        ; load next char in A
C727 | F0 06    | BEQ $06     |         BEQ NOCHAR          ; null, :, or ? signal end of buffer
C729 | C9 3A    | CMP #$3A    |         CMP.# ':'        
C72B | F0 02    | BEQ $02     |         BEQ NOCHAR
C72D | C9 3F    | CMP #$3F    |         CMP.# '?'
C72F | 08       | PHP         | NOCHAR: PHP
C730 | EE 31 02 | INC $0231   |         INC CHRPNT          ; next char
C733 | AE 05 01 | LDX $0105   |         LDX SAVX
C736 | 28       | PLP         |         PLP                 ; Z flag will signal last character
C737 | 60       | RTS         |         RTS
C738 |          |             | 
C738 |          |             | ; -----------------------------------------------------------------------------
C738 |          |             | ; copy TMP0 to TMP2
C738 | A5 C1    | LDA $C1     | COPY12: LDA.zp TMP0            ; low byte
C73A | 85 C3    | STA $C3     |         STA.zp TMP2
C73C | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; high byte
C73E | 85 C4    | STA $C4     |         STA.zp TMP2+1
C740 | 60       | RTS         |         RTS
C741 |          |             | 
C741 |          |             | ; -----------------------------------------------------------------------------
C741 |          |             | ; subtract TMP2 from TMP0
C741 | 38       | SEC         | SUB12:  SEC
C742 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; subtract low byte
C744 | E5 C3    | SBC $C3     |         SBC.zp TMP2
C746 | 85 C1    | STA $C1     |         STA.zp TMP0
C748 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
C74A | E5 C4    | SBC $C4     |         SBC.zp TMP2+1          ; subtract high byte
C74C | 85 C2    | STA $C2     |         STA.zp TMP0+1
C74E | 60       | RTS         |         RTS
C74F |          |             | 
C74F |          |             | ; -----------------------------------------------------------------------------
C74F |          |             | ; subtract from TMP0
C74F | A9 01    | LDA #$01    | SUBA1:  LDA.# 1              ; shortcut to decrement by 1
C751 | 8D 05 01 | STA $0105   | SUBA2:  STA SAVX            ; subtrahend in accumulator
C754 | 38       | SEC         |         SEC
C755 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; minuend in low byte
C757 | ED 05 01 | SBC $0105   |         SBC SAVX
C75A | 85 C1    | STA $C1     |         STA.zp TMP0
C75C | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; borrow from high byte
C75E | E9 00    | SBC #$00    |         SBC.# 0
C760 | 85 C2    | STA $C2     |         STA.zp TMP0+1
C762 | 60       | RTS         |         RTS
C763 |          |             | 
C763 |          |             | ; -----------------------------------------------------------------------------
C763 |          |             | ; subtract 1 from STORE
C763 | 38       | SEC         | SUB13:  SEC
C764 | AD 2F 02 | LDA $022F   |         LDA STORE
C767 | E9 01    | SBC #$01    |         SBC.# 1              ; decrement low byte
C769 | 8D 2F 02 | STA $022F   |         STA STORE
C76C | AD 30 02 | LDA $0230   |         LDA STORE+1
C76F | E9 00    | SBC #$00    |         SBC.# 0              ; borrow from high byte
C771 | 8D 30 02 | STA $0230   |         STA STORE+1
C774 | 60       | RTS         |         RTS
C775 |          |             | 
C775 |          |             | ; -----------------------------------------------------------------------------
C775 |          |             | ; add to TMP2
C775 | A9 01    | LDA #$01    | ADDA2:  LDA.# 1              ; shortcut to increment by 1
C777 | 18       | CLC         | BUMPAD2: CLC
C778 | 65 C3    | ADC $C3     |         ADC.zp TMP2            ; add value in accumulator to low byte
C77A | 85 C3    | STA $C3     |         STA.zp TMP2
C77C | 90 02    | BCC $02     |         BCC BUMPEX
C77E | E6 C4    | INC $C4     |         INC.zp TMP2+1          ; carry to high byte
C780 | 60       | RTS         | BUMPEX: RTS 
C781 |          |             | 
C781 |          |             | ; -----------------------------------------------------------------------------
C781 |          |             | ; subtract 1 from TMP2
C781 | 38       | SEC         | SUB21:  SEC
C782 | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; decrement low byte
C784 | E9 01    | SBC #$01    |         SBC.# 1
C786 | 85 C3    | STA $C3     |         STA.zp TMP2
C788 | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ; borrow from high byte
C78A | E9 00    | SBC #$00    |         SBC.# 0
C78C | 85 C4    | STA $C4     |         STA.zp TMP2+1
C78E | 60       | RTS         |         RTS
C78F |          |             | 
C78F |          |             | ; -----------------------------------------------------------------------------
C78F |          |             | ; copy TMP0 to PC
C78F | B0 0A    | BCS $0A     | COPY1P: BCS CPY1PX          ; do nothing if parameter is empty
C791 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; copy low byte
C793 | A4 C2    | LDY $C2     |         LDY.zp TMP0+1          ; copy high byte
C795 | 8D 29 02 | STA $0229   |         STA PCL
C798 | 8C 28 02 | STY $0228   |         STY PCH
C79B | 60       | RTS         | CPY1PX: RTS 
C79C |          |             | 
C79C |          |             | ; -----------------------------------------------------------------------------
C79C |          |             | ; get start/end addresses and calc difference
C79C | B0 23    | BCS $23     | GETDIF: BCS GDIFX           ; exit with error if no parameter given
C79E | 20 38 C7 | JSR $C738   |         JSR COPY12          ; save start address in TMP2
C7A1 | 20 FF C5 | JSR $C5FF   |         JSR GETPAR          ; get end address in TMP0
C7A4 | B0 1B    | BCS $1B     |         BCS GDIFX           ; exit with error if no parameter given
C7A6 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; save end address in STASH
C7A8 | 8D 0B 01 | STA $010B   |         STA STASH
C7AB | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
C7AD | 8D 0C 01 | STA $010C   |         STA STASH+1
C7B0 | 20 41 C7 | JSR $C741   |         JSR SUB12           ; subtract start address from end address
C7B3 | A5 C1    | LDA $C1     |         LDA.zp TMP0
C7B5 | 8D 2F 02 | STA $022F   |         STA STORE           ; save difference in STORE
C7B8 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
C7BA | 8D 30 02 | STA $0230   |         STA STORE+1
C7BD | 90 02    | BCC $02     |         BCC GDIFX           ; error if start address is after end address
C7BF | 18       | CLC         |         CLC                 ; clear carry to indicate success
C7C0 | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (SEC)
C7C1 | 38       | SEC         | GDIFX:  SEC                 ; set carry to indicate error
C7C2 | 60       | RTS         |         RTS
C7C3 |          |             | 
C7C3 |          |             | ; -----------------------------------------------------------------------------
C7C3 |          |             | ; convert base [$+&%]
C7C3 | 20 FC C5 | JSR $C5FC   | CONVRT: JSR RDPAR           ; read a parameter
C7C6 | 20 EB C6 | JSR $C6EB   |         JSR FRESH           ; next line and clear
C7C9 | A9 24    | LDA #$24    |         LDA.#  $24;'$'            ; output $ sigil for hex
C7CB | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C7CE | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load the 16-bit value entered
C7D0 | A6 C2    | LDX $C2     |         LDX.zp TMP0+1
C7D2 | 20 CC C6 | JSR $C6CC   |         JSR WRADDR          ; print it in 4 hex digits
C7D5 | 20 EB C6 | JSR $C6EB   |         JSR FRESH
C7D8 | A9 2B    | LDA #$2B    |         LDA.# '+'            ; output + sigil for decimal
C7DA | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C7DD | 20 0E C8 | JSR $C80E   |         JSR CVTDEC          ; convert to BCD using hardware mode
C7E0 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
C7E2 | A2 06    | LDX #$06    |         LDX.# 6              ; max digits + 1
C7E4 | A0 03    | LDY #$03    |         LDY.# 3              ; bits per digit - 1
C7E6 | 20 48 C8 | JSR $C848   |         JSR NMPRNT          ; print result without leading zeros
C7E9 | 20 EB C6 | JSR $C6EB   |         JSR FRESH           ; next line and clear
C7EC | A9 26    | LDA #$26    |         LDA.# $26 ;'&'            ; print & sigil for octal
C7EE | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C7F1 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
C7F3 | A2 08    | LDX #$08    |         LDX.# 8              ; max digits + 1
C7F5 | A0 02    | LDY #$02    |         LDY.# 2              ; bits per digit - 1
C7F7 | 20 37 C8 | JSR $C837   |         JSR PRINUM          ; output number
C7FA | 20 EB C6 | JSR $C6EB   |         JSR FRESH           ; next line and clear
C7FD | A9 25    | LDA #$25    |         LDA.# '%'            ; print % sigil for binary
C7FF | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C802 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
C804 | A2 18    | LDX #$18    |         LDX.# $18            ; max digits + 1
C806 | A0 00    | LDY #$00    |         LDY.# 0              ; bits per digit - 1
C808 | 20 37 C8 | JSR $C837   |         JSR PRINUM          ; output number
C80B | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to mainloop
C80E |          |             | 
C80E |          |             | ; -----------------------------------------------------------------------------
C80E |          |             | ; convert binary to BCD
C80E |          |             | 
C80E | 20 38 C7 | JSR $C738   | CVTDEC: JSR COPY12          ; copy value from TMP0 to TMP2
C811 | A9 00    | LDA #$00    |         LDA.# 0
C813 | A2 02    | LDX #$02    |         LDX.# 2              ; clear 3 bytes in work buffer
C815 | 9D 0D 01 | STA $010D,X | DECML1: STA,X U0AA0
C818 | CA       | DEX         |         DEX
C819 | 10 FA    | BPL $FA     |         BPL DECML1
C81B | A0 10    | LDY #$10    |         LDY.# 16             ; 16 bits in input
C81D | 08       | PHP         |         PHP                 ; save status register
C81E | 78       | SEI         |         SEI                 ; make sure no interrupts occur with BCD enabled
C81F | F8       | SED         |         SED
C820 | 06 C3    | ASL $C3     | DECML2: ASL.zp TMP2            ; rotate bytes out of input low byte
C822 | 26 C4    | ROL $C4     |         ROL.zp TMP2+1          ; .. into high byte and carry bit
C824 | A2 02    | LDX #$02    |         LDX.# 2              ; process 3 bytes
C826 | BD 0D 01 | LDA $010D,X | DECDBL: LDA,X U0AA0         ; load current value of byte
C829 | 7D 0D 01 | ADC $010D,X |         ADC,X U0AA0         ; add it to itself plus the carry bit
C82C | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; store it back in the same location
C82F | CA       | DEX         |         DEX                 ; decrement byte counter
C830 | 10 F4    | BPL $F4     |         BPL DECDBL          ; loop until all bytes processed
C832 | 88       | DEY         |         DEY                 ; decrement bit counter
C833 | D0 EB    | BNE $EB     |         BNE DECML2          ; loop until all bits processed
C835 | 28       | PLP         |         PLP                 ; restore processor status
C836 | 60       | RTS         |         RTS
C837 |          |             | 
C837 |          |             | ; load the input value and fall through to print it
C837 | 48       | PHA         | PRINUM: PHA                 ; save accumulator
C838 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; copy input low byte to work buffer
C83A | 8D 0F 01 | STA $010F   |         STA U0AA0+2
C83D | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; copy input high byte to work buffer
C83F | 8D 0E 01 | STA $010E   |         STA U0AA0+1
C842 | A9 00    | LDA #$00    |         LDA.# 0              ; clear overflow byte in work buffer
C844 | 8D 0D 01 | STA $010D   |         STA U0AA0
C847 | 68       | PLA         |         PLA                 ; restore accumulator
C848 |          |             | 
C848 |          |             | ; print number in specified base without leading zeros
C848 | 8D 08 01 | STA $0108   | NMPRNT: STA DIGCNT          ; number of digits in accumulator
C84B | 8C 0A 01 | STY $010A   |         STY NUMBIT          ; bits per digit passed in Y register
C84E | AC 0A 01 | LDY $010A   | DIGOUT: LDY NUMBIT          ; get bits to process
C851 | A9 00    | LDA #$00    |         LDA.# 0              ; clear accumulator
C853 | 0E 0F 01 | ASL $010F   | ROLBIT: ASL U0AA0+2         ; shift bits out of low byte
C856 | 2E 0E 01 | ROL $010E   |         ROL U0AA0+1         ; ... into high byte
C859 | 2E 0D 01 | ROL $010D   |         ROL U0AA0           ; ... into overflow byte
C85C | 2A       | ROL A       |         ROL.A               ; ... into accumulator
C85D | 88       | DEY         |         DEY                 ; decrement bit counter
C85E | 10 F3    | BPL $F3     |         BPL ROLBIT          ; loop until all bits processed
C860 | A8       | TAY         |         TAY                 ; check whether accumulator is 0
C861 | D0 09    | BNE $09     |         BNE NZERO           ; if not, print it
C863 | E0 01    | CPX #$01    |         CPX.# 1              ; have we output the max number of digits?
C865 | F0 05    | BEQ $05     |         BEQ NZERO           ; if not, print it
C867 | AC 08 01 | LDY $0108   |         LDY DIGCNT          ; how many digits have we output?
C86A | F0 08    | BEQ $08     |         BEQ ZERSUP          ; skip output if digit is 0
C86C | EE 08 01 | INC $0108   | NZERO:  INC DIGCNT          ; increment digit counter
C86F | 09 30    | ORA #$30    |         ORA.# $30            ; add numeric value to ascii '0' to get ascii char
C871 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output character
C874 | CA       | DEX         | ZERSUP: DEX                 ; decrement number of leading zeros
C875 | D0 D7    | BNE $D7     |         BNE DIGOUT          ; next digit
C877 | 60       | RTS         |         RTS
C878 |          |             | 
C878 |          |             | ; -----------------------------------------------------------------------------
C878 |          |             | ; disk status/command [@]
C878 | D0 03    | BNE $03     | DSTAT:  BNE CHGDEV          ; if device address was given, use it
C87A | A2 08    | LDX #$08    |         LDX.# 8              ; otherwise, default to 8
C87C | 2C       |             |         DATA.b $2C           ; absolute BIT opcode consumes next word (LDX TMP0)
C87D | A6 C1    | LDX $C1     | CHGDEV: LDX.zp TMP0            ; load device address from parameter
C87F | E0 04    | CPX #$04    |         CPX.# 4              ; make sure device address is in range 4-31
C881 | 90 58    | BCC $58     |         BCC IOERR
C883 | E0 20    | CPX #$20    |         CPX.# 32
C885 | B0 54    | BCS $54     |         BCS IOERR
C887 | 86 C1    | STX $C1     |         STX.zp TMP0
C889 | A9 00    | LDA #$00    |         LDA.# 0              ; clear status
C88B | 85 90    | STA $90     |         STA.zp SATUS
C88D | 85 B7    | STA $B7     |         STA.zp FNLEN           ; empty filename
C88F | 20 1E C7 | JSR $C71E   |         JSR GETCHR          ; get next character
C892 | F0 24    | BEQ $24     |         BEQ INSTAT1         ; null, display status
C894 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up 1 char
C897 | C9 24    | CMP #$24    |         CMP.#  $24 ;'$'            ; $, display directory
C899 | F0 43    | BEQ $43     |         BEQ DIRECT
C89B | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; command specified device to listen
C89D | 20 B1 FF | JSR $FFB1   |         JSR LISTEN
C8A0 | A9 6F    | LDA #$6F    |         LDA.# $6F            ; secondary address 15 (only low nybble used)
C8A2 | 20 93 FF | JSR $FF93   |         JSR SECOND
C8A5 |          |             | 
C8A5 |          |             | ; send command to device
C8A5 | AE 31 02 | LDX $0231   | DCOMD:  LDX CHRPNT          ; get next character from buffer
C8A8 | EE 31 02 | INC $0231   |         INC CHRPNT
C8AB | BD 00 02 | LDA $0200,X |         LDA,X INBUFF
C8AE | F0 05    | BEQ $05     |         BEQ INSTAT          ; break out of loop if it's null
C8B0 | 20 A8 FF | JSR $FFA8   |         JSR CIOUT           ; otherwise output it to the serial bus
C8B3 | 90 F0    | BCC $F0     |         BCC DCOMD           ; unconditional loop: CIOUT clears carry before RTS
C8B5 |          |             | 
C8B5 |          |             | ; get device status
C8B5 | 20 AE FF | JSR $FFAE   | INSTAT: JSR UNLSN           ; command device to unlisten
C8B8 | 20 DD C6 | JSR $C6DD   | INSTAT1: JSR CRLF            ; new line
C8BB | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load device address
C8BD | 20 B4 FF | JSR $FFB4   |         JSR TALK            ; command device to talk
C8C0 | A9 6F    | LDA #$6F    |         LDA.# $6F            ; secondary address 15 (only low nybble used)
C8C2 | 20 96 FF | JSR $FF96   |         JSR TKSA
C8C5 | 20 A5 FF | JSR $FFA5   | RDSTAT: JSR ACPTR           ; read byte from serial bus
C8C8 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print it
C8CB | C9 0D    | CMP #$0D    |         CMP.# $0D            ; if the byte is CR, exit loop
C8CD | F0 06    | BEQ $06     |         BEQ DEXIT
C8CF | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
C8D1 | 29 BF    | AND #$BF    |         AND.# $BF            ; ignore EOI bit
C8D3 | F0 F0    | BEQ $F0     |         BEQ RDSTAT          ; if no errors, read next byte
C8D5 | 20 AB FF | JSR $FFAB   | DEXIT:  JSR UNTLK           ; command device to stop talking
C8D8 | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to mainloop
C8DB | 4C 90 C0 | JMP $C090   | IOERR:  JMP ERROR           ; handle error
C8DE |          |             | 
C8DE |          |             | ; get directory
C8DE | A5 C1    | LDA $C1     | DIRECT: LDA.zp TMP0            ; load device address
C8E0 | 20 B1 FF | JSR $FFB1   |         JSR LISTEN          ; command device to listen
C8E3 | A9 F0    | LDA #$F0    |         LDA.# $F0            ; secondary address 0 (only low nybble used)
C8E5 | 20 93 FF | JSR $FF93   |         JSR SECOND
C8E8 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; get index of next character
C8EB | BD 00 02 | LDA $0200,X | DIR2:   LDA,X INBUFF        ; get next character from buffer
C8EE | F0 06    | BEQ $06     |         BEQ DIR3            ; break if it's null
C8F0 | 20 A8 FF | JSR $FFA8   |         JSR CIOUT           ; send character to device
C8F3 | E8       | INX         |         INX                 ; increment characer index
C8F4 | D0 F5    | BNE $F5     |         BNE DIR2            ; loop if it hasn't wrapped to zero
C8F6 | 20 AE FF | JSR $FFAE   | DIR3:   JSR UNLSN           ; command device to unlisten
C8F9 | 20 DD C6 | JSR $C6DD   |         JSR CRLF            ; new line
C8FC | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load device address
C8FE | 48       | PHA         |         PHA                 ; save on stack
C8FF | 20 B4 FF | JSR $FFB4   |         JSR TALK            ; command device to talk
C902 | A9 60    | LDA #$60    |         LDA.# $60            ; secondary address 0 (only low nybble used)
C904 | 20 96 FF | JSR $FF96   |         JSR TKSA
C907 | A0 03    | LDY #$03    |         LDY.# 3              ; read 3 16-bit values from device
C909 | 8C 2F 02 | STY $022F   | DIRLIN: STY STORE           ;   ignore the first 2; 3rd is file size
C90C | 20 A5 FF | JSR $FFA5   | DLINK:  JSR ACPTR           ; read low byte from device
C90F | 85 C1    | STA $C1     |         STA.zp TMP0            ; store it
C911 | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
C913 | D0 44    | BNE $44     |         BNE DREXIT          ; exit if error or eof occurred
C915 | 20 A5 FF | JSR $FFA5   |         JSR ACPTR           ; read high byte from device
C918 | 85 C2    | STA $C2     |         STA.zp TMP0+1          ; store it
C91A | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
C91C | D0 3B    | BNE $3B     |         BNE DREXIT          ; exit if error or eof cocurred
C91E | CE 2F 02 | DEC $022F   |         DEC STORE           ; decrement byte count
C921 | D0 E9    | BNE $E9     |         BNE DLINK           ; loop if bytes remain
C923 | 20 0E C8 | JSR $C80E   |         JSR CVTDEC          ; convert last 16-bit value to decimal
C926 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit count
C928 | A2 06    | LDX #$06    |         LDX.# 6              ; max 6 digits
C92A | A0 03    | LDY #$03    |         LDY.# 3              ; 3 bits per digit
C92C | 20 48 C8 | JSR $C848   |         JSR NMPRNT          ; output number
C92F | A9 20    | LDA #$20    |         LDA.# ' '            ; output space
C931 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C934 | 20 A5 FF | JSR $FFA5   | DNAME:  JSR ACPTR           ; get a filename character from the device
C937 | F0 0A    | BEQ $0A     |         BEQ DMORE           ; if it's null, break out of loop
C939 | A6 90    | LDX $90     |         LDX.zp SATUS           ; check for errors or eof
C93B | D0 1C    | BNE $1C     |         BNE DREXIT          ; if found exit early
C93D | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output character
C940 | 18       | CLC         |         CLC
C941 | 90 F1    | BCC $F1     |         BCC DNAME           ; unconditional branch to read next char
C943 | 20 DD C6 | JSR $C6DD   | DMORE:  JSR CRLF
C946 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
C949 | F0 0E    | BEQ $0E     |         BEQ DREXIT          ; exit early if pressed
C94B | 20 E4 FF | JSR $FFE4   |         JSR GETIN           ; pause if a key was pressed
C94E | F0 05    | BEQ $05     |         BEQ NOPAWS
C950 | 20 E4 FF | JSR $FFE4   | PAWS:   JSR GETIN           ; wait until another key is pressed
C953 | F0 FB    | BEQ $FB     |         BEQ PAWS            
C955 | A0 02    | LDY #$02    | NOPAWS: LDY.# 2
C957 | D0 B0    | BNE $B0     |         BNE DIRLIN          ; unconditional branch to read next file
C959 | 20 AB FF | JSR $FFAB   | DREXIT: JSR UNTLK           ; command device to untalk
C95C | 68       | PLA         |         PLA                 ; restore accumulator
C95D | 20 B1 FF | JSR $FFB1   |         JSR LISTEN          ; command device to listen
C960 | A9 E0    | LDA #$E0    |         LDA.# $E0            ; secondary address 0 (only low nybble is used)
C962 | 20 93 FF | JSR $FF93   |         JSR SECOND
C965 | 20 AE FF | JSR $FFAE   |         JSR UNLSN           ; command device to unlisten
C968 | 4C 61 C0 | JMP $C061   |         JMP STRT            ; back to mainloop
C96B |          |             | 
C96B |          |             | ; -----------------------------------------------------------------------------
C96B |          |             | ; print and clear routines
C96B | 20 DD C6 | JSR $C6DD   | CLINE:  JSR CRLF            ; send CR+LF
C96E | 4C 74 C9 | JMP $C974   |         JMP SNCLR           ; clear line
C971 | 20 84 C9 | JSR $C984   | SNDCLR: JSR SNDMSG
C974 | A0 28    | LDY #$28    | SNCLR:  LDY.# $28            ; loop 40 times
C976 | A9 20    | LDA #$20    | SNCLP:  LDA.# $20            ; output space character
C978 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C97B | A9 14    | LDA #$14    |         LDA.# $14            ; output delete character
C97D | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
C980 | 88       | DEY         |         DEY
C981 | D0 F3    | BNE $F3     |         BNE SNCLP
C983 | 60       | RTS         |         RTS
C984 |          |             | 
C984 |          |             | ; -----------------------------------------------------------------------------
C984 |          |             | ; display message from table
C984 | B9 92 C9 | LDA $C992,Y | SNDMSG: LDA,Y MSGBAS        ; Y contains offset in msg table
C987 | 08       | PHP         |         PHP
C988 | 29 7F    | AND #$7F    |         AND.# $7F            ; strip high bit before output
C98A | 20 D9 C6 | JSR $C6D9   |         JSR CHOUT
C98D | C8       | INY         |         INY
C98E | 28       | PLP         |         PLP
C98F | 10 F3    | BPL $F3     |         BPL SNDMSG          ; loop until high bit is set
C991 | 60       | RTS         |         RTS
C992 |          |             | 
C992 |          |             | ; -----------------------------------------------------------------------------
C992 |          |             | ; message table; last character has high bit set
C992 |          |             | MSGBAS:
C992 | 0D       |             | MSG2:   DATA.b $0D               ; header for registers
C993 |          |             |         ;.TEXT "   PC  SR AC XR YR SP   V1.2"
C993 | 20       |             |         DATA.b ' '
C994 | 20       |             |         DATA.b ' '
C995 | 20       |             |         DATA.b ' '
C996 | 50       |             |         DATA.b 'P'
C997 | 43       |             |         DATA.b 'C'
C998 | 20       |             |         DATA.b ' '
C999 | 20       |             |         DATA.b ' '
C99A | 53       |             |         DATA.b 'S'
C99B | 52       |             |         DATA.b 'R'
C99C | 20       |             |         DATA.b ' '
C99D | 41       |             |         DATA.b 'A'
C99E | 43       |             |         DATA.b 'C'
C99F | 20       |             |         DATA.b ' '
C9A0 | 58       |             |         DATA.b 'X'
C9A1 | 52       |             |         DATA.b 'R'
C9A2 | 20       |             |         DATA.b ' '
C9A3 | 59       |             |         DATA.b 'Y'
C9A4 | 52       |             |         DATA.b 'R'
C9A5 | 20       |             |         DATA.b ' '
C9A6 | 53       |             |         DATA.b 'S'
C9A7 | 50       |             |         DATA.b 'P'
C9A8 | 20       |             |         DATA.b ' '
C9A9 | 20       |             |         DATA.b ' '
C9AA | 20       |             |         DATA.b ' '
C9AB | 56       |             |         DATA.b 'V'
C9AC | 31       |             |         DATA.b '1'
C9AD | 2E       |             |         DATA.b '.'
C9AE | 32       |             |         DATA.b '2'
C9AF | 8D       |             |         DATA.b $0D+$80
C9B0 |          |             | 
C9B0 | 1D       |             | MSG3:   DATA.b $1D
C9B1 | BF       |             |         DATA.b $3F+$80       ; syntax error: move right, display "?"
C9B2 |          |             | 
C9B2 |          |             | MSG4:   ;.TEXT "..SYS"           ; SYS call to enter monitor
C9B2 | 2E       |             |         DATA.b '.'
C9B3 | 2E       |             |         DATA.b '.'
C9B4 | 53       |             |         DATA.b 'S'
C9B5 | 59       |             |         DATA.b 'Y'
C9B6 | 53       |             |         DATA.b 'S'
C9B7 |          |             | 
C9B7 | A0       |             |         DATA.b $20+$80
C9B8 |          |             | 
C9B8 | 3A       |             | MSG5:   DATA.b $3A
C9B9 | 92       |             |         DATA.b $12+$80       ; ":" then RVS ON for memory ASCII dump
C9BA |          |             | 
C9BA |          |             | MSG6:   ;.TEXT " ERRO"           ; I/O error: display " ERROR"
C9BA | 20       |             |         DATA.b ' '
C9BB | 45       |             |         DATA.b 'E'
C9BC | 52       |             |         DATA.b 'R'
C9BD | 52       |             |         DATA.b 'R'
C9BE | 4F       |             |         DATA.b 'O'
C9BF | D2       |             |         DATA.b 'R'+$80
C9C0 |          |             | 
C9C0 | 41       |             | MSG7:   DATA.b $41
C9C1 | A0       |             |         DATA.b $20+$80       ; assemble next instruction: "A " + addr
C9C2 |          |             | 
C9C2 |          |             | MSG8:   ; .TEXT "  "              ; pad non-existent byte: skip 3 spaces
C9C2 | 20       |             |         DATA.b ' '
C9C3 | 20       |             |         DATA.b ' '
C9C4 | A0       |             |         DATA.b $20+$80
C9C5 |          |             | 
C9C5 |          |             | 
C9C5 |          |             | ; -----------------------------------------------------------------------------
C9C5 |          |             | ; addressing mode table - nybbles provide index into MODE2 table
C9C5 |          |             | ; for opcodes XXXXXXY0, use XXXXXX as index into table
C9C5 |          |             | ; for opcodes WWWXXY01  use $40 + XX as index into table
C9C5 |          |             | ; use right nybble if Y=0; use left nybble if Y=1
C9C5 |          |             | 
C9C5 | 40       |             | MODE:   DATA.b $40
C9C6 | 02       |             |         DATA.b $02
C9C7 | 45       |             |         DATA.b $45
C9C8 | 03       |             |         DATA.b $03   ; even opcodes
C9C9 | D0       |             |         DATA.b $D0
C9CA | 08       |             |         DATA.b $08
C9CB | 40       |             |         DATA.b $40
C9CC | 09       |             |         DATA.b $09
C9CD | 30       |             |         DATA.b $30
C9CE | 22       |             |         DATA.b $22
C9CF | 45       |             |         DATA.b $45
C9D0 | 33       |             |         DATA.b $33
C9D1 | D0       |             |         DATA.b $D0
C9D2 | 08       |             |         DATA.b $08
C9D3 | 40       |             |         DATA.b $40
C9D4 | 09       |             |         DATA.b $09
C9D5 | 40       |             |         DATA.b $40
C9D6 | 02       |             |         DATA.b $02
C9D7 | 45       |             |         DATA.b $45
C9D8 | 33       |             |         DATA.b $33
C9D9 | D0       |             |         DATA.b $D0
C9DA | 08       |             |         DATA.b $08
C9DB | 40       |             |         DATA.b $40
C9DC | 09       |             |         DATA.b $09
C9DD | 40       |             |         DATA.b $40
C9DE | 02       |             |         DATA.b $02
C9DF | 45       |             |         DATA.b $45
C9E0 | B3       |             |         DATA.b $B3
C9E1 | D0       |             |         DATA.b $D0
C9E2 | 08       |             |         DATA.b $08
C9E3 | 40       |             |         DATA.b $40
C9E4 | 09       |             |         DATA.b $09
C9E5 | 00       |             |         DATA.b $00
C9E6 | 22       |             |         DATA.b $22
C9E7 | 44       |             |         DATA.b $44
C9E8 | 33       |             |         DATA.b $33
C9E9 | D0       |             |         DATA.b $D0
C9EA | 8C       |             |         DATA.b $8C
C9EB | 44       |             |         DATA.b $44
C9EC | 00       |             |         DATA.b $00
C9ED | 11       |             |         DATA.b $11
C9EE | 22       |             |         DATA.b $22
C9EF | 44       |             |         DATA.b $44
C9F0 | 33       |             |         DATA.b $33
C9F1 | D0       |             |         DATA.b $D0
C9F2 | 8C       |             |         DATA.b $8C
C9F3 | 44       |             |         DATA.b $44
C9F4 | 9A       |             |         DATA.b $9A
C9F5 | 10       |             |         DATA.b $10
C9F6 | 22       |             |         DATA.b $22
C9F7 | 44       |             |         DATA.b $44
C9F8 | 33       |             |         DATA.b $33
C9F9 | D0       |             |         DATA.b $D0
C9FA | 08       |             |         DATA.b $08
C9FB | 40       |             |         DATA.b $40
C9FC | 09       |             |         DATA.b $09
C9FD | 10       |             |         DATA.b $10
C9FE | 22       |             |         DATA.b $22
C9FF | 44       |             |         DATA.b $44
CA00 | 33       |             |         DATA.b $33
CA01 | D0       |             |         DATA.b $D0
CA02 | 08       |             |         DATA.b $08
CA03 | 40       |             |         DATA.b $40
CA04 | 09       |             |         DATA.b $09
CA05 | 62       |             |         DATA.b $62
CA06 | 13       |             |         DATA.b $13
CA07 | 78       |             |         DATA.b $78
CA08 | A9       |             |         DATA.b $A9   ; opcodes ending in 01
CA09 |          |             | 
CA09 |          |             | ; addressing mode format definitions indexed by nybbles from MODE table
CA09 |          |             | 
CA09 |          |             | ; left 6 bits define which characters appear in the assembly operand
CA09 |          |             | ; left 3 bits are before the address; next 3 bits are after
CA09 |          |             | 
CA09 |          |             | ; right-most 2 bits define length of binary operand
CA09 |          |             | 
CA09 |          |             | ; index               654 321
CA09 |          |             | ; 1st character       $(# ,),  
CA09 |          |             | ; 2nd character        $$ X Y    length  format      idx mode
CA09 | 00       |             | MODE2:  DATA.b $00   ; 000 000    00                  0   error
CA0A | 21       |             |         DATA.b $21   ; 001 000    01      #$00        1   immediate
CA0B | 81       |             |         DATA.b $81   ; 100 000    01      $00         2   zero-page
CA0C | 82       |             |         DATA.b $82   ; 100 000    10      $0000       3   absolute
CA0D | 00       |             |         DATA.b $00   ; 000 000    00                  4   implied
CA0E | 00       |             |         DATA.b $00   ; 000 000    00                  5   accumulator
CA0F | 59       |             |         DATA.b $59   ; 010 110    01      ($00,X)     6   indirect,X
CA10 | 4D       |             |         DATA.b $4D   ; 010 011    01      ($00),Y     7   indirect,Y
CA11 | 91       |             |         DATA.b $91   ; 100 100    01      $00,X       8   zero-page,X
CA12 | 92       |             |         DATA.b $92   ; 100 100    10      $0000,X     9   absolute,X
CA13 | 86       |             |         DATA.b $86   ; 100 001    10      $0000,Y     A   absolute,Y
CA14 | 4A       |             |         DATA.b $4A   ; 010 010    10      ($0000)     B   indirect
CA15 | 85       |             |         DATA.b $85   ; 100 001    01      $00,Y       C   zero-page,Y
CA16 | 9D       |             |         DATA.b $9D   ; 100 111    01      $0000*      D   relative
CA17 |          |             | 
CA17 |          |             | ; * relative is special-cased so format bits don't match
CA17 |          |             | 
CA17 |          |             | 
CA17 |          |             | ; character lookup tables for the format definitions in MODE2
CA17 |          |             | 
CA17 | 2C       |             | CHAR1:  DATA.b $2C
CA18 | 29       |             |         DATA.b $29
CA19 | 2C       |             |         DATA.b $2C       ; ","  ")"  ","
CA1A | 23       |             |         DATA.b $23
CA1B | 28       |             |         DATA.b $28
CA1C | 24       |             |         DATA.b $24       ; "#"  "("  "$"
CA1D |          |             | 
CA1D | 59       |             | CHAR2:  DATA.b $59
CA1E | 00       |             |         DATA.b $00
CA1F | 58       |             |         DATA.b $58       ; "Y"   0   "X"
CA20 | 24       |             |         DATA.b $24
CA21 | 24       |             |         DATA.b $24
CA22 | 00       |             |         DATA.b $00       ; "$"  "$"   0
CA23 |          |             | 
CA23 |          |             | ; -----------------------------------------------------------------------------
CA23 |          |             | ; 3-letter mnemonics packed into two bytes (5 bits per letter)
CA23 |          |             | 
CA23 |          |             |         ; left 8 bits
CA23 |          |             |         ; XXXXX000 opcodes
CA23 | 1C       |             | MNEML:  DATA.b $1C
CA24 | 8A       |             |         DATA.b $8A
CA25 | 1C       |             |         DATA.b $1C
CA26 | 23       |             |         DATA.b $23   ; BRK PHP BPL CLC
CA27 | 5D       |             |         DATA.b $5D
CA28 | 8B       |             |         DATA.b $8B
CA29 | 1B       |             |         DATA.b $1B
CA2A | A1       |             |         DATA.b $A1   ; JSR PLP BMI SEC
CA2B | 9D       |             |         DATA.b $9D
CA2C | 8A       |             |         DATA.b $8A
CA2D | 1D       |             |         DATA.b $1D
CA2E | 23       |             |         DATA.b $23   ; RTI PHA BVC CLI
CA2F | 9D       |             |         DATA.b $9D
CA30 | 8B       |             |         DATA.b $8B
CA31 | 1D       |             |         DATA.b $1D
CA32 | A1       |             |         DATA.b $A1   ; RTS PLA BVS SEI
CA33 | 00       |             |         DATA.b $00
CA34 | 29       |             |         DATA.b $29
CA35 | 19       |             |         DATA.b $19
CA36 | AE       |             |         DATA.b $AE   ; ??? DEY BCC TYA
CA37 | 69       |             |         DATA.b $69
CA38 | A8       |             |         DATA.b $A8
CA39 | 19       |             |         DATA.b $19
CA3A | 23       |             |         DATA.b $23   ; LDY TAY BCS CLV
CA3B | 24       |             |         DATA.b $24
CA3C | 53       |             |         DATA.b $53
CA3D | 1B       |             |         DATA.b $1B
CA3E | 23       |             |         DATA.b $23   ; CPY INY BNE CLD
CA3F | 24       |             |         DATA.b $24
CA40 | 53       |             |         DATA.b $53
CA41 | 19       |             |         DATA.b $19
CA42 | A1       |             |         DATA.b $A1   ; CPX INX BEQ SED
CA43 |          |             |         ; XXXYY100 opcodes
CA43 | 00       |             |         DATA.b $00
CA44 | 1A       |             |         DATA.b $1A
CA45 | 5B       |             |         DATA.b $5B
CA46 | 5B       |             |         DATA.b $5B   ; ??? BIT JMP JMP
CA47 | A5       |             |         DATA.b $A5
CA48 | 69       |             |         DATA.b $69
CA49 | 24       |             |         DATA.b $24
CA4A | 24       |             |         DATA.b $24   ; STY LDY CPY CPX
CA4B |          |             |         ; 1XXX1010 opcodes
CA4B | AE       |             |         DATA.b $AE
CA4C | AE       |             |         DATA.b $AE
CA4D | A8       |             |         DATA.b $A8
CA4E | AD       |             |         DATA.b $AD   ; TXA TXS TAX TSX
CA4F | 29       |             |         DATA.b $29
CA50 | 00       |             |         DATA.b $00
CA51 | 7C       |             |         DATA.b $7C
CA52 | 00       |             |         DATA.b $00   ; DEX ??? NOP ???
CA53 |          |             |         ; XXXYYY10 opcodes
CA53 | 15       |             |         DATA.b $15
CA54 | 9C       |             |         DATA.b $9C
CA55 | 6D       |             |         DATA.b $6D
CA56 | 9C       |             |         DATA.b $9C   ; ASL ROL LSR ROR
CA57 | A5       |             |         DATA.b $A5
CA58 | 69       |             |         DATA.b $69
CA59 | 29       |             |         DATA.b $29
CA5A | 53       |             |         DATA.b $53   ; STX LDX DEC INC
CA5B |          |             |         ; XXXYYY01 opcodes
CA5B | 84       |             |         DATA.b $84
CA5C | 13       |             |         DATA.b $13
CA5D | 34       |             |         DATA.b $34
CA5E | 11       |             |         DATA.b $11   ; ORA AND EOR ADC
CA5F | A5       |             |         DATA.b $A5
CA60 | 69       |             |         DATA.b $69
CA61 | 23       |             |         DATA.b $23
CA62 | A0       |             |         DATA.b $A0   ; STA LDA CMP SBC
CA63 |          |             | 
CA63 |          |             |         ; right 7 bits, left justified
CA63 |          |             |         ; XXXXX000 opcodes
CA63 | D8       |             | MNEMR:  DATA.b $D8
CA64 | 62       |             |         DATA.b $62
CA65 | 5A       |             |         DATA.b $5A
CA66 | 48       |             |         DATA.b $48   ; BRK PHP BPL CLC
CA67 | 26       |             |         DATA.b $26
CA68 | 62       |             |         DATA.b $62
CA69 | 94       |             |         DATA.b $94
CA6A | 88       |             |         DATA.b $88   ; JSR PLP BMI SEC
CA6B | 54       |             |         DATA.b $54
CA6C | 44       |             |         DATA.b $44
CA6D | C8       |             |         DATA.b $C8
CA6E | 54       |             |         DATA.b $54   ; RTI PHA BVC CLI
CA6F | 68       |             |         DATA.b $68
CA70 | 44       |             |         DATA.b $44
CA71 | E8       |             |         DATA.b $E8
CA72 | 94       |             |         DATA.b $94   ; RTS PLA BVS SEI
CA73 | 00       |             |         DATA.b $00
CA74 | B4       |             |         DATA.b $B4
CA75 | 08       |             |         DATA.b $08
CA76 | 84       |             |         DATA.b $84   ; ??? DEY BCC TYA
CA77 | 74       |             |         DATA.b $74
CA78 | B4       |             |         DATA.b $B4
CA79 | 28       |             |         DATA.b $28
CA7A | 6E       |             |         DATA.b $6E   ; LDY TAY BCS CLV
CA7B | 74       |             |         DATA.b $74
CA7C | F4       |             |         DATA.b $F4
CA7D | CC       |             |         DATA.b $CC
CA7E | 4A       |             |         DATA.b $4A   ; CPY INY BNE CLD
CA7F | 72       |             |         DATA.b $72
CA80 | F2       |             |         DATA.b $F2
CA81 | A4       |             |         DATA.b $A4
CA82 | 8A       |             |         DATA.b $8A   ; CPX INX BEQ SED
CA83 |          |             |         ; XXXYY100 opcodes
CA83 | 00       |             |         DATA.b $00
CA84 | AA       |             |         DATA.b $AA
CA85 | A2       |             |         DATA.b $A2
CA86 | A2       |             |         DATA.b $A2   ; ??? BIT JMP JMP
CA87 | 74       |             |         DATA.b $74
CA88 | 74       |             |         DATA.b $74
CA89 | 74       |             |         DATA.b $74
CA8A | 72       |             |         DATA.b $72   ; STY LDY CPY CPX
CA8B |          |             |         ; 1XXX1010 opcodes
CA8B | 44       |             |         DATA.b $44
CA8C | 68       |             |         DATA.b $68
CA8D | B2       |             |         DATA.b $B2
CA8E | 32       |             |         DATA.b $32   ; TXA TXS TAX TSX
CA8F | B2       |             |         DATA.b $B2
CA90 | 00       |             |         DATA.b $00
CA91 | 22       |             |         DATA.b $22
CA92 | 00       |             |         DATA.b $00   ; DEX ??? NOP ???
CA93 |          |             |         ; XXXYYY10 opcodes
CA93 | 1A       |             |         DATA.b $1A
CA94 | 1A       |             |         DATA.b $1A
CA95 | 26       |             |         DATA.b $26
CA96 | 26       |             |         DATA.b $26   ; ASL ROL LSR ROR
CA97 | 72       |             |         DATA.b $72
CA98 | 72       |             |         DATA.b $72
CA99 | 88       |             |         DATA.b $88
CA9A | C8       |             |         DATA.b $C8   ; STX LDX DEC INC
CA9B |          |             |         ; XXXYYY01 opcodes
CA9B | C4       |             |         DATA.b $C4
CA9C | CA       |             |         DATA.b $CA
CA9D | 26       |             |         DATA.b $26
CA9E | 48       |             |         DATA.b $48   ; ORA AND EOR ADC
CA9F | 44       |             |         DATA.b $44
CAA0 | 44       |             |         DATA.b $44
CAA1 | A2       |             |         DATA.b $A2
CAA2 | C8       |             |         DATA.b $C8   ; STA LDA CMP SBC
CAA3 | 0D       |             |         DATA.b $0D
CAA4 | 20       |             |         DATA.b $20
CAA5 | 20       |             |         DATA.b $20
CAA6 | 20       |             |         DATA.b $20
CAA7 |          |             | 
CAA7 |          |             | ; -----------------------------------------------------------------------------
CAA7 |          |             | ; single-character commands
CAA7 |          |             | KEYW:    ;.TEXT "ACDFGHJMRTX@.>;"
CAA7 | 41       |             |         DATA.b 'A'
CAA8 | 43       |             |         DATA.b 'C'
CAA9 | 44       |             |         DATA.b 'D'
CAAA | 46       |             |         DATA.b 'F'
CAAB | 47       |             |         DATA.b 'G'
CAAC | 48       |             |         DATA.b 'H'
CAAD | 4A       |             |         DATA.b 'J'
CAAE | 4D       |             |         DATA.b 'M'
CAAF | 52       |             |         DATA.b 'R'
CAB0 | 54       |             |         DATA.b 'T'
CAB1 | 58       |             |         DATA.b 'X'
CAB2 | 40       |             |         DATA.b '@'
CAB3 | 2E       |             |         DATA.b '.'
CAB4 | 3E       |             |         DATA.b '>'
CAB5 | 3B       |             |         DATA.b $3b      ; ;
CAB6 |          |             | 
CAB6 |          |             | HIKEY:  ; .TEXT "$+&%LSV"
CAB6 | 24       |             |         DATA.b $24      ; $
CAB7 | 2B       |             |         DATA.b '+'
CAB8 | 26       |             |         DATA.b $26      ; &
CAB9 | 25       |             |         DATA.b '%'
CABA | 4C       |             |         DATA.b 'L'
CABB | 53       |             |         DATA.b 'S'
CABC | 56       |             |         DATA.b 'V'
CABD |          |             | 
CABD |          |             | KEYTOP:
CABD |          |             | 
CABD |          |             | ; vectors corresponding to commands above
CABD | 43 C3    |             | KADDR:  DATA ASSEM-1
CABF | 9B C1    |             |         DATA COMPAR-1
CAC1 | D0 C4    |             |         DATA DISASS-1
CAC3 | 1E C3    |             |         DATA FILL-1
CAC5 |          |             | 
CAC5 | 26 C1    |             |         DATA GOTO-1
CAC7 | 1F C2    |             |         DATA HUNT-1
CAC9 | 44 C1    |             |         DATA JSUB-1
CACB | B9 C0    |             |         DATA DSPLYM-1
CACD |          |             | 
CACD | 3E C0    |             |         DATA DSPLYR-1
CACF | 9E C1    |             |         DATA TRANS-1
CAD1 | B6 C0    |             |         DATA EXIT-1
CAD3 | 77 C8    |             |         DATA DSTAT-1
CAD5 |          |             | 
CAD5 | 43 C3    |             |         DATA ASSEM-1
CAD7 | 06 C1    |             |         DATA ALTM-1
CAD9 | EF C0    |             |         DATA ALTR-1
CADB |          |             | 
CADB |          |             | ; -----------------------------------------------------------------------------
CADB | 10       |             | MODTAB: DATA.b $10
CADC | 0A       |             |         DATA.b $0A
CADD | 08       |             |         DATA.b $08
CADE | 02       |             |         DATA.b 02    ; modulo number systems
CADF | 04       |             | LENTAB: DATA.b $04
CAE0 | 03       |             |         DATA.b $03
CAE1 | 03       |             |         DATA.b $03
CAE2 | 01       |             |         DATA.b $01   ; bits per digit
CAE3 |          |             | 
CAE3 | 30 C0    |             | LINKAD: DATA BREAK             ; address of brk handler
CAE5 | 00 C0    |             | SUPAD:  DATA SUPER             ; address of entry point
CAE7 |          |             | 
CAE7 |          |             | ; Ending Including 'pssupermon64.asm'
