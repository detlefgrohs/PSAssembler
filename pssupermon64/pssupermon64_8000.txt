0000 |          |             | ORG = $8000
0000 |          |             | 
0000 |          |             | #INCLUDE pssupermon64.asm
0000 |          |             | ; Start Including 'pssupermon64.asm'
0000 |          |             | ; -----------------------------------------------------------------------------
0000 |          |             | ; temporary pointers
0000 |          |             | TMP0    = $C1               ; used to return input, often holds end address
0000 |          |             | TMP2    = $C3               ; usually holds start address
0000 |          |             | 
0000 |          |             | ; -----------------------------------------------------------------------------
0000 |          |             | ; kernal variables
0000 |          |             | SATUS   = $90               ; kernal i/o status word
0000 |          |             | FNLEN   = $B7               ; length of current filename
0000 |          |             | SADD    = $B9               ; current secondary address (official name SA)
0000 |          |             | FA      = $BA               ; current device number
0000 |          |             | FNADR   = $BB               ; pointer to current filename
0000 |          |             | NDX     = $C6               ; number of characters in keyboard buffer
0000 |          |             | KEYD    = $0277             ; keyboard buffer
0000 |          |             | BKVEC   = $0316             ; BRK instruction vector (official name CBINV)
0000 |          |             | 
0100 |          |             |         *= $0100            ; store variables in tape error buffer
0100 |          |             | 
0100 |          |             | ; -----------------------------------------------------------------------------
0100 |          |             | ; variables
0100 |          |             | ACMD:    FILL 1             ; addressing command
0101 |          |             | LENGTH:  FILL 1             ; length of operand
0102 |          |             | MNEMW:   FILL 3             ; 3 letter mnemonic buffer
0105 |          |             | SAVX:    FILL 1             ; 1 byte temp storage, often to save X register
0106 |          |             | OPCODE:  FILL 1             ; current opcode for assembler/disassembler
0107 |          |             | UPFLG:   FILL 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
0108 |          |             | DIGCNT:  FILL 1             ; digit count
0109 |          |             | INDIG:   FILL 1             ; numeric value of single digit
010A |          |             | NUMBIT:  FILL 1             ; numeric base of input
010B |          |             | STASH:   FILL 2             ; 2-byte temp storage
010D |          |             | U0AA0:   FILL 10            ; work buffer
0117 |          |             | U0AAE:                     ; end of work buffer
0117 |          |             | STAGE:   FILL 30            ; staging buffer for filename, search, etc.
0135 |          |             | ESTAGE:                    ; end of staging buffer
0135 |          |             | 
0200 |          |             |         *= $0200            ; store more variables in basic line editor buffer
0200 |          |             | 
0200 |          |             | INBUFF:  FILL 40            ; 40-character input buffer
0228 |          |             | ENDIN:                     ; end of input buffer
0228 |          |             | 
0228 |          |             | ; the next 7 locations are used to store the registers when
0228 |          |             | ; entering the monitor and restore them when exiting.
0228 |          |             | 
0228 |          |             | PCH:     FILL 1             ; program counter high byte
0229 |          |             | PCL:     FILL 1             ; program counter low byte
022A |          |             | SR:      FILL 1             ; status register
022B |          |             | ACC:     FILL 1             ; accumulator
022C |          |             | XR:      FILL 1             ; X register
022D |          |             | YR:      FILL 1             ; Y register
022E |          |             | SP:      FILL 1             ; stack pointer
022F |          |             | 
022F |          |             | STORE:   FILL 2             ; 2-byte temp storage
0231 |          |             | CHRPNT:  FILL 1             ; current position in input buffer
0232 |          |             | SAVY:    FILL 1             ; temp storage, often to save Y register
0233 |          |             | U9F:     FILL 1             ; index into assembler work buffer
0234 |          |             | 
0234 |          |             | ; -----------------------------------------------------------------------------
0234 |          |             | ; kernal entry points
0234 |          |             | SETMSG  = $FF90             ; set kernel message control flag
0234 |          |             | SECOND  = $FF93             ; set secondary address after LISTEN
0234 |          |             | TKSA    = $FF96             ; send secondary address after TALK
0234 |          |             | LISTEN  = $FFB1             ; command serial bus device to LISTEN
0234 |          |             | TALK    = $FFB4             ; command serial bus device to TALK
0234 |          |             | SETLFS  = $FFBA             ; set logical file parameters
0234 |          |             | SETNAM  = $FFBD             ; set filename
0234 |          |             | ACPTR   = $FFA5             ; input byte from serial bus
0234 |          |             | CIOUT   = $FFA8             ; output byte to serial bus
0234 |          |             | UNTLK   = $FFAB             ; command serial bus device to UNTALK
0234 |          |             | UNLSN   = $FFAE             ; command serial bus device to UNLISTEN
0234 |          |             | CHKIN   = $FFC6             ; define input channel
0234 |          |             | CLRCHN  = $FFCC             ; restore default devices
0234 |          |             | INPUT   = $FFCF             ; input a character (official name CHRIN)
0234 |          |             | CHROUT  = $FFD2             ; output a character
0234 |          |             | LOAD    = $FFD5             ; load from device
0234 |          |             | SAVE    = $FFD8             ; save to device
0234 |          |             | STOP    = $FFE1             ; check the STOP key
0234 |          |             | GETIN   = $FFE4             ; get a character
0234 |          |             | 
0234 |          |             | ; -----------------------------------------------------------------------------
0234 |          |             | ; set up origin
0234 |          |             | 
8000 |          |             | *       = ORG
8000 |          |             | 
8000 |          |             | ; -----------------------------------------------------------------------------
8000 |          |             | ; initial entry point
8000 | A0 20    | LDY #$20    | SUPER:  LDY.# MSG4-MSGBAS    ; display "..SYS "
8002 | 20 84 89 | JSR $8984   |         JSR SNDMSG
8005 | AD E5 8A | LDA $8AE5   |         LDA SUPAD           ; store entry point address in tmp0
8008 | 85 C1    | STA $C1     |         STA.zp TMP0
800A | AD E6 8A | LDA $8AE6   |         LDA SUPAD+1
800D | 85 C2    | STA $C2     |         STA.zp TMP0+1
800F | 20 0E 88 | JSR $880E   |         JSR CVTDEC          ; convert address to decimal
8012 | A9 00    | LDA #$00    |         LDA.# 0
8014 | A2 06    | LDX #$06    |         LDX.# 6
8016 | A0 03    | LDY #$03    |         LDY.# 3
8018 | 20 48 88 | JSR $8848   |         JSR NMPRNT          ; print entry point address
801B | 20 DD 86 | JSR $86DD   |         JSR CRLF
801E | AD E3 8A | LDA $8AE3   |         LDA LINKAD          ; set BRK vector
8021 | 8D 16 03 | STA $0316   |         STA BKVEC
8024 | AD E4 8A | LDA $8AE4   |         LDA LINKAD+1
8027 | 8D 17 03 | STA $0317   |         STA BKVEC+1
802A | A9 80    | LDA #$80    |         LDA.# $80            ; disable kernel control messages
802C | 20 90 FF | JSR $FF90   |         JSR SETMSG          ; and enable error messages
802F | 00       | BRK         |         BRK
8030 |          |             | 
8030 |          |             | ; -----------------------------------------------------------------------------
8030 |          |             | ; BRK handler
8030 | A2 05    | LDX #$05    | BREAK:  LDX.# $05            ; pull registers off the stack
8032 | 68       | PLA         | BSTACK: PLA                 ; order: Y,X,A,SR,PCL,PCH
8033 | 9D 28 02 | STA $0228,X |         STA,X PCH           ; store in memory
8036 | CA       | DEX         |         DEX 
8037 | 10 F9    | BPL $F9     |         BPL BSTACK
8039 | D8       | CLD         |         CLD                 ; disable bcd mode
803A | BA       | TSX         |         TSX                 ; store stack pointer in memory 
803B | 8E 2E 02 | STX $022E   |         STX SP
803E | 58       | CLI         |         CLI                 ; enable interupts
803F |          |             | 
803F |          |             | ; -----------------------------------------------------------------------------
803F |          |             | ; display registers [R]
803F | A0 00    | LDY #$00    | DSPLYR:  LDY.# MSG2-MSGBAS    ; display headers
8041 | 20 71 89 | JSR $8971   |         JSR SNDCLR
8044 | A9 3B    | LDA #$3B    |         LDA.# $3B            ; prefix registers with "; " to allow editing
8046 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8049 | A9 20    | LDA #$20    |         LDA.# $20
804B | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
804E | AD 28 02 | LDA $0228   |         LDA PCH             ; print 2-byte program counter
8051 | 20 F6 86 | JSR $86F6   |         JSR WRTWO
8054 | A0 01    | LDY #$01    |         LDY.# 1              ; start 1 byte after PC high byte
8056 | B9 28 02 | LDA $0228,Y | DISJ:    LDA,Y PCH           ; loop through rest of the registers
8059 | 20 D2 86 | JSR $86D2   |         JSR WRBYTE          ; print 1-byte register value
805C | C8       | INY         |         INY 
805D | C0 07    | CPY #$07    |         CPY.# 7              ; there are a total of 5 registers to print
805F | 90 F5    | BCC $F5     |         BCC DISJ
8061 |          |             | 
8061 |          |             | ; -----------------------------------------------------------------------------
8061 |          |             | ; main loop
8061 | 20 DD 86 | JSR $86DD   | STRT:    JSR CRLF            ; new line
8064 | A2 00    | LDX #$00    |         LDX.# 0              ; point at start of input buffer
8066 | 8E 31 02 | STX $0231   |         STX CHRPNT 
8069 | 20 CF FF | JSR $FFCF   | SMOVE:   JSR INPUT           ; CHRIN kernal call to input a character
806C | 9D 00 02 | STA $0200,X |         STA,X INBUFF        ; store in input buffer
806F | E8       | INX         |         INX 
8070 | E0 28    | CPX #$28    |         CPX.# ENDIN-INBUFF   ; error if buffer is full
8072 | B0 1C    | BCS $1C     |         BCS ERROR
8074 | C9 0D    | CMP #$0D    |         CMP.# $0D            ; keep reading until CR
8076 | D0 F1    | BNE $F1     |         BNE SMOVE
8078 | A9 00    | LDA #$00    |         LDA.# 0              ; null-terminate input buffer
807A | 9D FF 01 | STA $01FF,X |         STA,X INBUFF-1      ; (replacing the CR)
807D | 20 1E 87 | JSR $871E   | ST1:     JSR GETCHR          ; get a character from the buffer
8080 | F0 DF    | BEQ $DF     |         BEQ STRT            ; start over if buffer is empty
8082 | C9 20    | CMP #$20    |         CMP.# $20            ; skip leading spaces
8084 | F0 F7    | BEQ $F7     |         BEQ ST1
8086 | A2 16    | LDX #$16    | S0:      LDX.# KEYTOP-KEYW    ; loop through valid command characters
8088 | DD A7 8A | CMP $8AA7,X | S1:      CMP,X KEYW          ; see if input character matches
808B | F0 0B    | BEQ $0B     |         BEQ S2              ; command matched, dispatch it
808D | CA       | DEX         |         DEX                 ; no match, check next command
808E | 10 F8    | BPL $F8     |         BPL S1              ; keep trying until we've checked them all
8090 |          |             |                             ; then fall through to error handler
8090 |          |             | 
8090 |          |             | ; -----------------------------------------------------------------------------
8090 |          |             | ; handle error
8090 | A0 1E    | LDY #$1E    | ERROR:   LDY.# MSG3-MSGBAS    ; display "?" to indicate error and go to new line
8092 | 20 84 89 | JSR $8984   |         JSR SNDMSG
8095 | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to main loop
8098 |          |             | 
8098 |          |             | ; -----------------------------------------------------------------------------
8098 |          |             | ; dispatch command
8098 | E0 13    | CPX #$13    | S2:      CPX.# $13            ; last 3 commands in table are load/save/validate
809A | B0 12    | BCS $12     |         BCS LSV             ;   which are handled by the same subroutine
809C | E0 0F    | CPX #$0F    |         CPX.# $0F            ; next 4 commands are base conversions
809E | B0 14    | BCS $14     |         BCS CNVLNK          ;   which are handled by the same subroutine
80A0 | 8A       | TXA         |         TXA                 ; remaining commands dispatch through vector table
80A1 | 0A       | ASL A       |         ASL.A               ; multiply index of command by 2
80A2 | AA       | TAX         |         TAX                 ;   since table contains 2-byte addresses
80A3 | BD BE 8A | LDA $8ABE,X |         LDA,X KADDR+1       ; push address from vector table onto stack
80A6 | 48       | PHA         |         PHA                 ;   so that the RTS from GETPAR will jump there
80A7 | BD BD 8A | LDA $8ABD,X |         LDA,X KADDR
80AA | 48       | PHA         |         PHA
80AB | 4C FF 85 | JMP $85FF   |         JMP GETPAR          ; get the first parameter for the command
80AE | 8D 32 02 | STA $0232   | LSV:     STA SAVY            ; handle load/save/validate
80B1 | 4C 81 82 | JMP $8281   |         JMP LD
80B4 | 4C C3 87 | JMP $87C3   | CNVLNK:  JMP CONVRT          ; handle base conversion
80B7 |          |             | 
80B7 |          |             | ; -----------------------------------------------------------------------------
80B7 |          |             | ; exit monitor [X]
80B7 | 6C 02 A0 | JMP ($A002) | EXIT:    JMP.i $A002         ; jump to warm-start vector to reinitialize BASIC
80BA |          |             | 
80BA |          |             | ; -----------------------------------------------------------------------------
80BA |          |             | ; display memory [M]
80BA | B0 08    | BCS $08     | DSPLYM:  BCS DSPM11          ; start from previous end addr if no address given
80BC | 20 38 87 | JSR $8738   |         JSR COPY12          ; save start address in TMP2
80BF | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get end address in TMP0
80C2 | 90 06    | BCC $06     |         BCC DSMNEW          ; did user specify one?
80C4 | A9 0B    | LDA #$0B    | DSPM11:  LDA.# $0B            ; if not, show 12 lines by default
80C6 | 85 C1    | STA $C1     |         STA.zp TMP0
80C8 | D0 0E    | BNE $0E     |         BNE DSPBYT          ; always true, but BNE uses 1 byte less than JMP
80CA | 20 41 87 | JSR $8741   | DSMNEW:  JSR SUB12           ; end addr given, calc bytes between start and end
80CD | 90 1E    | BCC $1E     |         BCC MERROR          ; error if start is after end
80CF | A2 03    | LDX #$03    |         LDX.# 3              ; divide by 8 (shift right 3 times)
80D1 | 46 C2    | LSR $C2     | DSPM01:  LSR.zp TMP0+1
80D3 | 66 C1    | ROR $C1     |         ROR.zp TMP0
80D5 | CA       | DEX         |         DEX 
80D6 | D0 F9    | BNE $F9     |         BNE DSPM01
80D8 | 20 E1 FF | JSR $FFE1   | DSPBYT:  JSR STOP            ; check for stop key
80DB | F0 0D    | BEQ $0D     |         BEQ DSPMX           ; exit early if pressed
80DD | 20 5D 81 | JSR $815D   |         JSR DISPMEM         ; display 1 line containing 8 bytes
80E0 | A9 08    | LDA #$08    |         LDA.# 8              ; increase start address by 8 bytes
80E2 | 20 77 87 | JSR $8777   |         JSR BUMPAD2
80E5 | 20 4F 87 | JSR $874F   |         JSR SUBA1           ; decrement line counter
80E8 | B0 EE    | BCS $EE     |         BCS DSPBYT          ; show another line until it's < 0
80EA | 4C 61 80 | JMP $8061   | DSPMX:   JMP STRT            ; back to main loop
80ED | 4C 90 80 | JMP $8090   | MERROR:  JMP ERROR           ; handle error
80F0 |          |             | 
80F0 |          |             | ; -----------------------------------------------------------------------------
80F0 |          |             | ; alter registers [;]
80F0 | 20 8F 87 | JSR $878F   | ALTR:   JSR COPY1P          ; store first parameter in PC
80F3 | A0 00    | LDY #$00    |         LDY.# 0              ; init counter
80F5 | 20 FF 85 | JSR $85FF   | ALTR1:  JSR GETPAR          ; get value for next register
80F8 | B0 0A    | BCS $0A     |         BCS ALTRX           ; exit early if no more values given
80FA | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; store in memory, offset from SR
80FC | 99 2A 02 | STA $022A,Y |         STA,Y SR            ; these locations will be transferred to the
80FF | C8       | INY         |         INY                 ;   actual registers before exiting the monitor
8100 | C0 05    | CPY #$05    |         CPY.# $05            ; have we updated all 5 yet?
8102 | 90 F1    | BCC $F1     |         BCC ALTR1           ; if not, get next
8104 | 4C 61 80 | JMP $8061   | ALTRX:  JMP STRT            ; back to main loop
8107 |          |             | 
8107 |          |             | ; -----------------------------------------------------------------------------
8107 |          |             | ; alter memory [>]
8107 | B0 13    | BCS $13     | ALTM:   BCS ALTMX           ; exit if no parameter provided
8109 | 20 38 87 | JSR $8738   |         JSR COPY12          ; copy parameter to start address
810C | A0 00    | LDY #$00    |         LDY.# 0
810E | 20 FF 85 | JSR $85FF   | ALTM1:  JSR GETPAR          ; get value for next byte of memory
8111 | B0 09    | BCS $09     |         BCS ALTMX           ; if none given, exit early
8113 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; poke value into memory at start address + Y
8115 | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2
8117 | C8       | INY         |         INY                 ; next byte
8118 | C0 08    | CPY #$08    |         CPY.# 8              ; have we read 8 bytes yet?
811A | 90 F2    | BCC $F2     |         BCC ALTM1           ; if not, read the next one
811C | A9 91    | LDA #$91    | ALTMX:  LDA.# $91            ; move cursor up
811E | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8121 | 20 5D 81 | JSR $815D   |         JSR DISPMEM         ; re-display line to make ascii match hex
8124 | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to main loop
8127 |          |             | 
8127 |          |             | ; -----------------------------------------------------------------------------
8127 |          |             | ; goto (run) [G]
8127 | AE 2E 02 | LDX $022E   | GOTO:   LDX SP              ; load stack pointer from memory
812A | 9A       | TXS         |         TXS                 ; save in SP register
812B | 20 8F 87 | JSR $878F   | GOTO2:  JSR COPY1P          ; copy provided address to PC
812E | 78       | SEI         |         SEI                 ; disable interrupts
812F | AD 28 02 | LDA $0228   |         LDA PCH             ; push PC high byte on stack
8132 | 48       | PHA         |         PHA
8133 | AD 29 02 | LDA $0229   |         LDA PCL             ; push PC low byte on stack
8136 | 48       | PHA         |         PHA
8137 | AD 2A 02 | LDA $022A   |         LDA SR              ; push status byte on stack
813A | 48       | PHA         |         PHA
813B | AD 2B 02 | LDA $022B   |         LDA ACC             ; load accumulator from memory
813E | AE 2C 02 | LDX $022C   |         LDX XR              ; load X from memory
8141 | AC 2D 02 | LDY $022D   |         LDY YR              ; load Y from memory
8144 | 40       | RTI         |         RTI                 ; return from interrupt (pops PC and SR)
8145 |          |             | 
8145 |          |             | ; jump to subroutine [J]
8145 | AE 2E 02 | LDX $022E   | JSUB:   LDX SP              ; load stack pointer from memory
8148 | 9A       | TXS         |         TXS                 ; save value in SP register
8149 | 20 2B 81 | JSR $812B   |         JSR GOTO2           ; same as goto command
814C | 8C 2D 02 | STY $022D   |         STY YR              ; save Y to memory
814F | 8E 2C 02 | STX $022C   |         STX XR              ; save X to memory
8152 | 8D 2B 02 | STA $022B   |         STA ACC             ; save accumulator to memory
8155 | 08       | PHP         |         PHP                 ; push processor status on stack
8156 | 68       | PLA         |         PLA                 ; pull processor status into A
8157 | 8D 2A 02 | STA $022A   |         STA SR              ; save processor status to memory
815A | 4C 3F 80 | JMP $803F   |         JMP DSPLYR          ; display registers
815D |          |             | 
815D |          |             | ; -----------------------------------------------------------------------------
815D |          |             | ; display 8 bytes of memory
815D | 20 DD 86 | JSR $86DD   | DISPMEM: JSR CRLF            ; new line
8160 | A9 3E    | LDA #$3E    |         LDA.# '>'            ; prefix > so memory can be edited in place
8162 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8165 | 20 C8 86 | JSR $86C8   |         JSR SHOWAD          ; show address of first byte on line
8168 | A0 00    | LDY #$00    |         LDY.# 0
816A | F0 03    | BEQ $03     |         BEQ DMEMGO          ; SHOWAD already printed a space after the address
816C | 20 D5 86 | JSR $86D5   | DMEMLP: JSR SPACE           ; print space between bytes
816F | B1 C3    | LDA ($C3),Y | DMEMGO: LDA.i,Y TMP2        ; load byte from start address + Y
8171 | 20 F6 86 | JSR $86F6   |         JSR WRTWO           ; output hex digits for byte
8174 | C8       | INY         |         INY                 ; next byte
8175 | C0 08    | CPY #$08    |         CPY.# 8              ; have we output 8 bytes yet?
8177 | 90 F3    | BCC $F3     |         BCC DMEMLP          ; if not, output next byte
8179 | A0 26    | LDY #$26    |         LDY.# MSG5-MSGBAS    ; if so, output : and turn on reverse video
817B | 20 84 89 | JSR $8984   |         JSR SNDMSG          ;   before displaying ascii representation
817E | A0 00    | LDY #$00    |         LDY.# 0              ; back to first byte in line
8180 | B1 C3    | LDA ($C3),Y | DCHAR:  LDA.i,Y TMP2        ; load byte at start address + Y
8182 | AA       | TAX         |         TAX                 ; stash in X
8183 | 29 BF    | AND #$BF    |         AND.# $BF            ; clear 6th bit
8185 | C9 22    | CMP #$22    |         CMP.# $22            ; is it a quote (")?
8187 | F0 08    | BEQ $08     |         BEQ DDOT            ; if so, print . instead
8189 | 8A       | TXA         |         TXA                 ; if not, restore character
818A | 29 7F    | AND #$7F    |         AND.# $7F            ; clear top bit
818C | C9 20    | CMP #$20    |         CMP.# $20            ; is it a printable character (>= $20)?
818E | 8A       | TXA         |         TXA                 ; restore character
818F | B0 02    | BCS $02     |         BCS DCHROK          ; if printable, output character
8191 | A9 2E    | LDA #$2E    | DDOT:   LDA.# $2E            ; if not, output '.' instaed
8193 | 20 D2 FF | JSR $FFD2   | DCHROK: JSR CHROUT
8196 | C8       | INY         |         INY                 ; next byte
8197 | C0 08    | CPY #$08    |         CPY.# 8              ; have we output 8 bytes yet?
8199 | 90 E5    | BCC $E5     |         BCC DCHAR           ; if not, output next byte
819B | 60       | RTS         |         RTS 
819C |          |             | 
819C |          |             | ; -----------------------------------------------------------------------------
819C |          |             | ; compare memory [C]
819C | A9 00    | LDA #$00    | COMPAR: LDA.# 0              ; bit 7 clear signals compare
819E | 2C       |             |         DATA.b $2C           ; absolute BIT opcode consumes next word (LDA #$80)
819F |          |             | 
819F |          |             | ; transfer memory [T]
819F | A9 80    | LDA #$80    | TRANS:  LDA.# $80            ; bit 7 set signals transfer
81A1 | 8D 32 02 | STA $0232   |         STA SAVY            ; save compare/transfer flag in SAVY
81A4 | A9 00    | LDA #$00    |         LDA.# 0              ; assume we're counting up (bit 7 clear)
81A6 | 8D 07 01 | STA $0107   |         STA UPFLG           ; save direction flag
81A9 | 20 9C 87 | JSR $879C   |         JSR GETDIF          ; get two addresses and calculate difference
81AC |          |             |                             ;   TMP2 = source start
81AC |          |             |                             ;   STASH = source end
81AC |          |             |                             ;   STORE = length
81AC | B0 05    | BCS $05     |         BCS TERROR          ; carry set indicates error
81AE | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get destination address in TMP0
81B1 | 90 03    | BCC $03     |         BCC TOKAY           ; carry set indicates error
81B3 | 4C 90 80 | JMP $8090   | TERROR: JMP ERROR           ; handle error
81B6 | 2C 32 02 | BIT $0232   | TOKAY:  BIT SAVY            ; transfer or compare?
81B9 | 10 27    | BPL $27     |         BPL COMPAR1         ; high bit clear indicates compare
81BB | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; if it's a transfer, we must take steps
81BD | C5 C1    | CMP $C1     |         CMP.zp TMP0            ;   to avoid overwriting the source bytes before 
81BF | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ;   they have been transferred
81C1 | E5 C2    | SBC $C2     |         SBC.zp TMP0+1          ; compare source (TMP2) to destination (TMP0)
81C3 | B0 1D    | BCS $1D     |         BCS COMPAR1         ; and count up if source is before than desitnation
81C5 | AD 2F 02 | LDA $022F   |         LDA STORE           ; otherwise, start at end and count down...
81C8 | 65 C1    | ADC $C1     |         ADC.zp TMP0            ; add length (STORE) to desintation (TMP0)
81CA | 85 C1    | STA $C1     |         STA.zp TMP0            ; to calculate end of destination
81CC | AD 30 02 | LDA $0230   |         LDA STORE+1
81CF | 65 C2    | ADC $C2     |         ADC.zp TMP0+1
81D1 | 85 C2    | STA $C2     |         STA.zp TMP0+1
81D3 | A2 01    | LDX #$01    |         LDX.# 1              ; change source pointer from beginning to end
81D5 | BD 0B 01 | LDA $010B,X | TDOWN:  LDA,X STASH         ; TMP2 = source end (STASH)
81D8 | 95 C3    | STA $C3,X   |         STA.zp,X TMP2
81DA | CA       | DEX         |         DEX 
81DB | 10 F8    | BPL $F8     |         BPL TDOWN
81DD | A9 80    | LDA #$80    |         LDA.# $80            ; high bit set in UPFLG means count down
81DF | 8D 07 01 | STA $0107   |         STA UPFLG
81E2 | 20 DD 86 | JSR $86DD   | COMPAR1: JSR CRLF            ; new line
81E5 | A0 00    | LDY #$00    |         LDY.# 0              ; no offset from pointer
81E7 | 20 E1 FF | JSR $FFE1   | TCLOOP: JSR STOP            ; check for stop key
81EA | F0 31    | BEQ $31     |         BEQ TEXIT           ; exit if pressed
81EC | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; load byte from source
81EE | 2C 32 02 | BIT $0232   |         BIT SAVY            ; transfer or compare?
81F1 | 10 02    | BPL $02     |         BPL COMPAR2         ; skip store if comparing
81F3 | 91 C1    | STA ($C1),Y |         STA.i,Y TMP0        ; otherwise, store in destination
81F5 | D1 C1    | CMP ($C1),Y | COMPAR2: CMP.i,Y TMP0        ; compare to destination
81F7 | F0 03    | BEQ $03     |         BEQ TMVAD           ; don't show address if equal
81F9 | 20 C8 86 | JSR $86C8   |         JSR SHOWAD          ; show address
81FC | 2C 07 01 | BIT $0107   | TMVAD:  BIT UPFLG           ; counting up or down?
81FF | 30 0B    | BMI $0B     |         BMI TDECAD          ; high bit set means we're counting down
8201 | E6 C1    | INC $C1     |         INC.zp TMP0            ; increment destination low byte
8203 | D0 10    | BNE $10     |         BNE TINCOK
8205 | E6 C2    | INC $C2     |         INC.zp TMP0+1          ; carry to high byte if necessary
8207 | D0 0C    | BNE $0C     |         BNE TINCOK
8209 | 4C 90 80 | JMP $8090   |         JMP ERROR           ; error if high byte overflowed
820C | 20 4F 87 | JSR $874F   | TDECAD: JSR SUBA1           ; decrement destination (TMP0)
820F | 20 81 87 | JSR $8781   |         JSR SUB21           ; decrement source (TMP2)
8212 | 4C 18 82 | JMP $8218   |         JMP TMOR
8215 | 20 75 87 | JSR $8775   | TINCOK: JSR ADDA2           ; increment source (TMP2)
8218 | 20 63 87 | JSR $8763   | TMOR:   JSR SUB13           ; decrement length
821B | B0 CA    | BCS $CA     |         BCS TCLOOP          ; loop until length is 0
821D | 4C 61 80 | JMP $8061   | TEXIT:  JMP STRT            ; back to main loop
8220 |          |             | 
8220 |          |             | ; -----------------------------------------------------------------------------
8220 |          |             | ; hunt memory [H]
8220 | 20 9C 87 | JSR $879C   | HUNT:   JSR GETDIF          ; get start (TMP2) and end (TMP0) of haystack
8223 | B0 59    | BCS $59     |         BCS HERROR          ; carry indicates error
8225 | A0 00    | LDY #$00    |         LDY.# 0
8227 | 20 1E 87 | JSR $871E   |         JSR GETCHR          ; get a single character
822A | C9 27    | CMP #$27    |         CMP.# 39 ; "'"            ; is it a single quote?
822C | D0 16    | BNE $16     |         BNE NOSTRH          ; if not, input needle as hex bytes
822E | 20 1E 87 | JSR $871E   |         JSR GETCHR          ; if so, input needle as string
8231 | C9 00    | CMP #$00    |         CMP.# 0
8233 | F0 49    | BEQ $49     |         BEQ HERROR          ; error if needle isn't at least one byte
8235 | 99 17 01 | STA $0117,Y | HPAR:   STA,Y STAGE         ; save char in staging area
8238 | C8       | INY         |         INY 
8239 | 20 1E 87 | JSR $871E   |         JSR GETCHR          ; get another char
823C | F0 18    | BEQ $18     |         BEQ HTGO            ; if it's null start searching
823E | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; have we filled up the needle staging area?
8240 | D0 F3    | BNE $F3     |         BNE HPAR            ; if not, get another character
8242 | F0 12    | BEQ $12     |         BEQ HTGO            ; if so, start searching
8244 | 20 FC 85 | JSR $85FC   | NOSTRH: JSR RDPAR           ; read hex bytes if string not indicated
8247 | A5 C1    | LDA $C1     | HLP:    LDA.zp TMP0            ; save last read byte in staging area
8249 | 99 17 01 | STA $0117,Y |         STA,Y STAGE
824C | C8       | INY         |         INY                 ; get another hex byte
824D | 20 FF 85 | JSR $85FF   |         JSR GETPAR
8250 | B0 04    | BCS $04     |         BCS HTGO            ; if there is none, start searching
8252 | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; have we filled up the needle staging area?
8254 | D0 F1    | BNE $F1     |         BNE HLP             ; if not, get another byte
8256 | 8C 32 02 | STY $0232   | HTGO:   STY SAVY            ; save length of needle
8259 | 20 DD 86 | JSR $86DD   |         JSR CRLF            ; new line
825C | A0 00    | LDY #$00    | HSCAN:  LDY.# 0
825E | B1 C3    | LDA ($C3),Y | HLP3:   LDA.i,Y TMP2        ; get first byte in haystack
8260 | D9 17 01 | CMP $0117,Y |         CMP,Y STAGE         ; compare it to first byte of needle
8263 | D0 09    | BNE $09     |         BNE HNOFT           ; if it doesn't match, we haven't found anything
8265 | C8       | INY         |         INY                 ; if it does, check the next byte
8266 | CC 32 02 | CPY $0232   |         CPY SAVY            ; have we reached the end of the needle?
8269 | D0 F3    | BNE $F3     |         BNE HLP3            ; if not, keep comparing bytes
826B | 20 C8 86 | JSR $86C8   |         JSR SHOWAD          ; match found, show address
826E | 20 E1 FF | JSR $FFE1   | HNOFT:  JSR STOP            ; no match, check for stop key
8271 | F0 08    | BEQ $08     |         BEQ HEXIT           ; exit prematurely if pressed
8273 | 20 75 87 | JSR $8775   |         JSR ADDA2           ; increment haystack pointer
8276 | 20 63 87 | JSR $8763   |         JSR SUB13           ; decrement haystack length
8279 | B0 E1    | BCS $E1     |         BCS HSCAN           ; still more haystack? keep searching
827B | 4C 61 80 | JMP $8061   | HEXIT:  JMP STRT            ; back to main loop
827E | 4C 90 80 | JMP $8090   | HERROR: JMP ERROR           ; handle error
8281 |          |             | 
8281 |          |             | ; -----------------------------------------------------------------------------
8281 |          |             | ; load, save, or verify [LSV]
8281 | A0 01    | LDY #$01    | LD:     LDY.# 1              ; default to reading from tape, device #1
8283 | 84 BA    | STY $BA     |         STY.zp FA
8285 | 84 B9    | STY $B9     |         STY.zp SADD            ; default to secondary address #1
8287 | 88       | DEY         |         DEY
8288 | 84 B7    | STY $B7     |         STY.zp FNLEN           ; start with an empty filename
828A | 84 90    | STY $90     |         STY.zp SATUS           ; clear status
828C | A9 01    | LDA #$01    |         LDA.# STAGE >> 8        ; set filename pointer to staging buffer
828E | 85 BC    | STA $BC     |         STA.zp FNADR+1
8290 | A9 17    | LDA #$17    |         LDA.# STAGE & 0x00ff 
8292 | 85 BB    | STA $BB     |         STA.zp FNADR
8294 | 20 1E 87 | JSR $871E   | L1:     JSR GETCHR          ; get a character
8297 | F0 59    | BEQ $59     |         BEQ LSHORT          ; no filename given, try load or verify from tape
8299 | C9 20    | CMP #$20    |         CMP.# $20            ; skip leading spaces
829B | F0 F7    | BEQ $F7     |         BEQ L1
829D | C9 22    | CMP #$22    |         CMP.# $22            ; error if filename doesn't start with a quote
829F | D0 16    | BNE $16     |         BNE LERROR
82A1 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; load current char pointer into index reg
82A4 | BD 00 02 | LDA $0200,X | L3:     LDA,X INBUFF        ; load current char from buffer to accumulator
82A7 | F0 49    | BEQ $49     |         BEQ LSHORT          ; no filename given, try load or verify from tape
82A9 | E8       | INX         |         INX                 ; next char
82AA | C9 22    | CMP #$22    |         CMP.# $22            ; is it a quote?
82AC | F0 0C    | BEQ $0C     |         BEQ L8              ; if so, we've reached the end of the filename
82AE | 91 BB    | STA ($BB),Y |         STA.i,Y FNADR       ; if not, save character in filename buffer
82B0 | E6 B7    | INC $B7     |         INC.zp FNLEN           ; increment filename length
82B2 | C8       | INY         |         INY 
82B3 | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; check whether buffer is full
82B5 | 90 ED    | BCC $ED     |         BCC L3              ; if not, get another character
82B7 | 4C 90 80 | JMP $8090   | LERROR: JMP ERROR           ; if so, handle error
82BA | 8E 31 02 | STX $0231   | L8:     STX CHRPNT          ; set character pointer to the current index
82BD | 20 1E 87 | JSR $871E   |         JSR GETCHR          ; eat separator between filename and device #
82C0 | F0 30    | BEQ $30     |         BEQ LSHORT          ; no separator, try to load or verify from tape
82C2 | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get device number
82C5 | B0 2B    | BCS $2B     |         BCS LSHORT          ; no device # given, try load or verify from tape
82C7 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; set device number for kernal routines
82C9 | 85 BA    | STA $BA     |         STA.zp FA
82CB | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get start address for load or save in TMP0
82CE | B0 22    | BCS $22     |         BCS LSHORT          ; no start address, try to load or verify
82D0 | 20 38 87 | JSR $8738   |         JSR COPY12          ; transfer start address to TMP2
82D3 | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get end address for save in TMP0
82D6 | B0 3D    | BCS $3D     |         BCS LDADDR          ; no end address, try to load to given start addr
82D8 | 20 DD 86 | JSR $86DD   |         JSR CRLF            ; new line
82DB | A6 C1    | LDX $C1     |         LDX.zp TMP0            ; put low byte of end address in X
82DD | A4 C2    | LDY $C2     |         LDY.zp TMP0+1          ; put high byte of end address in Y
82DF | AD 32 02 | LDA $0232   |         LDA SAVY            ; confirm that we're doing a save
82E2 | C9 53    | CMP #$53    |         CMP.# 'S'
82E4 | D0 D1    | BNE $D1     |         BNE LERROR          ; if not, error due to too many params
82E6 | A9 00    | LDA #$00    |         LDA.# 0
82E8 | 85 B9    | STA $B9     |         STA.zp SADD            ; set secondary address to 0
82EA | A9 C3    | LDA #$C3    |         LDA.# TMP2           ; put addr of zero-page pointer to data in A
82EC | 20 D8 FF | JSR $FFD8   |         JSR SAVE            ; call kernal save routine
82EF | 4C 61 80 | JMP $8061   | LSVXIT: JMP STRT            ; back to mainloop
82F2 | AD 32 02 | LDA $0232   | LSHORT: LDA SAVY            ; check which command we received
82F5 | C9 56    | CMP #$56    |         CMP.# 'V'
82F7 | F0 06    | BEQ $06     |         BEQ LOADIT          ; we're doing a verify so don't set A to 0
82F9 | C9 4C    | CMP #$4C    |         CMP.# 'L'
82FB | D0 BA    | BNE $BA     |         BNE LERROR          ; error due to not enough params for save
82FD | A9 00    | LDA #$00    |         LDA.# 0              ; 0 in A signals load, anything else is verify
82FF | 20 D5 FF | JSR $FFD5   | LOADIT: JSR LOAD            ; call kernal load routine
8302 | A5 90    | LDA $90     |         LDA.zp SATUS           ; get i/o status
8304 | 29 10    | AND #$10    |         AND.# $10            ; check bit 5 for checksum error
8306 | F0 E7    | BEQ $E7     |         BEQ LSVXIT          ; if no error go back to mainloop
8308 | AD 32 02 | LDA $0232   |         LDA SAVY            ; ?? not sure what these two lines are for...
830B | F0 AA    | BEQ $AA     |         BEQ LERROR          ; ?? SAVY will never be 0, so why check?
830D | A0 28    | LDY #$28    |         LDY.# MSG6-MSGBAS    ; display "ERROR" if checksum didn't match
830F | 20 84 89 | JSR $8984   |         JSR SNDMSG
8312 | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to mainloop
8315 | A6 C3    | LDX $C3     | LDADDR: LDX.zp TMP2            ; load address low byte in X
8317 | A4 C4    | LDY $C4     |         LDY.zp TMP2+1          ; load address high byte in Y
8319 | A9 00    | LDA #$00    |         LDA.# 0              ; 0 in A signals load
831B | 85 B9    | STA $B9     |         STA.zp SADD            ; secondary addr 0 means load to addr in X and Y
831D | F0 D3    | BEQ $D3     |         BEQ LSHORT          ; execute load
831F |          |             | 
831F |          |             | ; -----------------------------------------------------------------------------
831F |          |             | ; fill memory [F]
831F | 20 9C 87 | JSR $879C   | FILL:   JSR GETDIF          ; start in TMP2, end in STASH, length in STORE
8322 | B0 59    | BCS $59     |         BCS AERROR          ; carry set indicates error
8324 | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get value to fill in TMP0
8327 | B0 54    | BCS $54     |         BCS AERROR          ; carry set indicates error
8329 | 20 1E 87 | JSR $871E   |         JSR GETCHR          ; any more characters triggers an error
832C | D0 4F    | BNE $4F     |         BNE AERROR
832E | A0 00    | LDY #$00    |         LDY.# 0              ; no offset
8330 | A5 C1    | LDA $C1     | FILLP:  LDA.zp TMP0            ; load value to fill in accumulator
8332 | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2        ; store fill value in current address
8334 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
8337 | F0 08    | BEQ $08     |         BEQ FSTART          ; if pressed, back to main loop
8339 | 20 75 87 | JSR $8775   |         JSR ADDA2           ; increment address
833C | 20 63 87 | JSR $8763   |         JSR SUB13           ; decrement length
833F | B0 EF    | BCS $EF     |         BCS FILLP           ; keep going until length reaches 0
8341 | 4C 61 80 | JMP $8061   | FSTART: JMP STRT            ; back to main loop
8344 |          |             | 
8344 |          |             | ; -----------------------------------------------------------------------------
8344 |          |             | ; assemble [A.]
8344 |          |             | 
8344 |          |             | ; read in mnemonic
8344 | B0 37    | BCS $37     | ASSEM:  BCS AERROR          ; error if no address given
8346 | 20 38 87 | JSR $8738   |         JSR COPY12          ; copy address to TMP2
8349 | A2 00    | LDX #$00    | AGET1:  LDX.# 0
834B | 8E 0E 01 | STX $010E   |         STX U0AA0+1         ; clear byte that mnemonic gets shifted into
834E | 8E 08 01 | STX $0108   |         STX DIGCNT          ; clear digit count
8351 | 20 1E 87 | JSR $871E   | AGET2:  JSR GETCHR          ; get a char
8354 | D0 04    | BNE $04     |         BNE ALMOR           ; proceed if the character isn't null
8356 | E0 00    | CPX #$00    |         CPX.# 0              ; it's null, have read a mnemonic yet?
8358 | F0 E7    | BEQ $E7     |         BEQ FSTART          ; if not, silently go back to main loop
835A | C9 20    | CMP #$20    | ALMOR:  CMP.# $20            ; skip leading spaces
835C | F0 EB    | BEQ $EB     |         BEQ AGET1
835E | 9D 02 01 | STA $0102,X |         STA,X MNEMW         ; put character in mnemonic buffer
8361 | E8       | INX         |         INX
8362 | E0 03    | CPX #$03    |         CPX.# 3              ; have we read 3 characters yet?
8364 | D0 EB    | BNE $EB     |         BNE AGET2           ; if not, get next character
8366 |          |             | 
8366 |          |             | ; compress mnemonic into two bytes
8366 | CA       | DEX         | ASQEEZ: DEX                 ; move to previous char
8367 | 30 17    | BMI $17     |         BMI AOPRND          ; if we're done with mnemonic, look for operand
8369 | BD 02 01 | LDA $0102,X |         LDA,X MNEMW         ; get current character
836C | 38       | SEC         |         SEC                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
836D | E9 3F    | SBC #$3F    |         SBC.# $3F            ; subtract $3F from ascii code so A-Z = 2 to 27
836F | A0 05    | LDY #$05    |         LDY.# $05            ; letters now fit in 5 bits; shift them out
8371 | 4A       | LSR A       | ASHIFT: LSR.A               ;   into the first two bytes of the inst buffer
8372 | 6E 0E 01 | ROR $010E   |         ROR U0AA0+1         ; catch the low bit from accumulator in right byte
8375 | 6E 0D 01 | ROR $010D   |         ROR U0AA0           ; catch the low bit from right byte in left byte
8378 | 88       | DEY         |         DEY                 ; count down bits
8379 | D0 F6    | BNE $F6     |         BNE ASHIFT          ; keep looping until we reach zero
837B | F0 E9    | BEQ $E9     |         BEQ ASQEEZ          ; unconditional branch to handle next char
837D | 4C 90 80 | JMP $8090   | AERROR: JMP ERROR           ; handle error
8380 |          |             | 
8380 |          |             | ; parse operand
8380 | A2 02    | LDX #$02    | AOPRND: LDX.# 2              ; mnemonic is in first two bytes so start at third
8382 | AD 08 01 | LDA $0108   | ASCAN:  LDA DIGCNT          ; did we find address digits last time?
8385 | D0 2D    | BNE $2D     |         BNE AFORM1          ; if so, look for mode chars
8387 | 20 27 86 | JSR $8627   |         JSR RDVAL           ; otherwise, look for an address
838A | F0 25    | BEQ $25     |         BEQ AFORM0          ; we didn't find an address, look for characters
838C | B0 EF    | BCS $EF     |         BCS AERROR          ; carry flag indicates error
838E | A9 24    | LDA #$24    |         LDA.# 0x24  ; "$"
8390 | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; prefix addresses with $
8393 | E8       | INX         |         INX                 ; next position in buffer
8394 | A0 04    | LDY #$04    |         LDY.# 4              ; non-zero page addresses are 4 hex digits
8396 | AD 0A 01 | LDA $010A   |         LDA NUMBIT          ; check numeric base in which address was given
8399 | C9 08    | CMP #$08    |         CMP.# 8              ; for addresses given in octal or binary
839B | 90 05    | BCC $05     |         BCC AADDR           ;   use only the high byte to determine page
839D | CC 08 01 | CPY $0108   |         CPY DIGCNT          ; for decimal or hex, force non-zero page addressing
83A0 | F0 06    | BEQ $06     |         BEQ AFILL0          ;   if address was given with four digits or more 
83A2 | A5 C2    | LDA $C2     | AADDR:  LDA.zp TMP0+1          ; check whether high byte of address is zero
83A4 | D0 02    | BNE $02     |         BNE AFILL0          ; non-zero high byte means we're not in zero page
83A6 | A0 02    | LDY #$02    |         LDY.# 2              ; if it's in zero page, addr is 2 hex digits
83A8 | A9 30    | LDA #$30    | AFILL0: LDA.# $30            ; use 0 as placeholder for each hex digit in addr
83AA | 9D 0D 01 | STA $010D,X | AFIL0L: STA,X U0AA0         ; put placeholder in assembly buffer
83AD | E8       | INX         |         INX                 ; move to next byte in buffer
83AE | 88       | DEY         |         DEY                 ; decrement number of remaining digits
83AF | D0 F9    | BNE $F9     |         BNE AFIL0L          ; loop until all digits have been placed
83B1 | CE 31 02 | DEC $0231   | AFORM0: DEC CHRPNT          ; non-numeric input; back 1 char to see what it was
83B4 | 20 1E 87 | JSR $871E   | AFORM1: JSR GETCHR          ; get next character
83B7 | F0 0E    | BEQ $0E     |         BEQ AESCAN          ; if there is none, we're finished scanning
83B9 | C9 20    | CMP #$20    |         CMP.# $20            ; skip spaces
83BB | F0 C5    | BEQ $C5     |         BEQ ASCAN
83BD | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; store character in assembly buffer
83C0 | E8       | INX         |         INX                 ; move to next byte in buffer
83C1 | E0 0A    | CPX #$0A    |         CPX.# U0AAE-U0AA0    ; is instruction buffer full?
83C3 | 90 BD    | BCC $BD     |         BCC ASCAN           ; if not, keep scanning
83C5 | B0 B6    | BCS $B6     |         BCS AERROR          ; error if buffer is full
83C7 |          |             | 
83C7 |          |             | 
83C7 |          |             | ; find matching opcode
83C7 | 8E 2F 02 | STX $022F   | AESCAN: STX STORE           ; save number of bytes in assembly buffer
83CA | A2 00    | LDX #$00    |         LDX.# 0              ; start at opcode $00 and check every one until
83CC | 8E 06 01 | STX $0106   |         STX OPCODE          ;   we find one that matches our criteria
83CF | A2 00    | LDX #$00    | ATRYOP: LDX.# 0
83D1 | 8E 33 02 | STX $0233   |         STX U9F             ; reset index into work buffer
83D4 | AD 06 01 | LDA $0106   |         LDA OPCODE
83D7 | 20 8E 85 | JSR $858E   |         JSR INSTXX          ; look up instruction format for current opcode
83DA | AE 00 01 | LDX $0100   |         LDX ACMD            ; save addressing command for later
83DD | 8E 30 02 | STX $0230   |         STX STORE+1
83E0 | AA       | TAX         |         TAX                 ; use current opcode as index
83E1 | BD 63 8A | LDA $8A63,X |         LDA,X MNEMR         ; check right byte of compressed mnemonic
83E4 | 20 B5 84 | JSR $84B5   |         JSR CHEKOP
83E7 | BD 23 8A | LDA $8A23,X |         LDA,X MNEML         ; check left byte of compressed mnemonic
83EA | 20 B5 84 | JSR $84B5   |         JSR CHEKOP
83ED | A2 06    | LDX #$06    |         LDX.# 6              ; 6 possible characters to check against operand
83EF | E0 03    | CPX #$03    | TRYIT:  CPX.# 3              ; are we on character 3?
83F1 | D0 14    | BNE $14     |         BNE TRYMOD          ; if not, check operand characters
83F3 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; otherwise, check number of bytes in operand
83F6 | F0 0F    | BEQ $0F     |         BEQ TRYMOD          ; if zero, check operand characters
83F8 | AD 00 01 | LDA $0100   | TRYAD:  LDA ACMD            ; otherwise, look for an address
83FB | C9 E8    | CMP #$E8    |         CMP.# $E8            ; special case for relative addressing mode
83FD |          |             |                             ;   since it's specified with 4 digits in assembly
83FD |          |             |                             ;   but encoded with only 1 byte in object code
83FD | A9 30    | LDA #$30    |         LDA.# $30            ; '0' is the digit placeholder we're looking for
83FF | B0 1E    | BCS $1E     |         BCS TRY4B           ; ACMD >= $E8 indicates relative addressing
8401 | 20 B2 84 | JSR $84B2   |         JSR CHEK2B          ; ACMD < $E8 indicates normal addressing
8404 | 88       | DEY         |         DEY                 ; consume byte
8405 | D0 F1    | BNE $F1     |         BNE TRYAD           ; check for 2 more digits if not zero-page
8407 | 0E 00 01 | ASL $0100   | TRYMOD: ASL ACMD            ; shift a bit out of the addressing command
840A | 90 0E    | BCC $0E     |         BCC UB4DF           ; if it's zero, skip checking current character
840C | BD 16 8A | LDA $8A16,X |         LDA,X CHAR1-1
840F | 20 B5 84 | JSR $84B5   |         JSR CHEKOP          ; otherwise first character against operand
8412 | BD 1C 8A | LDA $8A1C,X |         LDA,X CHAR2-1       ; get second character to check
8415 | F0 03    | BEQ $03     |         BEQ UB4DF           ; if it's zero, skip checking it
8417 | 20 B5 84 | JSR $84B5   |         JSR CHEKOP          ; otherwise check it against hte operand
841A | CA       | DEX         | UB4DF:  DEX                 ; move to next character
841B | D0 D2    | BNE $D2     |         BNE TRYIT           ; repeat tests
841D | F0 06    | BEQ $06     |         BEQ TRYBRAN
841F | 20 B2 84 | JSR $84B2   | TRY4B:  JSR CHEK2B          ; check for 4 digit address placeholder
8422 | 20 B2 84 | JSR $84B2   |         JSR CHEK2B          ;   by checking for 2 digits twice
8425 | AD 2F 02 | LDA $022F   | TRYBRAN: LDA STORE           ; get number of bytes in assembly buffer
8428 | CD 33 02 | CMP $0233   |         CMP U9F             ; more bytes left to check?
842B | F0 03    | BEQ $03     |         BEQ ABRAN           ; if not, we've found a match; build instruction
842D | 4C C2 84 | JMP $84C2   |         JMP BUMPOP          ; if so, this opcode doesn't match; try the next
8430 |          |             | 
8430 |          |             | ; convert branches to relative address
8430 | AC 01 01 | LDY $0101   | ABRAN:  LDY LENGTH          ; get number of bytes in operand
8433 | F0 32    | BEQ $32     |         BEQ A1BYTE          ; if none, just output the opcode
8435 | AD 30 02 | LDA $0230   |         LDA STORE+1         ; otherwise check the address format
8438 | C9 9D    | CMP #$9D    |         CMP.# $9D            ; is it a relative branch?
843A | D0 23    | BNE $23     |         BNE OBJPUT          ; if not, skip relative branch calculation
843C | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; calculate the difference between the current
843E | E5 C3    | SBC $C3     |         SBC.zp TMP2            ;   address and the branch target (low byte)
8440 | AA       | TAX         |         TAX                 ; save it in X
8441 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; borrow from the high byte if necessary
8443 | E5 C4    | SBC $C4     |         SBC.zp TMP2+1
8445 | 90 08    | BCC $08     |         BCC ABBACK          ; if result is negative, we're branching back
8447 | D0 66    | BNE $66     |         BNE SERROR          ; high bytes must be equal when branching forward
8449 | E0 82    | CPX #$82    |         CPX.# $82            ; difference between low bytes must be < 130
844B | B0 62    | BCS $62     |         BCS SERROR          ; error if the address is too far away
844D | 90 08    | BCC $08     |         BCC ABRANX
844F | A8       | TAY         | ABBACK: TAY                 ; when branching backward high byte of target must
8450 | C8       | INY         |         INY                 ;   be 1 less than high byte of current address
8451 | D0 5C    | BNE $5C     |         BNE SERROR          ; if not, it's too far away
8453 | E0 82    | CPX #$82    |         CPX.# $82            ; difference between low bytes must be < 130
8455 | 90 58    | BCC $58     |         BCC SERROR          ; if not, it's too far away
8457 | CA       | DEX         | ABRANX: DEX                 ; adjust branch target relative to the 
8458 | CA       | DEX         |         DEX                 ;   instruction following this one
8459 | 8A       | TXA         |         TXA
845A | AC 01 01 | LDY $0101   |         LDY LENGTH          ; load length of operand
845D | D0 03    | BNE $03     |         BNE OBJP2           ; don't use the absolute address
845F |          |             | 
845F |          |             | ; assemble machine code
845F | B9 C0 00 | LDA $00C0,Y | OBJPUT: LDA,Y TMP0-1        ; get the operand
8462 | 91 C3    | STA ($C3),Y | OBJP2:  STA.i,Y TMP2        ; store it after the opcode
8464 | 88       | DEY         |         DEY
8465 | D0 F8    | BNE $F8     |         BNE OBJPUT          ; copy the other byte of operand if there is one
8467 | AD 06 01 | LDA $0106   | A1BYTE: LDA OPCODE          ; put opcode into instruction
846A | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2
846C | 20 DD 86 | JSR $86DD   |         JSR CRLF            ; carriage return
846F | A9 91    | LDA #$91    |         LDA.# $91            ; back up one line
8471 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8474 | A0 2E    | LDY #$2E    |         LDY.# MSG7-MSGBAS    ; "A " prefix
8476 | 20 71 89 | JSR $8971   |         JSR SNDCLR          ; clear line
8479 | 20 10 85 | JSR $8510   |         JSR DISLIN          ; disassemble the instruction we just assembled
847C | EE 01 01 | INC $0101   |         INC LENGTH          ; instruction length = operand length + 1 byte
847F | AD 01 01 | LDA $0101   |         LDA LENGTH          ;   for the opcode
8482 | 20 77 87 | JSR $8777   |         JSR BUMPAD2         ; increment address by length of instruction
8485 | A9 41    | LDA #$41    |         LDA.# 'A'            ; stuff keyboard buffer with next assemble command:
8487 | 8D 77 02 | STA $0277   |         STA KEYD            ;   "A XXXX " where XXXX is the next address
848A | A9 20    | LDA #$20    |         LDA.# ' '            ;   after the previously assembled instruction
848C | 8D 78 02 | STA $0278   |         STA KEYD+1
848F | 8D 7D 02 | STA $027D   |         STA KEYD+6
8492 | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ; convert high byte of next address to hex
8494 | 20 06 87 | JSR $8706   |         JSR ASCTWO
8497 | 8D 79 02 | STA $0279   |         STA KEYD+2          ; put it in the keyboard buffer
849A | 8E 7A 02 | STX $027A   |         STX KEYD+3
849D | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; convert low byte of next address to hex
849F | 20 06 87 | JSR $8706   |         JSR ASCTWO
84A2 | 8D 7B 02 | STA $027B   |         STA KEYD+4          ; put it in the keyboard buffer
84A5 | 8E 7C 02 | STX $027C   |         STX KEYD+5
84A8 | A9 07    | LDA #$07    |         LDA.# 7              ; set number of chars in keyboard buffer
84AA | 85 C6    | STA $C6     |         STA.zp NDX
84AC | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to main loop
84AF | 4C 90 80 | JMP $8090   | SERROR: JMP ERROR           ; handle error
84B2 |          |             | 
84B2 |          |             | ; check characters in operand
84B2 | 20 B5 84 | JSR $84B5   | CHEK2B: JSR CHEKOP          ; check two bytes against value in accumulator
84B5 | 8E 05 01 | STX $0105   | CHEKOP: STX SAVX            ; stash X
84B8 | AE 33 02 | LDX $0233   |         LDX U9F             ; get current index into work buffer
84BB | DD 0D 01 | CMP $010D,X |         CMP,X U0AA0         ; check whether this opcode matches the buffer
84BE | F0 0A    | BEQ $0A     |         BEQ OPOK            ;   matching so far, check the next criteria
84C0 | 68       | PLA         |         PLA                 ; didn't match, so throw away return address
84C1 | 68       | PLA         |         PLA                 ;   on the stack because we're starting over
84C2 | EE 06 01 | INC $0106   | BUMPOP: INC OPCODE          ; check the next opcode
84C5 | F0 E8    | BEQ $E8     |         BEQ SERROR          ; error if we tried every opcode and none fit
84C7 | 4C CF 83 | JMP $83CF   |         JMP ATRYOP          ; start over with new opcode
84CA | EE 33 02 | INC $0233   | OPOK:   INC U9F             ; opcode matches so far; check the next criteria
84CD | AE 05 01 | LDX $0105   |         LDX SAVX            ; restore X
84D0 | 60       | RTS         |         RTS
84D1 |          |             | 
84D1 |          |             | ; -----------------------------------------------------------------------------
84D1 |          |             | ; disassemble [D]
84D1 | B0 08    | BCS $08     | DISASS: BCS DIS0AD          ; if no address was given, start from last address
84D3 | 20 38 87 | JSR $8738   |         JSR COPY12          ; copy start address to TMP2
84D6 | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get end address in TMP0
84D9 | 90 06    | BCC $06     |         BCC DIS2AD          ; if one was given, skip default
84DB | A9 14    | LDA #$14    | DIS0AD: LDA.# $14            ; disassemble 14 bytes by default
84DD | 85 C1    | STA $C1     |         STA.zp TMP0            ; store length in TMP0
84DF | D0 05    | BNE $05     |         BNE DISGO           ; skip length calculation
84E1 | 20 41 87 | JSR $8741   | DIS2AD: JSR SUB12           ; calculate number of bytes between start and end
84E4 | 90 1F    | BCC $1F     |         BCC DERROR          ; error if end address is before start address
84E6 | 20 6B 89 | JSR $896B   | DISGO:  JSR CLINE           ; clear the current line
84E9 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
84EC | F0 14    | BEQ $14     |         BEQ DISEXIT         ; exit early if pressed
84EE | 20 08 85 | JSR $8508   |         JSR DSOUT1          ; output disassembly prefix ". "
84F1 | EE 01 01 | INC $0101   |         INC LENGTH
84F4 | AD 01 01 | LDA $0101   |         LDA LENGTH          ; add length of last instruction to start address
84F7 | 20 77 87 | JSR $8777   |         JSR BUMPAD2
84FA | AD 01 01 | LDA $0101   |         LDA LENGTH          ; subtract length of last inst from end address
84FD | 20 51 87 | JSR $8751   |         JSR SUBA2
8500 | B0 E4    | BCS $E4     |         BCS DISGO
8502 | 4C 61 80 | JMP $8061   | DISEXIT: JMP STRT            ; back to mainloop
8505 | 4C 90 80 | JMP $8090   | DERROR: JMP ERROR
8508 |          |             | 
8508 | A9 2E    | LDA #$2E    | DSOUT1: LDA.# '.'            ; output ". " prefix to allow edit and reassemble
850A | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
850D | 20 D5 86 | JSR $86D5   |         JSR SPACE
8510 |          |             | 
8510 | 20 C8 86 | JSR $86C8   | DISLIN: JSR SHOWAD          ; show the address of the instruction
8513 | 20 D5 86 | JSR $86D5   |         JSR SPACE           ; insert a space
8516 | A0 00    | LDY #$00    |         LDY.# 0              ; no offset
8518 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; load operand of current instruction
851A | 20 8E 85 | JSR $858E   |         JSR INSTXX          ; get mnemonic and addressing mode for opcode
851D | 48       | PHA         |         PHA                 ; save index into mnemonic table
851E | AE 01 01 | LDX $0101   |         LDX LENGTH          ; get length of operand
8521 | E8       | INX         |         INX                 ; add 1 byte for opcode
8522 | CA       | DEX         | DSBYT:  DEX                 ; decrement index
8523 | 10 0E    | BPL $0E     |         BPL DSHEX           ; show hex for byte being disassembled
8525 | 8C 32 02 | STY $0232   |         STY SAVY            ; save index
8528 | A0 30    | LDY #$30    |         LDY.# MSG8-MSGBAS    ; skip 3 spaces
852A | 20 84 89 | JSR $8984   |         JSR SNDMSG
852D | AC 32 02 | LDY $0232   |         LDY SAVY            ; restore index
8530 | 4C 38 85 | JMP $8538   |         JMP NXBYT
8533 | B1 C3    | LDA ($C3),Y | DSHEX:  LDA.i,Y TMP2        ; show hex for byte
8535 | 20 D2 86 | JSR $86D2   |         JSR WRBYTE
8538 |          |             | 
8538 | C8       | INY         | NXBYT:  INY                 ; next byte
8539 | C0 03    | CPY #$03    |         CPY.# 3              ; have we output 3 bytes yet?
853B | 90 E5    | BCC $E5     |         BCC DSBYT           ; if not, loop
853D | 68       | PLA         |         PLA                 ; restore index into mnemonic table
853E | A2 03    | LDX #$03    |         LDX.# 3              ; 3 letters in mnemonic
8540 | 20 D6 85 | JSR $85D6   |         JSR PROPXX          ; print mnemonic
8543 | A2 06    | LDX #$06    |         LDX.# 6              ; 6 possible address mode character combos
8545 | E0 03    | CPX #$03    | PRADR1: CPX.# 3              ; have we checked the third combo yet?
8547 | D0 16    | BNE $16     |         BNE PRADR3          ; if so, output the leading characters
8549 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; get the length of the operand
854C | F0 11    | BEQ $11     |         BEQ PRADR3          ; if it's zero, there's no operand to print
854E | AD 00 01 | LDA $0100   | PRADR2: LDA ACMD            ; otherwise, get the addressing mode
8551 | C9 E8    | CMP #$E8    |         CMP.# $E8            ; check for relative addressing
8553 | 08       | PHP         |         PHP                 ; save result of check
8554 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; get the operand
8556 | 28       | PLP         |         PLP                 ; restore result of check
8557 | B0 1D    | BCS $1D     |         BCS RELAD           ; handle a relative address
8559 | 20 F6 86 | JSR $86F6   |         JSR WRTWO           ; output digits from address
855C | 88       | DEY         |         DEY
855D | D0 EF    | BNE $EF     |         BNE PRADR2          ; repeat for next byte of operand, if there is one
855F | 0E 00 01 | ASL $0100   | PRADR3: ASL ACMD            ; check whether addr mode uses the current char
8562 | 90 0E    | BCC $0E     |         BCC PRADR4          ; if not, skip it
8564 | BD 16 8A | LDA $8A16,X |         LDA,X CHAR1-1       ; look up the first char in the table
8567 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print first char
856A | BD 1C 8A | LDA $8A1C,X |         LDA,X CHAR2-1       ; look up the second char in the table
856D | F0 03    | BEQ $03     |         BEQ PRADR4          ; if there's no second character, skip it
856F | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print second char
8572 | CA       | DEX         | PRADR4: DEX                 ; next potential address mode character
8573 | D0 D0    | BNE $D0     |         BNE PRADR1          ; loop if we haven't checked them all yet
8575 | 60       | RTS         |         RTS                 ; back to caller
8576 | 20 82 85 | JSR $8582   | RELAD:  JSR UB64D           ; calculate absolute address from relative
8579 | 18       | CLC         |         CLC
857A | 69 01    | ADC #$01    |         ADC.# 1              ; adjust address relative to next instruction
857C | D0 01    | BNE $01     |         BNE RELEND          ; don't increment high byte unless we overflowed
857E | E8       | INX         |         INX                 ; increment high byte
857F | 4C CC 86 | JMP $86CC   | RELEND: JMP WRADDR          ; print address
8582 |          |             | 
8582 | A6 C4    | LDX $C4     | UB64D:  LDX.zp TMP2+1          ; get high byte of current address
8584 | A8       | TAY         |         TAY                 ; is relative address positive or negative?
8585 | 10 01    | BPL $01     |         BPL RELC2           ; if positive, leave high byte alone
8587 | CA       | DEX         |         DEX                 ; if negative, decrement high byte
8588 | 65 C3    | ADC $C3     | RELC2:  ADC.zp TMP2            ; add relative address to low byte
858A | 90 01    | BCC $01     |         BCC RELC3           ; if there's no carry, we're done
858C | E8       | INX         |         INX                 ; if there's a carry, increment the high byte
858D | 60       | RTS         | RELC3:  RTS
858E |          |             | 
858E |          |             | ; -----------------------------------------------------------------------------
858E |          |             | ; get opcode mode and length
858E |          |             | 
858E |          |             | ; Note: the labels are different, but the code of this subroutine is almost
858E |          |             | ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
858E |          |             | ; the Apple II Red Book. I'm not sure exactly where this code originated
858E |          |             | ; (MOS or Apple) but it's clear that this part of Supermon64 and the 
858E |          |             | ; Mini-Asssembler share a common heritage.  The comments showing the way the 
858E |          |             | ; opcodes are transformed into indexes for the mnemonic lookup table come
858E |          |             | ; from the Mini-Assembler source.
858E |          |             | 
858E | A8       | TAY         | INSTXX: TAY                 ; stash opcode in accumulator in Y for later
858F | 4A       | LSR A       |         LSR.A               ; is opcode even or odd?
8590 | 90 0B    | BCC $0B     |         BCC IEVEN
8592 | 4A       | LSR A       |         LSR.A
8593 | B0 17    | BCS $17     |         BCS ERR             ; invalid opcodes XXXXXX11
8595 | C9 22    | CMP #$22    |         CMP.# $22
8597 | F0 13    | BEQ $13     |         BEQ ERR             ; invalid opcode 10001001
8599 | 29 07    | AND #$07    |         AND.# $07            ; mask bits to 10000XXX
859B | 09 80    | ORA #$80    |         ORA.# $80
859D | 4A       | LSR A       | IEVEN:  LSR.A               ; LSB determines whether to use left/right nybble
859E | AA       | TAX         |         TAX                 ; get format index using remaining high bytes
859F | BD C5 89 | LDA $89C5,X |         LDA,X MODE
85A2 | B0 04    | BCS $04     |         BCS RTMODE          ; look at left or right nybble based on carry bit
85A4 | 4A       | LSR A       |         LSR.A               ; if carry = 0, use left nybble
85A5 | 4A       | LSR A       |         LSR.A
85A6 | 4A       | LSR A       |         LSR.A
85A7 | 4A       | LSR A       |         LSR.A
85A8 | 29 0F    | AND #$0F    | RTMODE: AND.# $0F            ; if carry = 1, use right nybble
85AA | D0 04    | BNE $04     |         BNE GETFMT
85AC | A0 80    | LDY #$80    | ERR:    LDY.# $80            ; substitute 10000000 for invalid opcodes
85AE | A9 00    | LDA #$00    |         LDA.# 0
85B0 | AA       | TAX         | GETFMT: TAX
85B1 | BD 09 8A | LDA $8A09,X |         LDA,X MODE2         ; lookup operand format using selected nybble
85B4 | 8D 00 01 | STA $0100   |         STA ACMD            ; save for later use
85B7 | 29 03    | AND #$03    |         AND.# $03            ; lower 2 bits indicate number of bytes in operand
85B9 | 8D 01 01 | STA $0101   |         STA LENGTH
85BC | 98       | TYA         |         TYA                 ; restore original opcode
85BD | 29 8F    | AND #$8F    |         AND.# $8F            ; mask bits to X000XXXX
85BF | AA       | TAX         |         TAX                 ; save it
85C0 | 98       | TYA         |         TYA                 ; restore original opcode
85C1 | A0 03    | LDY #$03    |         LDY.# 3
85C3 | E0 8A    | CPX #$8A    |         CPX.# $8A            ; check if opcode = 1XXX1010
85C5 | F0 0B    | BEQ $0B     |         BEQ GTFM4
85C7 | 4A       | LSR A       | GTFM2:  LSR.A               ; transform opcode into index for mnemonic table
85C8 | 90 08    | BCC $08     |         BCC GTFM4
85CA | 4A       | LSR A       |         LSR.A               ; opcodes transformed as follows:
85CB | 4A       | LSR A       | GTFM3:  LSR.A               ; 1XXX1010->00101XXX
85CC | 09 20    | ORA #$20    |         ORA.# $20            ; XXXYYY01->00111XXX
85CE | 88       | DEY         |         DEY                 ; XXXYYY10->00111XXX
85CF | D0 FA    | BNE $FA     |         BNE GTFM3           ; XXXYY100->00110XXX
85D1 | C8       | INY         |         INY                 ; XXXXX000->000XXXXX
85D2 | 88       | DEY         | GTFM4:  DEY
85D3 | D0 F2    | BNE $F2     |         BNE GTFM2
85D5 | 60       | RTS         |         RTS
85D6 |          |             | 
85D6 |          |             | ; -----------------------------------------------------------------------------
85D6 |          |             | ; extract and print packed mnemonics
85D6 | A8       | TAY         | PROPXX: TAY                 ; use index in accumulator to look up mnemonic
85D7 | B9 23 8A | LDA $8A23,Y |         LDA,Y MNEML         ;   and place a temporary copy in STORE
85DA | 8D 2F 02 | STA $022F   |         STA STORE
85DD | B9 63 8A | LDA $8A63,Y |         LDA,Y MNEMR
85E0 | 8D 30 02 | STA $0230   |         STA STORE+1
85E3 | A9 00    | LDA #$00    | PRMN1:  LDA.# 0              ; clear accumulator
85E5 | A0 05    | LDY #$05    |         LDY.# $05            ; shift 5 times
85E7 | 0E 30 02 | ASL $0230   | PRMN2:  ASL STORE+1         ; shift right byte
85EA | 2E 2F 02 | ROL $022F   |         ROL STORE           ; rotate bits from right byte into left byte
85ED | 2A       | ROL A       |         ROL.A               ; rotate bits from left byte into accumulator
85EE | 88       | DEY         |         DEY                 ; next bit
85EF | D0 F6    | BNE $F6     |         BNE PRMN2           ; loop until all bits shifted
85F1 | 69 3F    | ADC #$3F    |         ADC.# $3F            ; calculate ascii code for letter by adding to '?'
85F3 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output letter
85F6 | CA       | DEX         |         DEX                 ; next letter
85F7 | D0 EA    | BNE $EA     |         BNE PRMN1           ; loop until all 3 letters are output
85F9 | 4C D5 86 | JMP $86D5   |         JMP SPACE           ; output space
85FC |          |             | 
85FC |          |             | ; -----------------------------------------------------------------------------
85FC |          |             | ; read parameters
85FC | CE 31 02 | DEC $0231   | RDPAR:  DEC CHRPNT          ; back up one char
85FF | 20 27 86 | JSR $8627   | GETPAR: JSR RDVAL           ; read the value
8602 | B0 17    | BCS $17     |         BCS GTERR           ; carry set indicates error
8604 | 20 1B 87 | JSR $871B   |         JSR GOTCHR          ; check previous character
8607 | D0 0A    | BNE $0A     |         BNE CKTERM          ; if it's not null, check if it's a valid separator
8609 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up one char
860C | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; get number of digits read
860F | D0 11    | BNE $11     |         BNE GETGOT          ; found some digits
8611 | F0 0D    | BEQ $0D     |         BEQ GTNIL           ; didn't find any digits
8613 | C9 20    | CMP #$20    | CKTERM: CMP.# $20            ; space or comma are valid separators
8615 | F0 0B    | BEQ $0B     |         BEQ GETGOT          ; anything else is an error
8617 | C9 2C    | CMP #$2C    |         CMP.# ','
8619 | F0 07    | BEQ $07     |         BEQ GETGOT
861B | 68       | PLA         | GTERR:  PLA                 ; encountered error
861C | 68       | PLA         |         PLA                 ; get rid of command vector pushed on stack
861D | 4C 90 80 | JMP $8090   |         JMP ERROR           ; handle error
8620 | 38       | SEC         | GTNIL:  SEC                 ; set carry to indicate no parameter found
8621 | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (CLC)
8622 | 18       | CLC         | GETGOT: CLC                 ; clear carry to indicate paremeter returned
8623 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; return number of digits in A
8626 | 60       | RTS         |         RTS                 ; return to address pushed from vector table
8627 |          |             | 
8627 |          |             | ; -----------------------------------------------------------------------------
8627 |          |             | ; read a value in the specified base
8627 | A9 00    | LDA #$00    | RDVAL:  LDA.# 0              ; clear temp
8629 | 85 C1    | STA $C1     |         STA.zp TMP0
862B | 85 C2    | STA $C2     |         STA.zp TMP0+1
862D | 8D 08 01 | STA $0108   |         STA DIGCNT          ; clear digit counter
8630 | 8A       | TXA         |         TXA                 ; save X and Y
8631 | 48       | PHA         |         PHA
8632 | 98       | TYA         |         TYA
8633 | 48       | PHA         |         PHA
8634 | 20 1E 87 | JSR $871E   | RDVMOR: JSR GETCHR          ; get next character from input buffer
8637 | F0 1E    | BEQ $1E     |         BEQ RDNILK          ; null at end of buffer
8639 | C9 20    | CMP #$20    |         CMP.# $20            ; skip spaces
863B | F0 F7    | BEQ $F7     |         BEQ RDVMOR
863D | A2 03    | LDX #$03    |         LDX.# 3              ; check numeric base [$+&%]
863F | DD B6 8A | CMP $8AB6,X | GNMODE: CMP,X HIKEY
8642 | F0 07    | BEQ $07     |         BEQ GOTMOD          ; got a match, set up base
8644 | CA       | DEX         |         DEX
8645 | 10 F8    | BPL $F8     |         BPL GNMODE          ; check next base
8647 | E8       | INX         |         INX                 ; default to hex
8648 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up one character
864B | BC DB 8A | LDY $8ADB,X | GOTMOD: LDY,X MODTAB        ; get base value
864E | BD DF 8A | LDA $8ADF,X |         LDA,X LENTAB        ; get bits per digit
8651 | 8D 0A 01 | STA $010A   |         STA NUMBIT          ; store bits per digit 
8654 | 20 1E 87 | JSR $871E   | NUDIG:  JSR GETCHR          ; get next char in A
8657 | F0 63    | BEQ $63     | RDNILK: BEQ RDNIL           ; end of number if no more characters
8659 | 38       | SEC         |         SEC
865A | E9 30    | SBC #$30    |         SBC.# $30            ; subtract ascii value of 0 to get numeric value
865C | 90 5E    | BCC $5E     |         BCC RDNIL           ; end of number if character was less than 0
865E | C9 0A    | CMP #$0A    |         CMP.# $0A
8660 | 90 06    | BCC $06     |         BCC DIGMOR          ; not a hex digit if less than A
8662 | E9 07    | SBC #$07    |         SBC.# $07            ; 7 chars between ascii 9 and A, so subtract 7
8664 | C9 10    | CMP #$10    |         CMP.# $10            ; end of number if char is greater than F
8666 | B0 54    | BCS $54     |         BCS RDNIL
8668 | 8D 09 01 | STA $0109   | DIGMOR: STA INDIG           ; store the digit
866B | CC 09 01 | CPY $0109   |         CPY INDIG           ; compare base with the digit
866E | 90 4A    | BCC $4A     |         BCC RDERR           ; error if the digit >= the base
8670 | F0 48    | BEQ $48     |         BEQ RDERR
8672 | EE 08 01 | INC $0108   |         INC DIGCNT          ; increment the number of digits
8675 | C0 0A    | CPY #$0A    |         CPY.# 10
8677 | D0 0A    | BNE $0A     |         BNE NODECM          ; skip the next part if not using base 10
8679 | A2 01    | LDX #$01    |         LDX.# 1
867B | B5 C1    | LDA $C1,X   | DECLP1: LDA.zp,X TMP0          ; stash the previous 16-bit value for later use
867D | 9D 0B 01 | STA $010B,X |         STA,X STASH
8680 | CA       | DEX         |         DEX
8681 | 10 F8    | BPL $F8     |         BPL DECLP1
8683 | AE 0A 01 | LDX $010A   | NODECM: LDX NUMBIT          ; number of bits to shift
8686 | 06 C1    | ASL $C1     | TIMES2: ASL.zp TMP0            ; shift 16-bit value by specified number of bits
8688 | 26 C2    | ROL $C2     |         ROL.zp TMP0+1
868A | B0 2E    | BCS $2E     |         BCS RDERR           ; error if we overflowed 16 bits
868C | CA       | DEX         |         DEX
868D | D0 F7    | BNE $F7     |         BNE TIMES2          ; shift remaining bits
868F | C0 0A    | CPY #$0A    |         CPY.# 10
8691 | D0 18    | BNE $18     |         BNE NODEC2          ; skip the next part if not using base 10
8693 | 0E 0B 01 | ASL $010B   |         ASL STASH           ; shift the previous 16-bit value one bit left
8696 | 2E 0C 01 | ROL $010C   |         ROL STASH+1
8699 | B0 1F    | BCS $1F     |         BCS RDERR           ; error if we overflowed 16 bits
869B | AD 0B 01 | LDA $010B   |         LDA STASH           ; add shifted previous value to current value
869E | 65 C1    | ADC $C1     |         ADC.zp TMP0
86A0 | 85 C1    | STA $C1     |         STA.zp TMP0
86A2 | AD 0C 01 | LDA $010C   |         LDA STASH+1
86A5 | 65 C2    | ADC $C2     |         ADC.zp TMP0+1
86A7 | 85 C2    | STA $C2     |         STA.zp TMP0+1
86A9 | B0 0F    | BCS $0F     |         BCS RDERR           ; error if we overflowed 16 bits
86AB | 18       | CLC         | NODEC2: CLC 
86AC | AD 09 01 | LDA $0109   |         LDA INDIG           ; load current digit
86AF | 65 C1    | ADC $C1     |         ADC.zp TMP0            ; add current digit to low byte
86B1 | 85 C1    | STA $C1     |         STA.zp TMP0            ; and store result back in low byte
86B3 | 8A       | TXA         |         TXA                 ; A=0
86B4 | 65 C2    | ADC $C2     |         ADC.zp TMP0+1          ; add carry to high byte
86B6 | 85 C2    | STA $C2     |         STA.zp TMP0+1          ; and store result back in high byte
86B8 | 90 9A    | BCC $9A     |         BCC NUDIG           ; get next digit if we didn't overflow
86BA | 38       | SEC         | RDERR:  SEC                 ; set carry to indicate error
86BB | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (CLC)
86BC | 18       | CLC         | RDNIL:  CLC                 ; clear carry to indicate success
86BD | 8C 0A 01 | STY $010A   |         STY NUMBIT          ; save base of number
86C0 | 68       | PLA         |         PLA                 ; restore X and Y
86C1 | A8       | TAY         |         TAY
86C2 | 68       | PLA         |         PLA
86C3 | AA       | TAX         |         TAX
86C4 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; return number of digits in A
86C7 | 60       | RTS         |         RTS
86C8 |          |             | 
86C8 |          |             | ; -----------------------------------------------------------------------------
86C8 |          |             | ; print address
86C8 | A5 C3    | LDA $C3     | SHOWAD: LDA.zp TMP2
86CA | A6 C4    | LDX $C4     |         LDX.zp TMP2+1
86CC |          |             | 
86CC | 48       | PHA         | WRADDR: PHA                 ; save low byte
86CD | 8A       | TXA         |         TXA                 ; put high byte in A
86CE | 20 F6 86 | JSR $86F6   |         JSR WRTWO           ; output high byte
86D1 | 68       | PLA         |         PLA                 ; restore low byte
86D2 |          |             | 
86D2 | 20 F6 86 | JSR $86F6   | WRBYTE: JSR WRTWO           ; output byte in A
86D5 |          |             | 
86D5 | A9 20    | LDA #$20    | SPACE:  LDA.# $20            ; output space
86D7 | D0 0F    | BNE $0F     |         BNE FLIP
86D9 |          |             | 
86D9 | C9 0D    | CMP #$0D    | CHOUT:  CMP.# $0D            ; output char with special handling of CR
86DB | D0 0B    | BNE $0B     |         BNE FLIP
86DD | A9 0D    | LDA #$0D    | CRLF:   LDA.# $0D            ; load CR in A
86DF | 24 13    | BIT $13     |         BIT.zp $13             ; check default channel
86E1 | 10 05    | BPL $05     |         BPL FLIP            ; if high bit is clear output CR only
86E3 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; otherwise output CR+LF
86E6 | A9 0A    | LDA #$0A    |         LDA.# $0A            ; output LF
86E8 | 4C D2 FF | JMP $FFD2   | FLIP:   JMP CHROUT
86EB |          |             | 
86EB | 20 DD 86 | JSR $86DD   | FRESH:  JSR CRLF            ; output CR
86EE | A9 20    | LDA #$20    |         LDA.# $20            ; load space in A
86F0 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
86F3 | 4C 74 89 | JMP $8974   |         JMP SNCLR
86F6 |          |             | 
86F6 |          |             | ; -----------------------------------------------------------------------------
86F6 |          |             | ; output two hex digits for byte
86F6 | 8E 05 01 | STX $0105   | WRTWO:  STX SAVX            ; save X
86F9 | 20 06 87 | JSR $8706   |         JSR ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
86FC | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output upper nybble
86FF | 8A       | TXA         |         TXA                 ; transfer lower to A
8700 | AE 05 01 | LDX $0105   |         LDX SAVX            ; restore X
8703 | 4C D2 FF | JMP $FFD2   |         JMP CHROUT          ; output lower nybble
8706 |          |             | 
8706 |          |             | ; -----------------------------------------------------------------------------
8706 |          |             | ; convert byte in A to hex digits
8706 | 48       | PHA         | ASCTWO: PHA                 ; save byte
8707 | 20 10 87 | JSR $8710   |         JSR ASCII           ; do low nybble
870A | AA       | TAX         |         TAX                 ; save in X
870B | 68       | PLA         |         PLA                 ; restore byte
870C | 4A       | LSR A       |         LSR.A               ; shift upper nybble down
870D | 4A       | LSR A       |         LSR.A
870E | 4A       | LSR A       |         LSR.A
870F | 4A       | LSR A       |         LSR.A
8710 |          |             | 
8710 |          |             | ; convert low nybble in A to hex digit
8710 | 29 0F    | AND #$0F    | ASCII:  AND.# $0F            ; clear upper nibble
8712 | C9 0A    | CMP #$0A    |         CMP.# $0A            ; if less than A, skip next step
8714 | 90 02    | BCC $02     |         BCC ASC1
8716 | 69 06    | ADC #$06    |         ADC.# 6              ; skip ascii chars between 9 and A
8718 | 69 30    | ADC #$30    | ASC1:   ADC.# $30            ; add ascii char 0 to value
871A | 60       | RTS         |         RTS
871B |          |             | 
871B |          |             | ; -----------------------------------------------------------------------------
871B |          |             | ; get prev char from input buffer
871B | CE 31 02 | DEC $0231   | GOTCHR: DEC CHRPNT
871E |          |             | 
871E |          |             | ; get next char from input buffer
871E | 8E 05 01 | STX $0105   | GETCHR: STX SAVX
8721 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; get pointer to next char
8724 | BD 00 02 | LDA $0200,X |         LDA,X INBUFF        ; load next char in A
8727 | F0 06    | BEQ $06     |         BEQ NOCHAR          ; null, :, or ? signal end of buffer
8729 | C9 3A    | CMP #$3A    |         CMP.# ':'        
872B | F0 02    | BEQ $02     |         BEQ NOCHAR
872D | C9 3F    | CMP #$3F    |         CMP.# '?'
872F | 08       | PHP         | NOCHAR: PHP
8730 | EE 31 02 | INC $0231   |         INC CHRPNT          ; next char
8733 | AE 05 01 | LDX $0105   |         LDX SAVX
8736 | 28       | PLP         |         PLP                 ; Z flag will signal last character
8737 | 60       | RTS         |         RTS
8738 |          |             | 
8738 |          |             | ; -----------------------------------------------------------------------------
8738 |          |             | ; copy TMP0 to TMP2
8738 | A5 C1    | LDA $C1     | COPY12: LDA.zp TMP0            ; low byte
873A | 85 C3    | STA $C3     |         STA.zp TMP2
873C | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; high byte
873E | 85 C4    | STA $C4     |         STA.zp TMP2+1
8740 | 60       | RTS         |         RTS
8741 |          |             | 
8741 |          |             | ; -----------------------------------------------------------------------------
8741 |          |             | ; subtract TMP2 from TMP0
8741 | 38       | SEC         | SUB12:  SEC
8742 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; subtract low byte
8744 | E5 C3    | SBC $C3     |         SBC.zp TMP2
8746 | 85 C1    | STA $C1     |         STA.zp TMP0
8748 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
874A | E5 C4    | SBC $C4     |         SBC.zp TMP2+1          ; subtract high byte
874C | 85 C2    | STA $C2     |         STA.zp TMP0+1
874E | 60       | RTS         |         RTS
874F |          |             | 
874F |          |             | ; -----------------------------------------------------------------------------
874F |          |             | ; subtract from TMP0
874F | A9 01    | LDA #$01    | SUBA1:  LDA.# 1              ; shortcut to decrement by 1
8751 | 8D 05 01 | STA $0105   | SUBA2:  STA SAVX            ; subtrahend in accumulator
8754 | 38       | SEC         |         SEC
8755 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; minuend in low byte
8757 | ED 05 01 | SBC $0105   |         SBC SAVX
875A | 85 C1    | STA $C1     |         STA.zp TMP0
875C | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; borrow from high byte
875E | E9 00    | SBC #$00    |         SBC.# 0
8760 | 85 C2    | STA $C2     |         STA.zp TMP0+1
8762 | 60       | RTS         |         RTS
8763 |          |             | 
8763 |          |             | ; -----------------------------------------------------------------------------
8763 |          |             | ; subtract 1 from STORE
8763 | 38       | SEC         | SUB13:  SEC
8764 | AD 2F 02 | LDA $022F   |         LDA STORE
8767 | E9 01    | SBC #$01    |         SBC.# 1              ; decrement low byte
8769 | 8D 2F 02 | STA $022F   |         STA STORE
876C | AD 30 02 | LDA $0230   |         LDA STORE+1
876F | E9 00    | SBC #$00    |         SBC.# 0              ; borrow from high byte
8771 | 8D 30 02 | STA $0230   |         STA STORE+1
8774 | 60       | RTS         |         RTS
8775 |          |             | 
8775 |          |             | ; -----------------------------------------------------------------------------
8775 |          |             | ; add to TMP2
8775 | A9 01    | LDA #$01    | ADDA2:  LDA.# 1              ; shortcut to increment by 1
8777 | 18       | CLC         | BUMPAD2: CLC
8778 | 65 C3    | ADC $C3     |         ADC.zp TMP2            ; add value in accumulator to low byte
877A | 85 C3    | STA $C3     |         STA.zp TMP2
877C | 90 02    | BCC $02     |         BCC BUMPEX
877E | E6 C4    | INC $C4     |         INC.zp TMP2+1          ; carry to high byte
8780 | 60       | RTS         | BUMPEX: RTS 
8781 |          |             | 
8781 |          |             | ; -----------------------------------------------------------------------------
8781 |          |             | ; subtract 1 from TMP2
8781 | 38       | SEC         | SUB21:  SEC
8782 | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; decrement low byte
8784 | E9 01    | SBC #$01    |         SBC.# 1
8786 | 85 C3    | STA $C3     |         STA.zp TMP2
8788 | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ; borrow from high byte
878A | E9 00    | SBC #$00    |         SBC.# 0
878C | 85 C4    | STA $C4     |         STA.zp TMP2+1
878E | 60       | RTS         |         RTS
878F |          |             | 
878F |          |             | ; -----------------------------------------------------------------------------
878F |          |             | ; copy TMP0 to PC
878F | B0 0A    | BCS $0A     | COPY1P: BCS CPY1PX          ; do nothing if parameter is empty
8791 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; copy low byte
8793 | A4 C2    | LDY $C2     |         LDY.zp TMP0+1          ; copy high byte
8795 | 8D 29 02 | STA $0229   |         STA PCL
8798 | 8C 28 02 | STY $0228   |         STY PCH
879B | 60       | RTS         | CPY1PX: RTS 
879C |          |             | 
879C |          |             | ; -----------------------------------------------------------------------------
879C |          |             | ; get start/end addresses and calc difference
879C | B0 23    | BCS $23     | GETDIF: BCS GDIFX           ; exit with error if no parameter given
879E | 20 38 87 | JSR $8738   |         JSR COPY12          ; save start address in TMP2
87A1 | 20 FF 85 | JSR $85FF   |         JSR GETPAR          ; get end address in TMP0
87A4 | B0 1B    | BCS $1B     |         BCS GDIFX           ; exit with error if no parameter given
87A6 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; save end address in STASH
87A8 | 8D 0B 01 | STA $010B   |         STA STASH
87AB | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
87AD | 8D 0C 01 | STA $010C   |         STA STASH+1
87B0 | 20 41 87 | JSR $8741   |         JSR SUB12           ; subtract start address from end address
87B3 | A5 C1    | LDA $C1     |         LDA.zp TMP0
87B5 | 8D 2F 02 | STA $022F   |         STA STORE           ; save difference in STORE
87B8 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
87BA | 8D 30 02 | STA $0230   |         STA STORE+1
87BD | 90 02    | BCC $02     |         BCC GDIFX           ; error if start address is after end address
87BF | 18       | CLC         |         CLC                 ; clear carry to indicate success
87C0 | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (SEC)
87C1 | 38       | SEC         | GDIFX:  SEC                 ; set carry to indicate error
87C2 | 60       | RTS         |         RTS
87C3 |          |             | 
87C3 |          |             | ; -----------------------------------------------------------------------------
87C3 |          |             | ; convert base [$+&%]
87C3 | 20 FC 85 | JSR $85FC   | CONVRT: JSR RDPAR           ; read a parameter
87C6 | 20 EB 86 | JSR $86EB   |         JSR FRESH           ; next line and clear
87C9 | A9 24    | LDA #$24    |         LDA.#  $24;'$'            ; output $ sigil for hex
87CB | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
87CE | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load the 16-bit value entered
87D0 | A6 C2    | LDX $C2     |         LDX.zp TMP0+1
87D2 | 20 CC 86 | JSR $86CC   |         JSR WRADDR          ; print it in 4 hex digits
87D5 | 20 EB 86 | JSR $86EB   |         JSR FRESH
87D8 | A9 2B    | LDA #$2B    |         LDA.# '+'            ; output + sigil for decimal
87DA | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
87DD | 20 0E 88 | JSR $880E   |         JSR CVTDEC          ; convert to BCD using hardware mode
87E0 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
87E2 | A2 06    | LDX #$06    |         LDX.# 6              ; max digits + 1
87E4 | A0 03    | LDY #$03    |         LDY.# 3              ; bits per digit - 1
87E6 | 20 48 88 | JSR $8848   |         JSR NMPRNT          ; print result without leading zeros
87E9 | 20 EB 86 | JSR $86EB   |         JSR FRESH           ; next line and clear
87EC | A9 26    | LDA #$26    |         LDA.# $26 ;'&'            ; print & sigil for octal
87EE | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
87F1 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
87F3 | A2 08    | LDX #$08    |         LDX.# 8              ; max digits + 1
87F5 | A0 02    | LDY #$02    |         LDY.# 2              ; bits per digit - 1
87F7 | 20 37 88 | JSR $8837   |         JSR PRINUM          ; output number
87FA | 20 EB 86 | JSR $86EB   |         JSR FRESH           ; next line and clear
87FD | A9 25    | LDA #$25    |         LDA.# '%'            ; print % sigil for binary
87FF | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8802 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
8804 | A2 18    | LDX #$18    |         LDX.# $18            ; max digits + 1
8806 | A0 00    | LDY #$00    |         LDY.# 0              ; bits per digit - 1
8808 | 20 37 88 | JSR $8837   |         JSR PRINUM          ; output number
880B | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to mainloop
880E |          |             | 
880E |          |             | ; -----------------------------------------------------------------------------
880E |          |             | ; convert binary to BCD
880E |          |             | 
880E | 20 38 87 | JSR $8738   | CVTDEC: JSR COPY12          ; copy value from TMP0 to TMP2
8811 | A9 00    | LDA #$00    |         LDA.# 0
8813 | A2 02    | LDX #$02    |         LDX.# 2              ; clear 3 bytes in work buffer
8815 | 9D 0D 01 | STA $010D,X | DECML1: STA,X U0AA0
8818 | CA       | DEX         |         DEX
8819 | 10 FA    | BPL $FA     |         BPL DECML1
881B | A0 10    | LDY #$10    |         LDY.# 16             ; 16 bits in input
881D | 08       | PHP         |         PHP                 ; save status register
881E | 78       | SEI         |         SEI                 ; make sure no interrupts occur with BCD enabled
881F | F8       | SED         |         SED
8820 | 06 C3    | ASL $C3     | DECML2: ASL.zp TMP2            ; rotate bytes out of input low byte
8822 | 26 C4    | ROL $C4     |         ROL.zp TMP2+1          ; .. into high byte and carry bit
8824 | A2 02    | LDX #$02    |         LDX.# 2              ; process 3 bytes
8826 | BD 0D 01 | LDA $010D,X | DECDBL: LDA,X U0AA0         ; load current value of byte
8829 | 7D 0D 01 | ADC $010D,X |         ADC,X U0AA0         ; add it to itself plus the carry bit
882C | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; store it back in the same location
882F | CA       | DEX         |         DEX                 ; decrement byte counter
8830 | 10 F4    | BPL $F4     |         BPL DECDBL          ; loop until all bytes processed
8832 | 88       | DEY         |         DEY                 ; decrement bit counter
8833 | D0 EB    | BNE $EB     |         BNE DECML2          ; loop until all bits processed
8835 | 28       | PLP         |         PLP                 ; restore processor status
8836 | 60       | RTS         |         RTS
8837 |          |             | 
8837 |          |             | ; load the input value and fall through to print it
8837 | 48       | PHA         | PRINUM: PHA                 ; save accumulator
8838 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; copy input low byte to work buffer
883A | 8D 0F 01 | STA $010F   |         STA U0AA0+2
883D | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; copy input high byte to work buffer
883F | 8D 0E 01 | STA $010E   |         STA U0AA0+1
8842 | A9 00    | LDA #$00    |         LDA.# 0              ; clear overflow byte in work buffer
8844 | 8D 0D 01 | STA $010D   |         STA U0AA0
8847 | 68       | PLA         |         PLA                 ; restore accumulator
8848 |          |             | 
8848 |          |             | ; print number in specified base without leading zeros
8848 | 8D 08 01 | STA $0108   | NMPRNT: STA DIGCNT          ; number of digits in accumulator
884B | 8C 0A 01 | STY $010A   |         STY NUMBIT          ; bits per digit passed in Y register
884E | AC 0A 01 | LDY $010A   | DIGOUT: LDY NUMBIT          ; get bits to process
8851 | A9 00    | LDA #$00    |         LDA.# 0              ; clear accumulator
8853 | 0E 0F 01 | ASL $010F   | ROLBIT: ASL U0AA0+2         ; shift bits out of low byte
8856 | 2E 0E 01 | ROL $010E   |         ROL U0AA0+1         ; ... into high byte
8859 | 2E 0D 01 | ROL $010D   |         ROL U0AA0           ; ... into overflow byte
885C | 2A       | ROL A       |         ROL.A               ; ... into accumulator
885D | 88       | DEY         |         DEY                 ; decrement bit counter
885E | 10 F3    | BPL $F3     |         BPL ROLBIT          ; loop until all bits processed
8860 | A8       | TAY         |         TAY                 ; check whether accumulator is 0
8861 | D0 09    | BNE $09     |         BNE NZERO           ; if not, print it
8863 | E0 01    | CPX #$01    |         CPX.# 1              ; have we output the max number of digits?
8865 | F0 05    | BEQ $05     |         BEQ NZERO           ; if not, print it
8867 | AC 08 01 | LDY $0108   |         LDY DIGCNT          ; how many digits have we output?
886A | F0 08    | BEQ $08     |         BEQ ZERSUP          ; skip output if digit is 0
886C | EE 08 01 | INC $0108   | NZERO:  INC DIGCNT          ; increment digit counter
886F | 09 30    | ORA #$30    |         ORA.# $30            ; add numeric value to ascii '0' to get ascii char
8871 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output character
8874 | CA       | DEX         | ZERSUP: DEX                 ; decrement number of leading zeros
8875 | D0 D7    | BNE $D7     |         BNE DIGOUT          ; next digit
8877 | 60       | RTS         |         RTS
8878 |          |             | 
8878 |          |             | ; -----------------------------------------------------------------------------
8878 |          |             | ; disk status/command [@]
8878 | D0 03    | BNE $03     | DSTAT:  BNE CHGDEV          ; if device address was given, use it
887A | A2 08    | LDX #$08    |         LDX.# 8              ; otherwise, default to 8
887C | 2C       |             |         DATA.b $2C           ; absolute BIT opcode consumes next word (LDX TMP0)
887D | A6 C1    | LDX $C1     | CHGDEV: LDX.zp TMP0            ; load device address from parameter
887F | E0 04    | CPX #$04    |         CPX.# 4              ; make sure device address is in range 4-31
8881 | 90 58    | BCC $58     |         BCC IOERR
8883 | E0 20    | CPX #$20    |         CPX.# 32
8885 | B0 54    | BCS $54     |         BCS IOERR
8887 | 86 C1    | STX $C1     |         STX.zp TMP0
8889 | A9 00    | LDA #$00    |         LDA.# 0              ; clear status
888B | 85 90    | STA $90     |         STA.zp SATUS
888D | 85 B7    | STA $B7     |         STA.zp FNLEN           ; empty filename
888F | 20 1E 87 | JSR $871E   |         JSR GETCHR          ; get next character
8892 | F0 24    | BEQ $24     |         BEQ INSTAT1         ; null, display status
8894 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up 1 char
8897 | C9 24    | CMP #$24    |         CMP.#  $24 ;'$'            ; $, display directory
8899 | F0 43    | BEQ $43     |         BEQ DIRECT
889B | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; command specified device to listen
889D | 20 B1 FF | JSR $FFB1   |         JSR LISTEN
88A0 | A9 6F    | LDA #$6F    |         LDA.# $6F            ; secondary address 15 (only low nybble used)
88A2 | 20 93 FF | JSR $FF93   |         JSR SECOND
88A5 |          |             | 
88A5 |          |             | ; send command to device
88A5 | AE 31 02 | LDX $0231   | DCOMD:  LDX CHRPNT          ; get next character from buffer
88A8 | EE 31 02 | INC $0231   |         INC CHRPNT
88AB | BD 00 02 | LDA $0200,X |         LDA,X INBUFF
88AE | F0 05    | BEQ $05     |         BEQ INSTAT          ; break out of loop if it's null
88B0 | 20 A8 FF | JSR $FFA8   |         JSR CIOUT           ; otherwise output it to the serial bus
88B3 | 90 F0    | BCC $F0     |         BCC DCOMD           ; unconditional loop: CIOUT clears carry before RTS
88B5 |          |             | 
88B5 |          |             | ; get device status
88B5 | 20 AE FF | JSR $FFAE   | INSTAT: JSR UNLSN           ; command device to unlisten
88B8 | 20 DD 86 | JSR $86DD   | INSTAT1: JSR CRLF            ; new line
88BB | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load device address
88BD | 20 B4 FF | JSR $FFB4   |         JSR TALK            ; command device to talk
88C0 | A9 6F    | LDA #$6F    |         LDA.# $6F            ; secondary address 15 (only low nybble used)
88C2 | 20 96 FF | JSR $FF96   |         JSR TKSA
88C5 | 20 A5 FF | JSR $FFA5   | RDSTAT: JSR ACPTR           ; read byte from serial bus
88C8 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print it
88CB | C9 0D    | CMP #$0D    |         CMP.# $0D            ; if the byte is CR, exit loop
88CD | F0 06    | BEQ $06     |         BEQ DEXIT
88CF | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
88D1 | 29 BF    | AND #$BF    |         AND.# $BF            ; ignore EOI bit
88D3 | F0 F0    | BEQ $F0     |         BEQ RDSTAT          ; if no errors, read next byte
88D5 | 20 AB FF | JSR $FFAB   | DEXIT:  JSR UNTLK           ; command device to stop talking
88D8 | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to mainloop
88DB | 4C 90 80 | JMP $8090   | IOERR:  JMP ERROR           ; handle error
88DE |          |             | 
88DE |          |             | ; get directory
88DE | A5 C1    | LDA $C1     | DIRECT: LDA.zp TMP0            ; load device address
88E0 | 20 B1 FF | JSR $FFB1   |         JSR LISTEN          ; command device to listen
88E3 | A9 F0    | LDA #$F0    |         LDA.# $F0            ; secondary address 0 (only low nybble used)
88E5 | 20 93 FF | JSR $FF93   |         JSR SECOND
88E8 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; get index of next character
88EB | BD 00 02 | LDA $0200,X | DIR2:   LDA,X INBUFF        ; get next character from buffer
88EE | F0 06    | BEQ $06     |         BEQ DIR3            ; break if it's null
88F0 | 20 A8 FF | JSR $FFA8   |         JSR CIOUT           ; send character to device
88F3 | E8       | INX         |         INX                 ; increment characer index
88F4 | D0 F5    | BNE $F5     |         BNE DIR2            ; loop if it hasn't wrapped to zero
88F6 | 20 AE FF | JSR $FFAE   | DIR3:   JSR UNLSN           ; command device to unlisten
88F9 | 20 DD 86 | JSR $86DD   |         JSR CRLF            ; new line
88FC | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load device address
88FE | 48       | PHA         |         PHA                 ; save on stack
88FF | 20 B4 FF | JSR $FFB4   |         JSR TALK            ; command device to talk
8902 | A9 60    | LDA #$60    |         LDA.# $60            ; secondary address 0 (only low nybble used)
8904 | 20 96 FF | JSR $FF96   |         JSR TKSA
8907 | A0 03    | LDY #$03    |         LDY.# 3              ; read 3 16-bit values from device
8909 | 8C 2F 02 | STY $022F   | DIRLIN: STY STORE           ;   ignore the first 2; 3rd is file size
890C | 20 A5 FF | JSR $FFA5   | DLINK:  JSR ACPTR           ; read low byte from device
890F | 85 C1    | STA $C1     |         STA.zp TMP0            ; store it
8911 | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
8913 | D0 44    | BNE $44     |         BNE DREXIT          ; exit if error or eof occurred
8915 | 20 A5 FF | JSR $FFA5   |         JSR ACPTR           ; read high byte from device
8918 | 85 C2    | STA $C2     |         STA.zp TMP0+1          ; store it
891A | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
891C | D0 3B    | BNE $3B     |         BNE DREXIT          ; exit if error or eof cocurred
891E | CE 2F 02 | DEC $022F   |         DEC STORE           ; decrement byte count
8921 | D0 E9    | BNE $E9     |         BNE DLINK           ; loop if bytes remain
8923 | 20 0E 88 | JSR $880E   |         JSR CVTDEC          ; convert last 16-bit value to decimal
8926 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit count
8928 | A2 06    | LDX #$06    |         LDX.# 6              ; max 6 digits
892A | A0 03    | LDY #$03    |         LDY.# 3              ; 3 bits per digit
892C | 20 48 88 | JSR $8848   |         JSR NMPRNT          ; output number
892F | A9 20    | LDA #$20    |         LDA.# ' '            ; output space
8931 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8934 | 20 A5 FF | JSR $FFA5   | DNAME:  JSR ACPTR           ; get a filename character from the device
8937 | F0 0A    | BEQ $0A     |         BEQ DMORE           ; if it's null, break out of loop
8939 | A6 90    | LDX $90     |         LDX.zp SATUS           ; check for errors or eof
893B | D0 1C    | BNE $1C     |         BNE DREXIT          ; if found exit early
893D | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output character
8940 | 18       | CLC         |         CLC
8941 | 90 F1    | BCC $F1     |         BCC DNAME           ; unconditional branch to read next char
8943 | 20 DD 86 | JSR $86DD   | DMORE:  JSR CRLF
8946 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
8949 | F0 0E    | BEQ $0E     |         BEQ DREXIT          ; exit early if pressed
894B | 20 E4 FF | JSR $FFE4   |         JSR GETIN           ; pause if a key was pressed
894E | F0 05    | BEQ $05     |         BEQ NOPAWS
8950 | 20 E4 FF | JSR $FFE4   | PAWS:   JSR GETIN           ; wait until another key is pressed
8953 | F0 FB    | BEQ $FB     |         BEQ PAWS            
8955 | A0 02    | LDY #$02    | NOPAWS: LDY.# 2
8957 | D0 B0    | BNE $B0     |         BNE DIRLIN          ; unconditional branch to read next file
8959 | 20 AB FF | JSR $FFAB   | DREXIT: JSR UNTLK           ; command device to untalk
895C | 68       | PLA         |         PLA                 ; restore accumulator
895D | 20 B1 FF | JSR $FFB1   |         JSR LISTEN          ; command device to listen
8960 | A9 E0    | LDA #$E0    |         LDA.# $E0            ; secondary address 0 (only low nybble is used)
8962 | 20 93 FF | JSR $FF93   |         JSR SECOND
8965 | 20 AE FF | JSR $FFAE   |         JSR UNLSN           ; command device to unlisten
8968 | 4C 61 80 | JMP $8061   |         JMP STRT            ; back to mainloop
896B |          |             | 
896B |          |             | ; -----------------------------------------------------------------------------
896B |          |             | ; print and clear routines
896B | 20 DD 86 | JSR $86DD   | CLINE:  JSR CRLF            ; send CR+LF
896E | 4C 74 89 | JMP $8974   |         JMP SNCLR           ; clear line
8971 | 20 84 89 | JSR $8984   | SNDCLR: JSR SNDMSG
8974 | A0 28    | LDY #$28    | SNCLR:  LDY.# $28            ; loop 40 times
8976 | A9 20    | LDA #$20    | SNCLP:  LDA.# $20            ; output space character
8978 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
897B | A9 14    | LDA #$14    |         LDA.# $14            ; output delete character
897D | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
8980 | 88       | DEY         |         DEY
8981 | D0 F3    | BNE $F3     |         BNE SNCLP
8983 | 60       | RTS         |         RTS
8984 |          |             | 
8984 |          |             | ; -----------------------------------------------------------------------------
8984 |          |             | ; display message from table
8984 | B9 92 89 | LDA $8992,Y | SNDMSG: LDA,Y MSGBAS        ; Y contains offset in msg table
8987 | 08       | PHP         |         PHP
8988 | 29 7F    | AND #$7F    |         AND.# $7F            ; strip high bit before output
898A | 20 D9 86 | JSR $86D9   |         JSR CHOUT
898D | C8       | INY         |         INY
898E | 28       | PLP         |         PLP
898F | 10 F3    | BPL $F3     |         BPL SNDMSG          ; loop until high bit is set
8991 | 60       | RTS         |         RTS
8992 |          |             | 
8992 |          |             | ; -----------------------------------------------------------------------------
8992 |          |             | ; message table; last character has high bit set
8992 |          |             | MSGBAS:
8992 | 0D       |             | MSG2:   DATA.b $0D               ; header for registers
8993 |          |             |         ;.TEXT "   PC  SR AC XR YR SP   V1.2"
8993 | 20       |             |         DATA.b ' '
8994 | 20       |             |         DATA.b ' '
8995 | 20       |             |         DATA.b ' '
8996 | 50       |             |         DATA.b 'P'
8997 | 43       |             |         DATA.b 'C'
8998 | 20       |             |         DATA.b ' '
8999 | 20       |             |         DATA.b ' '
899A | 53       |             |         DATA.b 'S'
899B | 52       |             |         DATA.b 'R'
899C | 20       |             |         DATA.b ' '
899D | 41       |             |         DATA.b 'A'
899E | 43       |             |         DATA.b 'C'
899F | 20       |             |         DATA.b ' '
89A0 | 58       |             |         DATA.b 'X'
89A1 | 52       |             |         DATA.b 'R'
89A2 | 20       |             |         DATA.b ' '
89A3 | 59       |             |         DATA.b 'Y'
89A4 | 52       |             |         DATA.b 'R'
89A5 | 20       |             |         DATA.b ' '
89A6 | 53       |             |         DATA.b 'S'
89A7 | 50       |             |         DATA.b 'P'
89A8 | 20       |             |         DATA.b ' '
89A9 | 20       |             |         DATA.b ' '
89AA | 20       |             |         DATA.b ' '
89AB | 56       |             |         DATA.b 'V'
89AC | 31       |             |         DATA.b '1'
89AD | 2E       |             |         DATA.b '.'
89AE | 32       |             |         DATA.b '2'
89AF | 8D       |             |         DATA.b $0D+$80
89B0 |          |             | 
89B0 | 1D       |             | MSG3:   DATA.b $1D
89B1 | BF       |             |         DATA.b $3F+$80       ; syntax error: move right, display "?"
89B2 |          |             | 
89B2 |          |             | MSG4:   ;.TEXT "..SYS"           ; SYS call to enter monitor
89B2 | 2E       |             |         DATA.b '.'
89B3 | 2E       |             |         DATA.b '.'
89B4 | 53       |             |         DATA.b 'S'
89B5 | 59       |             |         DATA.b 'Y'
89B6 | 53       |             |         DATA.b 'S'
89B7 |          |             | 
89B7 | A0       |             |         DATA.b $20+$80
89B8 |          |             | 
89B8 | 3A       |             | MSG5:   DATA.b $3A
89B9 | 92       |             |         DATA.b $12+$80       ; ":" then RVS ON for memory ASCII dump
89BA |          |             | 
89BA |          |             | MSG6:   ;.TEXT " ERRO"           ; I/O error: display " ERROR"
89BA | 20       |             |         DATA.b ' '
89BB | 45       |             |         DATA.b 'E'
89BC | 52       |             |         DATA.b 'R'
89BD | 52       |             |         DATA.b 'R'
89BE | 4F       |             |         DATA.b 'O'
89BF | D2       |             |         DATA.b 'R'+$80
89C0 |          |             | 
89C0 | 41       |             | MSG7:   DATA.b $41
89C1 | A0       |             |         DATA.b $20+$80       ; assemble next instruction: "A " + addr
89C2 |          |             | 
89C2 |          |             | MSG8:   ; .TEXT "  "              ; pad non-existent byte: skip 3 spaces
89C2 | 20       |             |         DATA.b ' '
89C3 | 20       |             |         DATA.b ' '
89C4 | A0       |             |         DATA.b $20+$80
89C5 |          |             | 
89C5 |          |             | 
89C5 |          |             | ; -----------------------------------------------------------------------------
89C5 |          |             | ; addressing mode table - nybbles provide index into MODE2 table
89C5 |          |             | ; for opcodes XXXXXXY0, use XXXXXX as index into table
89C5 |          |             | ; for opcodes WWWXXY01  use $40 + XX as index into table
89C5 |          |             | ; use right nybble if Y=0; use left nybble if Y=1
89C5 |          |             | 
89C5 | 40       |             | MODE:   DATA.b $40
89C6 | 02       |             |         DATA.b $02
89C7 | 45       |             |         DATA.b $45
89C8 | 03       |             |         DATA.b $03   ; even opcodes
89C9 | D0       |             |         DATA.b $D0
89CA | 08       |             |         DATA.b $08
89CB | 40       |             |         DATA.b $40
89CC | 09       |             |         DATA.b $09
89CD | 30       |             |         DATA.b $30
89CE | 22       |             |         DATA.b $22
89CF | 45       |             |         DATA.b $45
89D0 | 33       |             |         DATA.b $33
89D1 | D0       |             |         DATA.b $D0
89D2 | 08       |             |         DATA.b $08
89D3 | 40       |             |         DATA.b $40
89D4 | 09       |             |         DATA.b $09
89D5 | 40       |             |         DATA.b $40
89D6 | 02       |             |         DATA.b $02
89D7 | 45       |             |         DATA.b $45
89D8 | 33       |             |         DATA.b $33
89D9 | D0       |             |         DATA.b $D0
89DA | 08       |             |         DATA.b $08
89DB | 40       |             |         DATA.b $40
89DC | 09       |             |         DATA.b $09
89DD | 40       |             |         DATA.b $40
89DE | 02       |             |         DATA.b $02
89DF | 45       |             |         DATA.b $45
89E0 | B3       |             |         DATA.b $B3
89E1 | D0       |             |         DATA.b $D0
89E2 | 08       |             |         DATA.b $08
89E3 | 40       |             |         DATA.b $40
89E4 | 09       |             |         DATA.b $09
89E5 | 00       |             |         DATA.b $00
89E6 | 22       |             |         DATA.b $22
89E7 | 44       |             |         DATA.b $44
89E8 | 33       |             |         DATA.b $33
89E9 | D0       |             |         DATA.b $D0
89EA | 8C       |             |         DATA.b $8C
89EB | 44       |             |         DATA.b $44
89EC | 00       |             |         DATA.b $00
89ED | 11       |             |         DATA.b $11
89EE | 22       |             |         DATA.b $22
89EF | 44       |             |         DATA.b $44
89F0 | 33       |             |         DATA.b $33
89F1 | D0       |             |         DATA.b $D0
89F2 | 8C       |             |         DATA.b $8C
89F3 | 44       |             |         DATA.b $44
89F4 | 9A       |             |         DATA.b $9A
89F5 | 10       |             |         DATA.b $10
89F6 | 22       |             |         DATA.b $22
89F7 | 44       |             |         DATA.b $44
89F8 | 33       |             |         DATA.b $33
89F9 | D0       |             |         DATA.b $D0
89FA | 08       |             |         DATA.b $08
89FB | 40       |             |         DATA.b $40
89FC | 09       |             |         DATA.b $09
89FD | 10       |             |         DATA.b $10
89FE | 22       |             |         DATA.b $22
89FF | 44       |             |         DATA.b $44
8A00 | 33       |             |         DATA.b $33
8A01 | D0       |             |         DATA.b $D0
8A02 | 08       |             |         DATA.b $08
8A03 | 40       |             |         DATA.b $40
8A04 | 09       |             |         DATA.b $09
8A05 | 62       |             |         DATA.b $62
8A06 | 13       |             |         DATA.b $13
8A07 | 78       |             |         DATA.b $78
8A08 | A9       |             |         DATA.b $A9   ; opcodes ending in 01
8A09 |          |             | 
8A09 |          |             | ; addressing mode format definitions indexed by nybbles from MODE table
8A09 |          |             | 
8A09 |          |             | ; left 6 bits define which characters appear in the assembly operand
8A09 |          |             | ; left 3 bits are before the address; next 3 bits are after
8A09 |          |             | 
8A09 |          |             | ; right-most 2 bits define length of binary operand
8A09 |          |             | 
8A09 |          |             | ; index               654 321
8A09 |          |             | ; 1st character       $(# ,),  
8A09 |          |             | ; 2nd character        $$ X Y    length  format      idx mode
8A09 | 00       |             | MODE2:  DATA.b $00   ; 000 000    00                  0   error
8A0A | 21       |             |         DATA.b $21   ; 001 000    01      #$00        1   immediate
8A0B | 81       |             |         DATA.b $81   ; 100 000    01      $00         2   zero-page
8A0C | 82       |             |         DATA.b $82   ; 100 000    10      $0000       3   absolute
8A0D | 00       |             |         DATA.b $00   ; 000 000    00                  4   implied
8A0E | 00       |             |         DATA.b $00   ; 000 000    00                  5   accumulator
8A0F | 59       |             |         DATA.b $59   ; 010 110    01      ($00,X)     6   indirect,X
8A10 | 4D       |             |         DATA.b $4D   ; 010 011    01      ($00),Y     7   indirect,Y
8A11 | 91       |             |         DATA.b $91   ; 100 100    01      $00,X       8   zero-page,X
8A12 | 92       |             |         DATA.b $92   ; 100 100    10      $0000,X     9   absolute,X
8A13 | 86       |             |         DATA.b $86   ; 100 001    10      $0000,Y     A   absolute,Y
8A14 | 4A       |             |         DATA.b $4A   ; 010 010    10      ($0000)     B   indirect
8A15 | 85       |             |         DATA.b $85   ; 100 001    01      $00,Y       C   zero-page,Y
8A16 | 9D       |             |         DATA.b $9D   ; 100 111    01      $0000*      D   relative
8A17 |          |             | 
8A17 |          |             | ; * relative is special-cased so format bits don't match
8A17 |          |             | 
8A17 |          |             | 
8A17 |          |             | ; character lookup tables for the format definitions in MODE2
8A17 |          |             | 
8A17 | 2C       |             | CHAR1:  DATA.b $2C
8A18 | 29       |             |         DATA.b $29
8A19 | 2C       |             |         DATA.b $2C       ; ","  ")"  ","
8A1A | 23       |             |         DATA.b $23
8A1B | 28       |             |         DATA.b $28
8A1C | 24       |             |         DATA.b $24       ; "#"  "("  "$"
8A1D |          |             | 
8A1D | 59       |             | CHAR2:  DATA.b $59
8A1E | 00       |             |         DATA.b $00
8A1F | 58       |             |         DATA.b $58       ; "Y"   0   "X"
8A20 | 24       |             |         DATA.b $24
8A21 | 24       |             |         DATA.b $24
8A22 | 00       |             |         DATA.b $00       ; "$"  "$"   0
8A23 |          |             | 
8A23 |          |             | ; -----------------------------------------------------------------------------
8A23 |          |             | ; 3-letter mnemonics packed into two bytes (5 bits per letter)
8A23 |          |             | 
8A23 |          |             |         ; left 8 bits
8A23 |          |             |         ; XXXXX000 opcodes
8A23 | 1C       |             | MNEML:  DATA.b $1C
8A24 | 8A       |             |         DATA.b $8A
8A25 | 1C       |             |         DATA.b $1C
8A26 | 23       |             |         DATA.b $23   ; BRK PHP BPL CLC
8A27 | 5D       |             |         DATA.b $5D
8A28 | 8B       |             |         DATA.b $8B
8A29 | 1B       |             |         DATA.b $1B
8A2A | A1       |             |         DATA.b $A1   ; JSR PLP BMI SEC
8A2B | 9D       |             |         DATA.b $9D
8A2C | 8A       |             |         DATA.b $8A
8A2D | 1D       |             |         DATA.b $1D
8A2E | 23       |             |         DATA.b $23   ; RTI PHA BVC CLI
8A2F | 9D       |             |         DATA.b $9D
8A30 | 8B       |             |         DATA.b $8B
8A31 | 1D       |             |         DATA.b $1D
8A32 | A1       |             |         DATA.b $A1   ; RTS PLA BVS SEI
8A33 | 00       |             |         DATA.b $00
8A34 | 29       |             |         DATA.b $29
8A35 | 19       |             |         DATA.b $19
8A36 | AE       |             |         DATA.b $AE   ; ??? DEY BCC TYA
8A37 | 69       |             |         DATA.b $69
8A38 | A8       |             |         DATA.b $A8
8A39 | 19       |             |         DATA.b $19
8A3A | 23       |             |         DATA.b $23   ; LDY TAY BCS CLV
8A3B | 24       |             |         DATA.b $24
8A3C | 53       |             |         DATA.b $53
8A3D | 1B       |             |         DATA.b $1B
8A3E | 23       |             |         DATA.b $23   ; CPY INY BNE CLD
8A3F | 24       |             |         DATA.b $24
8A40 | 53       |             |         DATA.b $53
8A41 | 19       |             |         DATA.b $19
8A42 | A1       |             |         DATA.b $A1   ; CPX INX BEQ SED
8A43 |          |             |         ; XXXYY100 opcodes
8A43 | 00       |             |         DATA.b $00
8A44 | 1A       |             |         DATA.b $1A
8A45 | 5B       |             |         DATA.b $5B
8A46 | 5B       |             |         DATA.b $5B   ; ??? BIT JMP JMP
8A47 | A5       |             |         DATA.b $A5
8A48 | 69       |             |         DATA.b $69
8A49 | 24       |             |         DATA.b $24
8A4A | 24       |             |         DATA.b $24   ; STY LDY CPY CPX
8A4B |          |             |         ; 1XXX1010 opcodes
8A4B | AE       |             |         DATA.b $AE
8A4C | AE       |             |         DATA.b $AE
8A4D | A8       |             |         DATA.b $A8
8A4E | AD       |             |         DATA.b $AD   ; TXA TXS TAX TSX
8A4F | 29       |             |         DATA.b $29
8A50 | 00       |             |         DATA.b $00
8A51 | 7C       |             |         DATA.b $7C
8A52 | 00       |             |         DATA.b $00   ; DEX ??? NOP ???
8A53 |          |             |         ; XXXYYY10 opcodes
8A53 | 15       |             |         DATA.b $15
8A54 | 9C       |             |         DATA.b $9C
8A55 | 6D       |             |         DATA.b $6D
8A56 | 9C       |             |         DATA.b $9C   ; ASL ROL LSR ROR
8A57 | A5       |             |         DATA.b $A5
8A58 | 69       |             |         DATA.b $69
8A59 | 29       |             |         DATA.b $29
8A5A | 53       |             |         DATA.b $53   ; STX LDX DEC INC
8A5B |          |             |         ; XXXYYY01 opcodes
8A5B | 84       |             |         DATA.b $84
8A5C | 13       |             |         DATA.b $13
8A5D | 34       |             |         DATA.b $34
8A5E | 11       |             |         DATA.b $11   ; ORA AND EOR ADC
8A5F | A5       |             |         DATA.b $A5
8A60 | 69       |             |         DATA.b $69
8A61 | 23       |             |         DATA.b $23
8A62 | A0       |             |         DATA.b $A0   ; STA LDA CMP SBC
8A63 |          |             | 
8A63 |          |             |         ; right 7 bits, left justified
8A63 |          |             |         ; XXXXX000 opcodes
8A63 | D8       |             | MNEMR:  DATA.b $D8
8A64 | 62       |             |         DATA.b $62
8A65 | 5A       |             |         DATA.b $5A
8A66 | 48       |             |         DATA.b $48   ; BRK PHP BPL CLC
8A67 | 26       |             |         DATA.b $26
8A68 | 62       |             |         DATA.b $62
8A69 | 94       |             |         DATA.b $94
8A6A | 88       |             |         DATA.b $88   ; JSR PLP BMI SEC
8A6B | 54       |             |         DATA.b $54
8A6C | 44       |             |         DATA.b $44
8A6D | C8       |             |         DATA.b $C8
8A6E | 54       |             |         DATA.b $54   ; RTI PHA BVC CLI
8A6F | 68       |             |         DATA.b $68
8A70 | 44       |             |         DATA.b $44
8A71 | E8       |             |         DATA.b $E8
8A72 | 94       |             |         DATA.b $94   ; RTS PLA BVS SEI
8A73 | 00       |             |         DATA.b $00
8A74 | B4       |             |         DATA.b $B4
8A75 | 08       |             |         DATA.b $08
8A76 | 84       |             |         DATA.b $84   ; ??? DEY BCC TYA
8A77 | 74       |             |         DATA.b $74
8A78 | B4       |             |         DATA.b $B4
8A79 | 28       |             |         DATA.b $28
8A7A | 6E       |             |         DATA.b $6E   ; LDY TAY BCS CLV
8A7B | 74       |             |         DATA.b $74
8A7C | F4       |             |         DATA.b $F4
8A7D | CC       |             |         DATA.b $CC
8A7E | 4A       |             |         DATA.b $4A   ; CPY INY BNE CLD
8A7F | 72       |             |         DATA.b $72
8A80 | F2       |             |         DATA.b $F2
8A81 | A4       |             |         DATA.b $A4
8A82 | 8A       |             |         DATA.b $8A   ; CPX INX BEQ SED
8A83 |          |             |         ; XXXYY100 opcodes
8A83 | 00       |             |         DATA.b $00
8A84 | AA       |             |         DATA.b $AA
8A85 | A2       |             |         DATA.b $A2
8A86 | A2       |             |         DATA.b $A2   ; ??? BIT JMP JMP
8A87 | 74       |             |         DATA.b $74
8A88 | 74       |             |         DATA.b $74
8A89 | 74       |             |         DATA.b $74
8A8A | 72       |             |         DATA.b $72   ; STY LDY CPY CPX
8A8B |          |             |         ; 1XXX1010 opcodes
8A8B | 44       |             |         DATA.b $44
8A8C | 68       |             |         DATA.b $68
8A8D | B2       |             |         DATA.b $B2
8A8E | 32       |             |         DATA.b $32   ; TXA TXS TAX TSX
8A8F | B2       |             |         DATA.b $B2
8A90 | 00       |             |         DATA.b $00
8A91 | 22       |             |         DATA.b $22
8A92 | 00       |             |         DATA.b $00   ; DEX ??? NOP ???
8A93 |          |             |         ; XXXYYY10 opcodes
8A93 | 1A       |             |         DATA.b $1A
8A94 | 1A       |             |         DATA.b $1A
8A95 | 26       |             |         DATA.b $26
8A96 | 26       |             |         DATA.b $26   ; ASL ROL LSR ROR
8A97 | 72       |             |         DATA.b $72
8A98 | 72       |             |         DATA.b $72
8A99 | 88       |             |         DATA.b $88
8A9A | C8       |             |         DATA.b $C8   ; STX LDX DEC INC
8A9B |          |             |         ; XXXYYY01 opcodes
8A9B | C4       |             |         DATA.b $C4
8A9C | CA       |             |         DATA.b $CA
8A9D | 26       |             |         DATA.b $26
8A9E | 48       |             |         DATA.b $48   ; ORA AND EOR ADC
8A9F | 44       |             |         DATA.b $44
8AA0 | 44       |             |         DATA.b $44
8AA1 | A2       |             |         DATA.b $A2
8AA2 | C8       |             |         DATA.b $C8   ; STA LDA CMP SBC
8AA3 | 0D       |             |         DATA.b $0D
8AA4 | 20       |             |         DATA.b $20
8AA5 | 20       |             |         DATA.b $20
8AA6 | 20       |             |         DATA.b $20
8AA7 |          |             | 
8AA7 |          |             | ; -----------------------------------------------------------------------------
8AA7 |          |             | ; single-character commands
8AA7 |          |             | KEYW:    ;.TEXT "ACDFGHJMRTX@.>;"
8AA7 | 41       |             |         DATA.b 'A'
8AA8 | 43       |             |         DATA.b 'C'
8AA9 | 44       |             |         DATA.b 'D'
8AAA | 46       |             |         DATA.b 'F'
8AAB | 47       |             |         DATA.b 'G'
8AAC | 48       |             |         DATA.b 'H'
8AAD | 4A       |             |         DATA.b 'J'
8AAE | 4D       |             |         DATA.b 'M'
8AAF | 52       |             |         DATA.b 'R'
8AB0 | 54       |             |         DATA.b 'T'
8AB1 | 58       |             |         DATA.b 'X'
8AB2 | 40       |             |         DATA.b '@'
8AB3 | 2E       |             |         DATA.b '.'
8AB4 | 3E       |             |         DATA.b '>'
8AB5 | 3B       |             |         DATA.b $3b      ; ;
8AB6 |          |             | 
8AB6 |          |             | HIKEY:  ; .TEXT "$+&%LSV"
8AB6 | 24       |             |         DATA.b $24      ; $
8AB7 | 2B       |             |         DATA.b '+'
8AB8 | 26       |             |         DATA.b $26      ; &
8AB9 | 25       |             |         DATA.b '%'
8ABA | 4C       |             |         DATA.b 'L'
8ABB | 53       |             |         DATA.b 'S'
8ABC | 56       |             |         DATA.b 'V'
8ABD |          |             | 
8ABD |          |             | KEYTOP:
8ABD |          |             | 
8ABD |          |             | ; vectors corresponding to commands above
8ABD | 43 83    |             | KADDR:  DATA ASSEM-1
8ABF | 9B 81    |             |         DATA COMPAR-1
8AC1 | D0 84    |             |         DATA DISASS-1
8AC3 | 1E 83    |             |         DATA FILL-1
8AC5 |          |             | 
8AC5 | 26 81    |             |         DATA GOTO-1
8AC7 | 1F 82    |             |         DATA HUNT-1
8AC9 | 44 81    |             |         DATA JSUB-1
8ACB | B9 80    |             |         DATA DSPLYM-1
8ACD |          |             | 
8ACD | 3E 80    |             |         DATA DSPLYR-1
8ACF | 9E 81    |             |         DATA TRANS-1
8AD1 | B6 80    |             |         DATA EXIT-1
8AD3 | 77 88    |             |         DATA DSTAT-1
8AD5 |          |             | 
8AD5 | 43 83    |             |         DATA ASSEM-1
8AD7 | 06 81    |             |         DATA ALTM-1
8AD9 | EF 80    |             |         DATA ALTR-1
8ADB |          |             | 
8ADB |          |             | ; -----------------------------------------------------------------------------
8ADB | 10       |             | MODTAB: DATA.b $10
8ADC | 0A       |             |         DATA.b $0A
8ADD | 08       |             |         DATA.b $08
8ADE | 02       |             |         DATA.b 02    ; modulo number systems
8ADF | 04       |             | LENTAB: DATA.b $04
8AE0 | 03       |             |         DATA.b $03
8AE1 | 03       |             |         DATA.b $03
8AE2 | 01       |             |         DATA.b $01   ; bits per digit
8AE3 |          |             | 
8AE3 | 30 80    |             | LINKAD: DATA BREAK             ; address of brk handler
8AE5 | 00 80    |             | SUPAD:  DATA SUPER             ; address of entry point
8AE7 |          |             | 
8AE7 |          |             | ; Ending Including 'pssupermon64.asm'
