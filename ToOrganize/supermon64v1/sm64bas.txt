0000 |          |             | 
0801 |          |             | * = $0801
0801 |          |             | 
0801 | 0B 08    |             |             DATA        $080B    ; Basic Stub
0803 | 0A 00    |             |             DATA        $000A    ; 10 SYS2061
0805 | 9E       |             |             DATA.B      $9E
0806 | 32       |             |             DATA.B      $32
0807 | 30       |             |             DATA.B      $30
0808 | 36       |             |             DATA.B      $36
0809 | 31       |             |             DATA.B      $31
080A | 00       |             |             DATA.B      $00
080B | 00 00    |             |             DATA        $0000
080D |          |             | 
080D |          |             | ORG:
080D |          |             | 
080D |          |             |             #INCLUDE Supermon64v1.asm
080D |          |             | ; Start Including 'Supermon64v1.asm'
080D |          |             | ; -----------------------------------------------------------------------------
080D |          |             | ; temporary pointers
080D |          |             | TMP0    = $C1               ; used to return input, often holds end address
080D |          |             | TMP2    = $C3               ; usually holds start address
080D |          |             | 
080D |          |             | ; -----------------------------------------------------------------------------
080D |          |             | ; kernal variables
080D |          |             | SATUS   = $90               ; kernal i/o status word
080D |          |             | FNLEN   = $B7               ; length of current filename
080D |          |             | SADD    = $B9               ; current secondary address (official name SA)
080D |          |             | FA      = $BA               ; current device number
080D |          |             | FNADR   = $BB               ; pointer to current filename
080D |          |             | NDX     = $C6               ; number of characters in keyboard buffer
080D |          |             | KEYD    = $0277             ; keyboard buffer
080D |          |             | BKVEC   = $0316             ; BRK instruction vector (official name CBINV)
080D |          |             | 
0100 |          |             |         *= $0100            ; store variables in tape error buffer
0100 |          |             | 
0100 |          |             | ; -----------------------------------------------------------------------------
0100 |          |             | ; variables
0100 |          |             | ACMD:    FILL 1             ; addressing command
0101 |          |             | LENGTH:  FILL 1             ; length of operand
0102 |          |             | MNEMW:   FILL 3             ; 3 letter mnemonic buffer
0105 |          |             | SAVX:    FILL 1             ; 1 byte temp storage, often to save X register
0106 |          |             | OPCODE:  FILL 1             ; current opcode for assembler/disassembler
0107 |          |             | UPFLG:   FILL 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
0108 |          |             | DIGCNT:  FILL 1             ; digit count
0109 |          |             | INDIG:   FILL 1             ; numeric value of single digit
010A |          |             | NUMBIT:  FILL 1             ; numeric base of input
010B |          |             | STASH:   FILL 2             ; 2-byte temp storage
010D |          |             | U0AA0:   FILL 10            ; work buffer
0117 |          |             | U0AAE:                     ; end of work buffer
0117 |          |             | STAGE:   FILL 30            ; staging buffer for filename, search, etc.
0135 |          |             | ESTAGE:                    ; end of staging buffer
0135 |          |             | 
0200 |          |             |         *= $0200            ; store more variables in basic line editor buffer
0200 |          |             | 
0200 |          |             | INBUFF:  FILL 40            ; 40-character input buffer
0228 |          |             | ENDIN:                     ; end of input buffer
0228 |          |             | 
0228 |          |             | ; the next 7 locations are used to store the registers when
0228 |          |             | ; entering the monitor and restore them when exiting.
0228 |          |             | 
0228 |          |             | PCH:     FILL 1             ; program counter high byte
0229 |          |             | PCL:     FILL 1             ; program counter low byte
022A |          |             | SR:      FILL 1             ; status register
022B |          |             | ACC:     FILL 1             ; accumulator
022C |          |             | XR:      FILL 1             ; X register
022D |          |             | YR:      FILL 1             ; Y register
022E |          |             | SP:      FILL 1             ; stack pointer
022F |          |             | 
022F |          |             | STORE:   FILL 2             ; 2-byte temp storage
0231 |          |             | CHRPNT:  FILL 1             ; current position in input buffer
0232 |          |             | SAVY:    FILL 1             ; temp storage, often to save Y register
0233 |          |             | U9F:     FILL 1             ; index into assembler work buffer
0234 |          |             | 
0234 |          |             | ; -----------------------------------------------------------------------------
0234 |          |             | ; kernal entry points
0234 |          |             | SETMSG  = $FF90             ; set kernel message control flag
0234 |          |             | SECOND  = $FF93             ; set secondary address after LISTEN
0234 |          |             | TKSA    = $FF96             ; send secondary address after TALK
0234 |          |             | LISTEN  = $FFB1             ; command serial bus device to LISTEN
0234 |          |             | TALK    = $FFB4             ; command serial bus device to TALK
0234 |          |             | SETLFS  = $FFBA             ; set logical file parameters
0234 |          |             | SETNAM  = $FFBD             ; set filename
0234 |          |             | ACPTR   = $FFA5             ; input byte from serial bus
0234 |          |             | CIOUT   = $FFA8             ; output byte to serial bus
0234 |          |             | UNTLK   = $FFAB             ; command serial bus device to UNTALK
0234 |          |             | UNLSN   = $FFAE             ; command serial bus device to UNLISTEN
0234 |          |             | CHKIN   = $FFC6             ; define input channel
0234 |          |             | CLRCHN  = $FFCC             ; restore default devices
0234 |          |             | INPUT   = $FFCF             ; input a character (official name CHRIN)
0234 |          |             | CHROUT  = $FFD2             ; output a character
0234 |          |             | LOAD    = $FFD5             ; load from device
0234 |          |             | SAVE    = $FFD8             ; save to device
0234 |          |             | STOP    = $FFE1             ; check the STOP key
0234 |          |             | GETIN   = $FFE4             ; get a character
0234 |          |             | 
0234 |          |             | ; -----------------------------------------------------------------------------
0234 |          |             | ; set up origin
0234 |          |             | 
080D |          |             | *       = ORG
080D |          |             | 
080D |          |             | ; -----------------------------------------------------------------------------
080D |          |             | ; initial entry point
080D | A0 20    | LDY #$20    | SUPER:  LDY.# MSG4-MSGBAS    ; display "..SYS "
080F | 20 91 11 | JSR $1191   |         JSR SNDMSG
0812 | AD F2 12 | LDA $12F2   |         LDA SUPAD           ; store entry point address in tmp0
0815 | 85 C1    | STA $C1     |         STA.zp TMP0
0817 | AD F3 12 | LDA $12F3   |         LDA SUPAD+1
081A | 85 C2    | STA $C2     |         STA.zp TMP0+1
081C | 20 1B 10 | JSR $101B   |         JSR CVTDEC          ; convert address to decimal
081F | A9 00    | LDA #$00    |         LDA.# 0
0821 | A2 06    | LDX #$06    |         LDX.# 6
0823 | A0 03    | LDY #$03    |         LDY.# 3
0825 | 20 55 10 | JSR $1055   |         JSR NMPRNT          ; print entry point address
0828 | 20 EA 0E | JSR $0EEA   |         JSR CRLF
082B | AD F0 12 | LDA $12F0   |         LDA LINKAD          ; set BRK vector
082E | 8D 16 03 | STA $0316   |         STA BKVEC
0831 | AD F1 12 | LDA $12F1   |         LDA LINKAD+1
0834 | 8D 17 03 | STA $0317   |         STA BKVEC+1
0837 | A9 80    | LDA #$80    |         LDA.# $80            ; disable kernel control messages
0839 | 20 90 FF | JSR $FF90   |         JSR SETMSG          ; and enable error messages
083C | 00       | BRK         |         BRK
083D |          |             | 
083D |          |             | ; -----------------------------------------------------------------------------
083D |          |             | ; BRK handler
083D | A2 05    | LDX #$05    | BREAK:  LDX.# $05            ; pull registers off the stack
083F | 68       | PLA         | BSTACK: PLA                 ; order: Y,X,A,SR,PCL,PCH
0840 | 9D 28 02 | STA $0228,X |         STA,X PCH           ; store in memory
0843 | CA       | DEX         |         DEX 
0844 | 10 F9    | BPL $F9     |         BPL BSTACK
0846 | D8       | CLD         |         CLD                 ; disable bcd mode
0847 | BA       | TSX         |         TSX                 ; store stack pointer in memory 
0848 | 8E 2E 02 | STX $022E   |         STX SP
084B | 58       | CLI         |         CLI                 ; enable interupts
084C |          |             | 
084C |          |             | ; -----------------------------------------------------------------------------
084C |          |             | ; display registers [R]
084C | A0 00    | LDY #$00    | DSPLYR:  LDY.# MSG2-MSGBAS    ; display headers
084E | 20 7E 11 | JSR $117E   |         JSR SNDCLR
0851 | A9 3B    | LDA #$3B    |         LDA.# $3B            ; prefix registers with "; " to allow editing
0853 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0856 | A9 20    | LDA #$20    |         LDA.# $20
0858 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
085B | AD 28 02 | LDA $0228   |         LDA PCH             ; print 2-byte program counter
085E | 20 03 0F | JSR $0F03   |         JSR WRTWO
0861 | A0 01    | LDY #$01    |         LDY.# 1              ; start 1 byte after PC high byte
0863 | B9 28 02 | LDA $0228,Y | DISJ:    LDA,Y PCH           ; loop through rest of the registers
0866 | 20 DF 0E | JSR $0EDF   |         JSR WRBYTE          ; print 1-byte register value
0869 | C8       | INY         |         INY 
086A | C0 07    | CPY #$07    |         CPY.# 7              ; there are a total of 5 registers to print
086C | 90 F5    | BCC $F5     |         BCC DISJ
086E |          |             | 
086E |          |             | ; -----------------------------------------------------------------------------
086E |          |             | ; main loop
086E | 20 EA 0E | JSR $0EEA   | STRT:    JSR CRLF            ; new line
0871 | A2 00    | LDX #$00    |         LDX.# 0              ; point at start of input buffer
0873 | 8E 31 02 | STX $0231   |         STX CHRPNT 
0876 | 20 CF FF | JSR $FFCF   | SMOVE:   JSR INPUT           ; CHRIN kernal call to input a character
0879 | 9D 00 02 | STA $0200,X |         STA,X INBUFF        ; store in input buffer
087C | E8       | INX         |         INX 
087D | E0 28    | CPX #$28    |         CPX.# ENDIN-INBUFF   ; error if buffer is full
087F | B0 1C    | BCS $1C     |         BCS ERROR
0881 | C9 0D    | CMP #$0D    |         CMP.# $0D            ; keep reading until CR
0883 | D0 F1    | BNE $F1     |         BNE SMOVE
0885 | A9 00    | LDA #$00    |         LDA.# 0              ; null-terminate input buffer
0887 | 9D FF 01 | STA $01FF,X |         STA,X INBUFF-1      ; (replacing the CR)
088A | 20 2B 0F | JSR $0F2B   | ST1:     JSR GETCHR          ; get a character from the buffer
088D | F0 DF    | BEQ $DF     |         BEQ STRT            ; start over if buffer is empty
088F | C9 20    | CMP #$20    |         CMP.# $20            ; skip leading spaces
0891 | F0 F7    | BEQ $F7     |         BEQ ST1
0893 | A2 16    | LDX #$16    | S0:      LDX.# KEYTOP-KEYW    ; loop through valid command characters
0895 | DD B4 12 | CMP $12B4,X | S1:      CMP,X KEYW          ; see if input character matches
0898 | F0 0B    | BEQ $0B     |         BEQ S2              ; command matched, dispatch it
089A | CA       | DEX         |         DEX                 ; no match, check next command
089B | 10 F8    | BPL $F8     |         BPL S1              ; keep trying until we've checked them all
089D |          |             |                             ; then fall through to error handler
089D |          |             | 
089D |          |             | ; -----------------------------------------------------------------------------
089D |          |             | ; handle error
089D | A0 1E    | LDY #$1E    | ERROR:   LDY.# MSG3-MSGBAS    ; display "?" to indicate error and go to new line
089F | 20 91 11 | JSR $1191   |         JSR SNDMSG
08A2 | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to main loop
08A5 |          |             | 
08A5 |          |             | ; -----------------------------------------------------------------------------
08A5 |          |             | ; dispatch command
08A5 | E0 13    | CPX #$13    | S2:      CPX.# $13            ; last 3 commands in table are load/save/validate
08A7 | B0 12    | BCS $12     |         BCS LSV             ;   which are handled by the same subroutine
08A9 | E0 0F    | CPX #$0F    |         CPX.# $0F            ; next 4 commands are base conversions
08AB | B0 14    | BCS $14     |         BCS CNVLNK          ;   which are handled by the same subroutine
08AD | 8A       | TXA         |         TXA                 ; remaining commands dispatch through vector table
08AE | 0A       | ASL A       |         ASL.A               ; multiply index of command by 2
08AF | AA       | TAX         |         TAX                 ;   since table contains 2-byte addresses
08B0 | BD CB 12 | LDA $12CB,X |         LDA,X KADDR+1       ; push address from vector table onto stack
08B3 | 48       | PHA         |         PHA                 ;   so that the RTS from GETPAR will jump there
08B4 | BD CA 12 | LDA $12CA,X |         LDA,X KADDR
08B7 | 48       | PHA         |         PHA
08B8 | 4C 0C 0E | JMP $0E0C   |         JMP GETPAR          ; get the first parameter for the command
08BB | 8D 32 02 | STA $0232   | LSV:     STA SAVY            ; handle load/save/validate
08BE | 4C 8E 0A | JMP $0A8E   |         JMP LD
08C1 | 4C D0 0F | JMP $0FD0   | CNVLNK:  JMP CONVRT          ; handle base conversion
08C4 |          |             | 
08C4 |          |             | ; -----------------------------------------------------------------------------
08C4 |          |             | ; exit monitor [X]
08C4 | 6C 02 A0 | JMP ($A002) | EXIT:    JMP.i $A002         ; jump to warm-start vector to reinitialize BASIC
08C7 |          |             | 
08C7 |          |             | ; -----------------------------------------------------------------------------
08C7 |          |             | ; display memory [M]
08C7 | B0 08    | BCS $08     | DSPLYM:  BCS DSPM11          ; start from previous end addr if no address given
08C9 | 20 45 0F | JSR $0F45   |         JSR COPY12          ; save start address in TMP2
08CC | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get end address in TMP0
08CF | 90 06    | BCC $06     |         BCC DSMNEW          ; did user specify one?
08D1 | A9 0B    | LDA #$0B    | DSPM11:  LDA.# $0B            ; if not, show 12 lines by default
08D3 | 85 C1    | STA $C1     |         STA.zp TMP0
08D5 | D0 0E    | BNE $0E     |         BNE DSPBYT          ; always true, but BNE uses 1 byte less than JMP
08D7 | 20 4E 0F | JSR $0F4E   | DSMNEW:  JSR SUB12           ; end addr given, calc bytes between start and end
08DA | 90 1E    | BCC $1E     |         BCC MERROR          ; error if start is after end
08DC | A2 03    | LDX #$03    |         LDX.# 3              ; divide by 8 (shift right 3 times)
08DE | 46 C2    | LSR $C2     | DSPM01:  LSR.zp TMP0+1
08E0 | 66 C1    | ROR $C1     |         ROR.zp TMP0
08E2 | CA       | DEX         |         DEX 
08E3 | D0 F9    | BNE $F9     |         BNE DSPM01
08E5 | 20 E1 FF | JSR $FFE1   | DSPBYT:  JSR STOP            ; check for stop key
08E8 | F0 0D    | BEQ $0D     |         BEQ DSPMX           ; exit early if pressed
08EA | 20 6A 09 | JSR $096A   |         JSR DISPMEM         ; display 1 line containing 8 bytes
08ED | A9 08    | LDA #$08    |         LDA.# 8              ; increase start address by 8 bytes
08EF | 20 84 0F | JSR $0F84   |         JSR BUMPAD2
08F2 | 20 5C 0F | JSR $0F5C   |         JSR SUBA1           ; decrement line counter
08F5 | B0 EE    | BCS $EE     |         BCS DSPBYT          ; show another line until it's < 0
08F7 | 4C 6E 08 | JMP $086E   | DSPMX:   JMP STRT            ; back to main loop
08FA | 4C 9D 08 | JMP $089D   | MERROR:  JMP ERROR           ; handle error
08FD |          |             | 
08FD |          |             | ; -----------------------------------------------------------------------------
08FD |          |             | ; alter registers [;]
08FD | 20 9C 0F | JSR $0F9C   | ALTR:   JSR COPY1P          ; store first parameter in PC
0900 | A0 00    | LDY #$00    |         LDY.# 0              ; init counter
0902 | 20 0C 0E | JSR $0E0C   | ALTR1:  JSR GETPAR          ; get value for next register
0905 | B0 0A    | BCS $0A     |         BCS ALTRX           ; exit early if no more values given
0907 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; store in memory, offset from SR
0909 | 99 2A 02 | STA $022A,Y |         STA,Y SR            ; these locations will be transferred to the
090C | C8       | INY         |         INY                 ;   actual registers before exiting the monitor
090D | C0 05    | CPY #$05    |         CPY.# $05            ; have we updated all 5 yet?
090F | 90 F1    | BCC $F1     |         BCC ALTR1           ; if not, get next
0911 | 4C 6E 08 | JMP $086E   | ALTRX:  JMP STRT            ; back to main loop
0914 |          |             | 
0914 |          |             | ; -----------------------------------------------------------------------------
0914 |          |             | ; alter memory [>]
0914 | B0 13    | BCS $13     | ALTM:   BCS ALTMX           ; exit if no parameter provided
0916 | 20 45 0F | JSR $0F45   |         JSR COPY12          ; copy parameter to start address
0919 | A0 00    | LDY #$00    |         LDY.# 0
091B | 20 0C 0E | JSR $0E0C   | ALTM1:  JSR GETPAR          ; get value for next byte of memory
091E | B0 09    | BCS $09     |         BCS ALTMX           ; if none given, exit early
0920 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; poke value into memory at start address + Y
0922 | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2
0924 | C8       | INY         |         INY                 ; next byte
0925 | C0 08    | CPY #$08    |         CPY.# 8              ; have we read 8 bytes yet?
0927 | 90 F2    | BCC $F2     |         BCC ALTM1           ; if not, read the next one
0929 | A9 91    | LDA #$91    | ALTMX:  LDA.# $91            ; move cursor up
092B | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
092E | 20 6A 09 | JSR $096A   |         JSR DISPMEM         ; re-display line to make ascii match hex
0931 | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to main loop
0934 |          |             | 
0934 |          |             | ; -----------------------------------------------------------------------------
0934 |          |             | ; goto (run) [G]
0934 | AE 2E 02 | LDX $022E   | GOTO:   LDX SP              ; load stack pointer from memory
0937 | 9A       | TXS         |         TXS                 ; save in SP register
0938 | 20 9C 0F | JSR $0F9C   | GOTO2:  JSR COPY1P          ; copy provided address to PC
093B | 78       | SEI         |         SEI                 ; disable interrupts
093C | AD 28 02 | LDA $0228   |         LDA PCH             ; push PC high byte on stack
093F | 48       | PHA         |         PHA
0940 | AD 29 02 | LDA $0229   |         LDA PCL             ; push PC low byte on stack
0943 | 48       | PHA         |         PHA
0944 | AD 2A 02 | LDA $022A   |         LDA SR              ; push status byte on stack
0947 | 48       | PHA         |         PHA
0948 | AD 2B 02 | LDA $022B   |         LDA ACC             ; load accumulator from memory
094B | AE 2C 02 | LDX $022C   |         LDX XR              ; load X from memory
094E | AC 2D 02 | LDY $022D   |         LDY YR              ; load Y from memory
0951 | 40       | RTI         |         RTI                 ; return from interrupt (pops PC and SR)
0952 |          |             | 
0952 |          |             | ; jump to subroutine [J]
0952 | AE 2E 02 | LDX $022E   | JSUB:   LDX SP              ; load stack pointer from memory
0955 | 9A       | TXS         |         TXS                 ; save value in SP register
0956 | 20 38 09 | JSR $0938   |         JSR GOTO2           ; same as goto command
0959 | 8C 2D 02 | STY $022D   |         STY YR              ; save Y to memory
095C | 8E 2C 02 | STX $022C   |         STX XR              ; save X to memory
095F | 8D 2B 02 | STA $022B   |         STA ACC             ; save accumulator to memory
0962 | 08       | PHP         |         PHP                 ; push processor status on stack
0963 | 68       | PLA         |         PLA                 ; pull processor status into A
0964 | 8D 2A 02 | STA $022A   |         STA SR              ; save processor status to memory
0967 | 4C 4C 08 | JMP $084C   |         JMP DSPLYR          ; display registers
096A |          |             | 
096A |          |             | ; -----------------------------------------------------------------------------
096A |          |             | ; display 8 bytes of memory
096A | 20 EA 0E | JSR $0EEA   | DISPMEM: JSR CRLF            ; new line
096D | A9 3E    | LDA #$3E    |         LDA.# '>'            ; prefix > so memory can be edited in place
096F | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0972 | 20 D5 0E | JSR $0ED5   |         JSR SHOWAD          ; show address of first byte on line
0975 | A0 00    | LDY #$00    |         LDY.# 0
0977 | F0 03    | BEQ $03     |         BEQ DMEMGO          ; SHOWAD already printed a space after the address
0979 | 20 E2 0E | JSR $0EE2   | DMEMLP: JSR SPACE           ; print space between bytes
097C | B1 C3    | LDA ($C3),Y | DMEMGO: LDA.i,Y TMP2        ; load byte from start address + Y
097E | 20 03 0F | JSR $0F03   |         JSR WRTWO           ; output hex digits for byte
0981 | C8       | INY         |         INY                 ; next byte
0982 | C0 08    | CPY #$08    |         CPY.# 8              ; have we output 8 bytes yet?
0984 | 90 F3    | BCC $F3     |         BCC DMEMLP          ; if not, output next byte
0986 | A0 26    | LDY #$26    |         LDY.# MSG5-MSGBAS    ; if so, output : and turn on reverse video
0988 | 20 91 11 | JSR $1191   |         JSR SNDMSG          ;   before displaying ascii representation
098B | A0 00    | LDY #$00    |         LDY.# 0              ; back to first byte in line
098D | B1 C3    | LDA ($C3),Y | DCHAR:  LDA.i,Y TMP2        ; load byte at start address + Y
098F | AA       | TAX         |         TAX                 ; stash in X
0990 | 29 BF    | AND #$BF    |         AND.# $BF            ; clear 6th bit
0992 | C9 22    | CMP #$22    |         CMP.# $22            ; is it a quote (")?
0994 | F0 08    | BEQ $08     |         BEQ DDOT            ; if so, print . instead
0996 | 8A       | TXA         |         TXA                 ; if not, restore character
0997 | 29 7F    | AND #$7F    |         AND.# $7F            ; clear top bit
0999 | C9 20    | CMP #$20    |         CMP.# $20            ; is it a printable character (>= $20)?
099B | 8A       | TXA         |         TXA                 ; restore character
099C | B0 02    | BCS $02     |         BCS DCHROK          ; if printable, output character
099E | A9 2E    | LDA #$2E    | DDOT:   LDA.# $2E            ; if not, output '.' instaed
09A0 | 20 D2 FF | JSR $FFD2   | DCHROK: JSR CHROUT
09A3 | C8       | INY         |         INY                 ; next byte
09A4 | C0 08    | CPY #$08    |         CPY.# 8              ; have we output 8 bytes yet?
09A6 | 90 E5    | BCC $E5     |         BCC DCHAR           ; if not, output next byte
09A8 | 60       | RTS         |         RTS 
09A9 |          |             | 
09A9 |          |             | ; -----------------------------------------------------------------------------
09A9 |          |             | ; compare memory [C]
09A9 | A9 00    | LDA #$00    | COMPAR: LDA.# 0              ; bit 7 clear signals compare
09AB | 2C       |             |         DATA.b $2C           ; absolute BIT opcode consumes next word (LDA #$80)
09AC |          |             | 
09AC |          |             | ; transfer memory [T]
09AC | A9 80    | LDA #$80    | TRANS:  LDA.# $80            ; bit 7 set signals transfer
09AE | 8D 32 02 | STA $0232   |         STA SAVY            ; save compare/transfer flag in SAVY
09B1 | A9 00    | LDA #$00    |         LDA.# 0              ; assume we're counting up (bit 7 clear)
09B3 | 8D 07 01 | STA $0107   |         STA UPFLG           ; save direction flag
09B6 | 20 A9 0F | JSR $0FA9   |         JSR GETDIF          ; get two addresses and calculate difference
09B9 |          |             |                             ;   TMP2 = source start
09B9 |          |             |                             ;   STASH = source end
09B9 |          |             |                             ;   STORE = length
09B9 | B0 05    | BCS $05     |         BCS TERROR          ; carry set indicates error
09BB | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get destination address in TMP0
09BE | 90 03    | BCC $03     |         BCC TOKAY           ; carry set indicates error
09C0 | 4C 9D 08 | JMP $089D   | TERROR: JMP ERROR           ; handle error
09C3 | 2C 32 02 | BIT $0232   | TOKAY:  BIT SAVY            ; transfer or compare?
09C6 | 10 27    | BPL $27     |         BPL COMPAR1         ; high bit clear indicates compare
09C8 | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; if it's a transfer, we must take steps
09CA | C5 C1    | CMP $C1     |         CMP.zp TMP0            ;   to avoid overwriting the source bytes before 
09CC | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ;   they have been transferred
09CE | E5 C2    | SBC $C2     |         SBC.zp TMP0+1          ; compare source (TMP2) to destination (TMP0)
09D0 | B0 1D    | BCS $1D     |         BCS COMPAR1         ; and count up if source is before than desitnation
09D2 | AD 2F 02 | LDA $022F   |         LDA STORE           ; otherwise, start at end and count down...
09D5 | 65 C1    | ADC $C1     |         ADC.zp TMP0            ; add length (STORE) to desintation (TMP0)
09D7 | 85 C1    | STA $C1     |         STA.zp TMP0            ; to calculate end of destination
09D9 | AD 30 02 | LDA $0230   |         LDA STORE+1
09DC | 65 C2    | ADC $C2     |         ADC.zp TMP0+1
09DE | 85 C2    | STA $C2     |         STA.zp TMP0+1
09E0 | A2 01    | LDX #$01    |         LDX.# 1              ; change source pointer from beginning to end
09E2 | BD 0B 01 | LDA $010B,X | TDOWN:  LDA,X STASH         ; TMP2 = source end (STASH)
09E5 | 95 C3    | STA $C3,X   |         STA.zp,X TMP2
09E7 | CA       | DEX         |         DEX 
09E8 | 10 F8    | BPL $F8     |         BPL TDOWN
09EA | A9 80    | LDA #$80    |         LDA.# $80            ; high bit set in UPFLG means count down
09EC | 8D 07 01 | STA $0107   |         STA UPFLG
09EF | 20 EA 0E | JSR $0EEA   | COMPAR1: JSR CRLF            ; new line
09F2 | A0 00    | LDY #$00    |         LDY.# 0              ; no offset from pointer
09F4 | 20 E1 FF | JSR $FFE1   | TCLOOP: JSR STOP            ; check for stop key
09F7 | F0 31    | BEQ $31     |         BEQ TEXIT           ; exit if pressed
09F9 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; load byte from source
09FB | 2C 32 02 | BIT $0232   |         BIT SAVY            ; transfer or compare?
09FE | 10 02    | BPL $02     |         BPL COMPAR2         ; skip store if comparing
0A00 | 91 C1    | STA ($C1),Y |         STA.i,Y TMP0        ; otherwise, store in destination
0A02 | D1 C1    | CMP ($C1),Y | COMPAR2: CMP.i,Y TMP0        ; compare to destination
0A04 | F0 03    | BEQ $03     |         BEQ TMVAD           ; don't show address if equal
0A06 | 20 D5 0E | JSR $0ED5   |         JSR SHOWAD          ; show address
0A09 | 2C 07 01 | BIT $0107   | TMVAD:  BIT UPFLG           ; counting up or down?
0A0C | 30 0B    | BMI $0B     |         BMI TDECAD          ; high bit set means we're counting down
0A0E | E6 C1    | INC $C1     |         INC.zp TMP0            ; increment destination low byte
0A10 | D0 10    | BNE $10     |         BNE TINCOK
0A12 | E6 C2    | INC $C2     |         INC.zp TMP0+1          ; carry to high byte if necessary
0A14 | D0 0C    | BNE $0C     |         BNE TINCOK
0A16 | 4C 9D 08 | JMP $089D   |         JMP ERROR           ; error if high byte overflowed
0A19 | 20 5C 0F | JSR $0F5C   | TDECAD: JSR SUBA1           ; decrement destination (TMP0)
0A1C | 20 8E 0F | JSR $0F8E   |         JSR SUB21           ; decrement source (TMP2)
0A1F | 4C 25 0A | JMP $0A25   |         JMP TMOR
0A22 | 20 82 0F | JSR $0F82   | TINCOK: JSR ADDA2           ; increment source (TMP2)
0A25 | 20 70 0F | JSR $0F70   | TMOR:   JSR SUB13           ; decrement length
0A28 | B0 CA    | BCS $CA     |         BCS TCLOOP          ; loop until length is 0
0A2A | 4C 6E 08 | JMP $086E   | TEXIT:  JMP STRT            ; back to main loop
0A2D |          |             | 
0A2D |          |             | ; -----------------------------------------------------------------------------
0A2D |          |             | ; hunt memory [H]
0A2D | 20 A9 0F | JSR $0FA9   | HUNT:   JSR GETDIF          ; get start (TMP2) and end (TMP0) of haystack
0A30 | B0 59    | BCS $59     |         BCS HERROR          ; carry indicates error
0A32 | A0 00    | LDY #$00    |         LDY.# 0
0A34 | 20 2B 0F | JSR $0F2B   |         JSR GETCHR          ; get a single character
0A37 | C9 27    | CMP #$27    |         CMP.# 39 ; "'"            ; is it a single quote?
0A39 | D0 16    | BNE $16     |         BNE NOSTRH          ; if not, input needle as hex bytes
0A3B | 20 2B 0F | JSR $0F2B   |         JSR GETCHR          ; if so, input needle as string
0A3E | C9 00    | CMP #$00    |         CMP.# 0
0A40 | F0 49    | BEQ $49     |         BEQ HERROR          ; error if needle isn't at least one byte
0A42 | 99 17 01 | STA $0117,Y | HPAR:   STA,Y STAGE         ; save char in staging area
0A45 | C8       | INY         |         INY 
0A46 | 20 2B 0F | JSR $0F2B   |         JSR GETCHR          ; get another char
0A49 | F0 18    | BEQ $18     |         BEQ HTGO            ; if it's null start searching
0A4B | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; have we filled up the needle staging area?
0A4D | D0 F3    | BNE $F3     |         BNE HPAR            ; if not, get another character
0A4F | F0 12    | BEQ $12     |         BEQ HTGO            ; if so, start searching
0A51 | 20 09 0E | JSR $0E09   | NOSTRH: JSR RDPAR           ; read hex bytes if string not indicated
0A54 | A5 C1    | LDA $C1     | HLP:    LDA.zp TMP0            ; save last read byte in staging area
0A56 | 99 17 01 | STA $0117,Y |         STA,Y STAGE
0A59 | C8       | INY         |         INY                 ; get another hex byte
0A5A | 20 0C 0E | JSR $0E0C   |         JSR GETPAR
0A5D | B0 04    | BCS $04     |         BCS HTGO            ; if there is none, start searching
0A5F | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; have we filled up the needle staging area?
0A61 | D0 F1    | BNE $F1     |         BNE HLP             ; if not, get another byte
0A63 | 8C 32 02 | STY $0232   | HTGO:   STY SAVY            ; save length of needle
0A66 | 20 EA 0E | JSR $0EEA   |         JSR CRLF            ; new line
0A69 | A0 00    | LDY #$00    | HSCAN:  LDY.# 0
0A6B | B1 C3    | LDA ($C3),Y | HLP3:   LDA.i,Y TMP2        ; get first byte in haystack
0A6D | D9 17 01 | CMP $0117,Y |         CMP,Y STAGE         ; compare it to first byte of needle
0A70 | D0 09    | BNE $09     |         BNE HNOFT           ; if it doesn't match, we haven't found anything
0A72 | C8       | INY         |         INY                 ; if it does, check the next byte
0A73 | CC 32 02 | CPY $0232   |         CPY SAVY            ; have we reached the end of the needle?
0A76 | D0 F3    | BNE $F3     |         BNE HLP3            ; if not, keep comparing bytes
0A78 | 20 D5 0E | JSR $0ED5   |         JSR SHOWAD          ; match found, show address
0A7B | 20 E1 FF | JSR $FFE1   | HNOFT:  JSR STOP            ; no match, check for stop key
0A7E | F0 08    | BEQ $08     |         BEQ HEXIT           ; exit prematurely if pressed
0A80 | 20 82 0F | JSR $0F82   |         JSR ADDA2           ; increment haystack pointer
0A83 | 20 70 0F | JSR $0F70   |         JSR SUB13           ; decrement haystack length
0A86 | B0 E1    | BCS $E1     |         BCS HSCAN           ; still more haystack? keep searching
0A88 | 4C 6E 08 | JMP $086E   | HEXIT:  JMP STRT            ; back to main loop
0A8B | 4C 9D 08 | JMP $089D   | HERROR: JMP ERROR           ; handle error
0A8E |          |             | 
0A8E |          |             | ; -----------------------------------------------------------------------------
0A8E |          |             | ; load, save, or verify [LSV]
0A8E | A0 01    | LDY #$01    | LD:     LDY.# 1              ; default to reading from tape, device #1
0A90 | 84 BA    | STY $BA     |         STY.zp FA
0A92 | 84 B9    | STY $B9     |         STY.zp SADD            ; default to secondary address #1
0A94 | 88       | DEY         |         DEY
0A95 | 84 B7    | STY $B7     |         STY.zp FNLEN           ; start with an empty filename
0A97 | 84 90    | STY $90     |         STY.zp SATUS           ; clear status
0A99 | A9 01    | LDA #$01    |         LDA.# STAGE >> 8        ; set filename pointer to staging buffer
0A9B | 85 BC    | STA $BC     |         STA.zp FNADR+1
0A9D | A9 17    | LDA #$17    |         LDA.# STAGE & 0x00ff 
0A9F | 85 BB    | STA $BB     |         STA.zp FNADR
0AA1 | 20 2B 0F | JSR $0F2B   | L1:     JSR GETCHR          ; get a character
0AA4 | F0 59    | BEQ $59     |         BEQ LSHORT          ; no filename given, try load or verify from tape
0AA6 | C9 20    | CMP #$20    |         CMP.# $20            ; skip leading spaces
0AA8 | F0 F7    | BEQ $F7     |         BEQ L1
0AAA | C9 22    | CMP #$22    |         CMP.# $22            ; error if filename doesn't start with a quote
0AAC | D0 16    | BNE $16     |         BNE LERROR
0AAE | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; load current char pointer into index reg
0AB1 | BD 00 02 | LDA $0200,X | L3:     LDA,X INBUFF        ; load current char from buffer to accumulator
0AB4 | F0 49    | BEQ $49     |         BEQ LSHORT          ; no filename given, try load or verify from tape
0AB6 | E8       | INX         |         INX                 ; next char
0AB7 | C9 22    | CMP #$22    |         CMP.# $22            ; is it a quote?
0AB9 | F0 0C    | BEQ $0C     |         BEQ L8              ; if so, we've reached the end of the filename
0ABB | 91 BB    | STA ($BB),Y |         STA.i,Y FNADR       ; if not, save character in filename buffer
0ABD | E6 B7    | INC $B7     |         INC.zp FNLEN           ; increment filename length
0ABF | C8       | INY         |         INY 
0AC0 | C0 1E    | CPY #$1E    |         CPY.# ESTAGE-STAGE   ; check whether buffer is full
0AC2 | 90 ED    | BCC $ED     |         BCC L3              ; if not, get another character
0AC4 | 4C 9D 08 | JMP $089D   | LERROR: JMP ERROR           ; if so, handle error
0AC7 | 8E 31 02 | STX $0231   | L8:     STX CHRPNT          ; set character pointer to the current index
0ACA | 20 2B 0F | JSR $0F2B   |         JSR GETCHR          ; eat separator between filename and device #
0ACD | F0 30    | BEQ $30     |         BEQ LSHORT          ; no separator, try to load or verify from tape
0ACF | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get device number
0AD2 | B0 2B    | BCS $2B     |         BCS LSHORT          ; no device # given, try load or verify from tape
0AD4 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; set device number for kernal routines
0AD6 | 85 BA    | STA $BA     |         STA.zp FA
0AD8 | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get start address for load or save in TMP0
0ADB | B0 22    | BCS $22     |         BCS LSHORT          ; no start address, try to load or verify
0ADD | 20 45 0F | JSR $0F45   |         JSR COPY12          ; transfer start address to TMP2
0AE0 | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get end address for save in TMP0
0AE3 | B0 3D    | BCS $3D     |         BCS LDADDR          ; no end address, try to load to given start addr
0AE5 | 20 EA 0E | JSR $0EEA   |         JSR CRLF            ; new line
0AE8 | A6 C1    | LDX $C1     |         LDX.zp TMP0            ; put low byte of end address in X
0AEA | A4 C2    | LDY $C2     |         LDY.zp TMP0+1          ; put high byte of end address in Y
0AEC | AD 32 02 | LDA $0232   |         LDA SAVY            ; confirm that we're doing a save
0AEF | C9 53    | CMP #$53    |         CMP.# 'S'
0AF1 | D0 D1    | BNE $D1     |         BNE LERROR          ; if not, error due to too many params
0AF3 | A9 00    | LDA #$00    |         LDA.# 0
0AF5 | 85 B9    | STA $B9     |         STA.zp SADD            ; set secondary address to 0
0AF7 | A9 C3    | LDA #$C3    |         LDA.# TMP2           ; put addr of zero-page pointer to data in A
0AF9 | 20 D8 FF | JSR $FFD8   |         JSR SAVE            ; call kernal save routine
0AFC | 4C 6E 08 | JMP $086E   | LSVXIT: JMP STRT            ; back to mainloop
0AFF | AD 32 02 | LDA $0232   | LSHORT: LDA SAVY            ; check which command we received
0B02 | C9 56    | CMP #$56    |         CMP.# 'V'
0B04 | F0 06    | BEQ $06     |         BEQ LOADIT          ; we're doing a verify so don't set A to 0
0B06 | C9 4C    | CMP #$4C    |         CMP.# 'L'
0B08 | D0 BA    | BNE $BA     |         BNE LERROR          ; error due to not enough params for save
0B0A | A9 00    | LDA #$00    |         LDA.# 0              ; 0 in A signals load, anything else is verify
0B0C | 20 D5 FF | JSR $FFD5   | LOADIT: JSR LOAD            ; call kernal load routine
0B0F | A5 90    | LDA $90     |         LDA.zp SATUS           ; get i/o status
0B11 | 29 10    | AND #$10    |         AND.# $10            ; check bit 5 for checksum error
0B13 | F0 E7    | BEQ $E7     |         BEQ LSVXIT          ; if no error go back to mainloop
0B15 | AD 32 02 | LDA $0232   |         LDA SAVY            ; ?? not sure what these two lines are for...
0B18 | F0 AA    | BEQ $AA     |         BEQ LERROR          ; ?? SAVY will never be 0, so why check?
0B1A | A0 28    | LDY #$28    |         LDY.# MSG6-MSGBAS    ; display "ERROR" if checksum didn't match
0B1C | 20 91 11 | JSR $1191   |         JSR SNDMSG
0B1F | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to mainloop
0B22 | A6 C3    | LDX $C3     | LDADDR: LDX.zp TMP2            ; load address low byte in X
0B24 | A4 C4    | LDY $C4     |         LDY.zp TMP2+1          ; load address high byte in Y
0B26 | A9 00    | LDA #$00    |         LDA.# 0              ; 0 in A signals load
0B28 | 85 B9    | STA $B9     |         STA.zp SADD            ; secondary addr 0 means load to addr in X and Y
0B2A | F0 D3    | BEQ $D3     |         BEQ LSHORT          ; execute load
0B2C |          |             | 
0B2C |          |             | ; -----------------------------------------------------------------------------
0B2C |          |             | ; fill memory [F]
0B2C | 20 A9 0F | JSR $0FA9   | FILL:   JSR GETDIF          ; start in TMP2, end in STASH, length in STORE
0B2F | B0 59    | BCS $59     |         BCS AERROR          ; carry set indicates error
0B31 | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get value to fill in TMP0
0B34 | B0 54    | BCS $54     |         BCS AERROR          ; carry set indicates error
0B36 | 20 2B 0F | JSR $0F2B   |         JSR GETCHR          ; any more characters triggers an error
0B39 | D0 4F    | BNE $4F     |         BNE AERROR
0B3B | A0 00    | LDY #$00    |         LDY.# 0              ; no offset
0B3D | A5 C1    | LDA $C1     | FILLP:  LDA.zp TMP0            ; load value to fill in accumulator
0B3F | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2        ; store fill value in current address
0B41 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
0B44 | F0 08    | BEQ $08     |         BEQ FSTART          ; if pressed, back to main loop
0B46 | 20 82 0F | JSR $0F82   |         JSR ADDA2           ; increment address
0B49 | 20 70 0F | JSR $0F70   |         JSR SUB13           ; decrement length
0B4C | B0 EF    | BCS $EF     |         BCS FILLP           ; keep going until length reaches 0
0B4E | 4C 6E 08 | JMP $086E   | FSTART: JMP STRT            ; back to main loop
0B51 |          |             | 
0B51 |          |             | ; -----------------------------------------------------------------------------
0B51 |          |             | ; assemble [A.]
0B51 |          |             | 
0B51 |          |             | ; read in mnemonic
0B51 | B0 37    | BCS $37     | ASSEM:  BCS AERROR          ; error if no address given
0B53 | 20 45 0F | JSR $0F45   |         JSR COPY12          ; copy address to TMP2
0B56 | A2 00    | LDX #$00    | AGET1:  LDX.# 0
0B58 | 8E 0E 01 | STX $010E   |         STX U0AA0+1         ; clear byte that mnemonic gets shifted into
0B5B | 8E 08 01 | STX $0108   |         STX DIGCNT          ; clear digit count
0B5E | 20 2B 0F | JSR $0F2B   | AGET2:  JSR GETCHR          ; get a char
0B61 | D0 04    | BNE $04     |         BNE ALMOR           ; proceed if the character isn't null
0B63 | E0 00    | CPX #$00    |         CPX.# 0              ; it's null, have read a mnemonic yet?
0B65 | F0 E7    | BEQ $E7     |         BEQ FSTART          ; if not, silently go back to main loop
0B67 | C9 20    | CMP #$20    | ALMOR:  CMP.# $20            ; skip leading spaces
0B69 | F0 EB    | BEQ $EB     |         BEQ AGET1
0B6B | 9D 02 01 | STA $0102,X |         STA,X MNEMW         ; put character in mnemonic buffer
0B6E | E8       | INX         |         INX
0B6F | E0 03    | CPX #$03    |         CPX.# 3              ; have we read 3 characters yet?
0B71 | D0 EB    | BNE $EB     |         BNE AGET2           ; if not, get next character
0B73 |          |             | 
0B73 |          |             | ; compress mnemonic into two bytes
0B73 | CA       | DEX         | ASQEEZ: DEX                 ; move to previous char
0B74 | 30 17    | BMI $17     |         BMI AOPRND          ; if we're done with mnemonic, look for operand
0B76 | BD 02 01 | LDA $0102,X |         LDA,X MNEMW         ; get current character
0B79 | 38       | SEC         |         SEC                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
0B7A | E9 3F    | SBC #$3F    |         SBC.# $3F            ; subtract $3F from ascii code so A-Z = 2 to 27
0B7C | A0 05    | LDY #$05    |         LDY.# $05            ; letters now fit in 5 bits; shift them out
0B7E | 4A       | LSR A       | ASHIFT: LSR.A               ;   into the first two bytes of the inst buffer
0B7F | 6E 0E 01 | ROR $010E   |         ROR U0AA0+1         ; catch the low bit from accumulator in right byte
0B82 | 6E 0D 01 | ROR $010D   |         ROR U0AA0           ; catch the low bit from right byte in left byte
0B85 | 88       | DEY         |         DEY                 ; count down bits
0B86 | D0 F6    | BNE $F6     |         BNE ASHIFT          ; keep looping until we reach zero
0B88 | F0 E9    | BEQ $E9     |         BEQ ASQEEZ          ; unconditional branch to handle next char
0B8A | 4C 9D 08 | JMP $089D   | AERROR: JMP ERROR           ; handle error
0B8D |          |             | 
0B8D |          |             | ; parse operand
0B8D | A2 02    | LDX #$02    | AOPRND: LDX.# 2              ; mnemonic is in first two bytes so start at third
0B8F | AD 08 01 | LDA $0108   | ASCAN:  LDA DIGCNT          ; did we find address digits last time?
0B92 | D0 2D    | BNE $2D     |         BNE AFORM1          ; if so, look for mode chars
0B94 | 20 34 0E | JSR $0E34   |         JSR RDVAL           ; otherwise, look for an address
0B97 | F0 25    | BEQ $25     |         BEQ AFORM0          ; we didn't find an address, look for characters
0B99 | B0 EF    | BCS $EF     |         BCS AERROR          ; carry flag indicates error
0B9B | A9 24    | LDA #$24    |         LDA.# 0x24  ; "$"
0B9D | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; prefix addresses with $
0BA0 | E8       | INX         |         INX                 ; next position in buffer
0BA1 | A0 04    | LDY #$04    |         LDY.# 4              ; non-zero page addresses are 4 hex digits
0BA3 | AD 0A 01 | LDA $010A   |         LDA NUMBIT          ; check numeric base in which address was given
0BA6 | C9 08    | CMP #$08    |         CMP.# 8              ; for addresses given in octal or binary
0BA8 | 90 05    | BCC $05     |         BCC AADDR           ;   use only the high byte to determine page
0BAA | CC 08 01 | CPY $0108   |         CPY DIGCNT          ; for decimal or hex, force non-zero page addressing
0BAD | F0 06    | BEQ $06     |         BEQ AFILL0          ;   if address was given with four digits or more 
0BAF | A5 C2    | LDA $C2     | AADDR:  LDA.zp TMP0+1          ; check whether high byte of address is zero
0BB1 | D0 02    | BNE $02     |         BNE AFILL0          ; non-zero high byte means we're not in zero page
0BB3 | A0 02    | LDY #$02    |         LDY.# 2              ; if it's in zero page, addr is 2 hex digits
0BB5 | A9 30    | LDA #$30    | AFILL0: LDA.# $30            ; use 0 as placeholder for each hex digit in addr
0BB7 | 9D 0D 01 | STA $010D,X | AFIL0L: STA,X U0AA0         ; put placeholder in assembly buffer
0BBA | E8       | INX         |         INX                 ; move to next byte in buffer
0BBB | 88       | DEY         |         DEY                 ; decrement number of remaining digits
0BBC | D0 F9    | BNE $F9     |         BNE AFIL0L          ; loop until all digits have been placed
0BBE | CE 31 02 | DEC $0231   | AFORM0: DEC CHRPNT          ; non-numeric input; back 1 char to see what it was
0BC1 | 20 2B 0F | JSR $0F2B   | AFORM1: JSR GETCHR          ; get next character
0BC4 | F0 0E    | BEQ $0E     |         BEQ AESCAN          ; if there is none, we're finished scanning
0BC6 | C9 20    | CMP #$20    |         CMP.# $20            ; skip spaces
0BC8 | F0 C5    | BEQ $C5     |         BEQ ASCAN
0BCA | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; store character in assembly buffer
0BCD | E8       | INX         |         INX                 ; move to next byte in buffer
0BCE | E0 0A    | CPX #$0A    |         CPX.# U0AAE-U0AA0    ; is instruction buffer full?
0BD0 | 90 BD    | BCC $BD     |         BCC ASCAN           ; if not, keep scanning
0BD2 | B0 B6    | BCS $B6     |         BCS AERROR          ; error if buffer is full
0BD4 |          |             | 
0BD4 |          |             | 
0BD4 |          |             | ; find matching opcode
0BD4 | 8E 2F 02 | STX $022F   | AESCAN: STX STORE           ; save number of bytes in assembly buffer
0BD7 | A2 00    | LDX #$00    |         LDX.# 0              ; start at opcode $00 and check every one until
0BD9 | 8E 06 01 | STX $0106   |         STX OPCODE          ;   we find one that matches our criteria
0BDC | A2 00    | LDX #$00    | ATRYOP: LDX.# 0
0BDE | 8E 33 02 | STX $0233   |         STX U9F             ; reset index into work buffer
0BE1 | AD 06 01 | LDA $0106   |         LDA OPCODE
0BE4 | 20 9B 0D | JSR $0D9B   |         JSR INSTXX          ; look up instruction format for current opcode
0BE7 | AE 00 01 | LDX $0100   |         LDX ACMD            ; save addressing command for later
0BEA | 8E 30 02 | STX $0230   |         STX STORE+1
0BED | AA       | TAX         |         TAX                 ; use current opcode as index
0BEE | BD 70 12 | LDA $1270,X |         LDA,X MNEMR         ; check right byte of compressed mnemonic
0BF1 | 20 C2 0C | JSR $0CC2   |         JSR CHEKOP
0BF4 | BD 30 12 | LDA $1230,X |         LDA,X MNEML         ; check left byte of compressed mnemonic
0BF7 | 20 C2 0C | JSR $0CC2   |         JSR CHEKOP
0BFA | A2 06    | LDX #$06    |         LDX.# 6              ; 6 possible characters to check against operand
0BFC | E0 03    | CPX #$03    | TRYIT:  CPX.# 3              ; are we on character 3?
0BFE | D0 14    | BNE $14     |         BNE TRYMOD          ; if not, check operand characters
0C00 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; otherwise, check number of bytes in operand
0C03 | F0 0F    | BEQ $0F     |         BEQ TRYMOD          ; if zero, check operand characters
0C05 | AD 00 01 | LDA $0100   | TRYAD:  LDA ACMD            ; otherwise, look for an address
0C08 | C9 E8    | CMP #$E8    |         CMP.# $E8            ; special case for relative addressing mode
0C0A |          |             |                             ;   since it's specified with 4 digits in assembly
0C0A |          |             |                             ;   but encoded with only 1 byte in object code
0C0A | A9 30    | LDA #$30    |         LDA.# $30            ; '0' is the digit placeholder we're looking for
0C0C | B0 1E    | BCS $1E     |         BCS TRY4B           ; ACMD >= $E8 indicates relative addressing
0C0E | 20 BF 0C | JSR $0CBF   |         JSR CHEK2B          ; ACMD < $E8 indicates normal addressing
0C11 | 88       | DEY         |         DEY                 ; consume byte
0C12 | D0 F1    | BNE $F1     |         BNE TRYAD           ; check for 2 more digits if not zero-page
0C14 | 0E 00 01 | ASL $0100   | TRYMOD: ASL ACMD            ; shift a bit out of the addressing command
0C17 | 90 0E    | BCC $0E     |         BCC UB4DF           ; if it's zero, skip checking current character
0C19 | BD 23 12 | LDA $1223,X |         LDA,X CHAR1-1
0C1C | 20 C2 0C | JSR $0CC2   |         JSR CHEKOP          ; otherwise first character against operand
0C1F | BD 29 12 | LDA $1229,X |         LDA,X CHAR2-1       ; get second character to check
0C22 | F0 03    | BEQ $03     |         BEQ UB4DF           ; if it's zero, skip checking it
0C24 | 20 C2 0C | JSR $0CC2   |         JSR CHEKOP          ; otherwise check it against hte operand
0C27 | CA       | DEX         | UB4DF:  DEX                 ; move to next character
0C28 | D0 D2    | BNE $D2     |         BNE TRYIT           ; repeat tests
0C2A | F0 06    | BEQ $06     |         BEQ TRYBRAN
0C2C | 20 BF 0C | JSR $0CBF   | TRY4B:  JSR CHEK2B          ; check for 4 digit address placeholder
0C2F | 20 BF 0C | JSR $0CBF   |         JSR CHEK2B          ;   by checking for 2 digits twice
0C32 | AD 2F 02 | LDA $022F   | TRYBRAN: LDA STORE           ; get number of bytes in assembly buffer
0C35 | CD 33 02 | CMP $0233   |         CMP U9F             ; more bytes left to check?
0C38 | F0 03    | BEQ $03     |         BEQ ABRAN           ; if not, we've found a match; build instruction
0C3A | 4C CF 0C | JMP $0CCF   |         JMP BUMPOP          ; if so, this opcode doesn't match; try the next
0C3D |          |             | 
0C3D |          |             | ; convert branches to relative address
0C3D | AC 01 01 | LDY $0101   | ABRAN:  LDY LENGTH          ; get number of bytes in operand
0C40 | F0 32    | BEQ $32     |         BEQ A1BYTE          ; if none, just output the opcode
0C42 | AD 30 02 | LDA $0230   |         LDA STORE+1         ; otherwise check the address format
0C45 | C9 9D    | CMP #$9D    |         CMP.# $9D            ; is it a relative branch?
0C47 | D0 23    | BNE $23     |         BNE OBJPUT          ; if not, skip relative branch calculation
0C49 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; calculate the difference between the current
0C4B | E5 C3    | SBC $C3     |         SBC.zp TMP2            ;   address and the branch target (low byte)
0C4D | AA       | TAX         |         TAX                 ; save it in X
0C4E | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; borrow from the high byte if necessary
0C50 | E5 C4    | SBC $C4     |         SBC.zp TMP2+1
0C52 | 90 08    | BCC $08     |         BCC ABBACK          ; if result is negative, we're branching back
0C54 | D0 66    | BNE $66     |         BNE SERROR          ; high bytes must be equal when branching forward
0C56 | E0 82    | CPX #$82    |         CPX.# $82            ; difference between low bytes must be < 130
0C58 | B0 62    | BCS $62     |         BCS SERROR          ; error if the address is too far away
0C5A | 90 08    | BCC $08     |         BCC ABRANX
0C5C | A8       | TAY         | ABBACK: TAY                 ; when branching backward high byte of target must
0C5D | C8       | INY         |         INY                 ;   be 1 less than high byte of current address
0C5E | D0 5C    | BNE $5C     |         BNE SERROR          ; if not, it's too far away
0C60 | E0 82    | CPX #$82    |         CPX.# $82            ; difference between low bytes must be < 130
0C62 | 90 58    | BCC $58     |         BCC SERROR          ; if not, it's too far away
0C64 | CA       | DEX         | ABRANX: DEX                 ; adjust branch target relative to the 
0C65 | CA       | DEX         |         DEX                 ;   instruction following this one
0C66 | 8A       | TXA         |         TXA
0C67 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; load length of operand
0C6A | D0 03    | BNE $03     |         BNE OBJP2           ; don't use the absolute address
0C6C |          |             | 
0C6C |          |             | ; assemble machine code
0C6C | B9 C0 00 | LDA $00C0,Y | OBJPUT: LDA,Y TMP0-1        ; get the operand
0C6F | 91 C3    | STA ($C3),Y | OBJP2:  STA.i,Y TMP2        ; store it after the opcode
0C71 | 88       | DEY         |         DEY
0C72 | D0 F8    | BNE $F8     |         BNE OBJPUT          ; copy the other byte of operand if there is one
0C74 | AD 06 01 | LDA $0106   | A1BYTE: LDA OPCODE          ; put opcode into instruction
0C77 | 91 C3    | STA ($C3),Y |         STA.i,Y TMP2
0C79 | 20 EA 0E | JSR $0EEA   |         JSR CRLF            ; carriage return
0C7C | A9 91    | LDA #$91    |         LDA.# $91            ; back up one line
0C7E | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0C81 | A0 2E    | LDY #$2E    |         LDY.# MSG7-MSGBAS    ; "A " prefix
0C83 | 20 7E 11 | JSR $117E   |         JSR SNDCLR          ; clear line
0C86 | 20 1D 0D | JSR $0D1D   |         JSR DISLIN          ; disassemble the instruction we just assembled
0C89 | EE 01 01 | INC $0101   |         INC LENGTH          ; instruction length = operand length + 1 byte
0C8C | AD 01 01 | LDA $0101   |         LDA LENGTH          ;   for the opcode
0C8F | 20 84 0F | JSR $0F84   |         JSR BUMPAD2         ; increment address by length of instruction
0C92 | A9 41    | LDA #$41    |         LDA.# 'A'            ; stuff keyboard buffer with next assemble command:
0C94 | 8D 77 02 | STA $0277   |         STA KEYD            ;   "A XXXX " where XXXX is the next address
0C97 | A9 20    | LDA #$20    |         LDA.# ' '            ;   after the previously assembled instruction
0C99 | 8D 78 02 | STA $0278   |         STA KEYD+1
0C9C | 8D 7D 02 | STA $027D   |         STA KEYD+6
0C9F | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ; convert high byte of next address to hex
0CA1 | 20 13 0F | JSR $0F13   |         JSR ASCTWO
0CA4 | 8D 79 02 | STA $0279   |         STA KEYD+2          ; put it in the keyboard buffer
0CA7 | 8E 7A 02 | STX $027A   |         STX KEYD+3
0CAA | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; convert low byte of next address to hex
0CAC | 20 13 0F | JSR $0F13   |         JSR ASCTWO
0CAF | 8D 7B 02 | STA $027B   |         STA KEYD+4          ; put it in the keyboard buffer
0CB2 | 8E 7C 02 | STX $027C   |         STX KEYD+5
0CB5 | A9 07    | LDA #$07    |         LDA.# 7              ; set number of chars in keyboard buffer
0CB7 | 85 C6    | STA $C6     |         STA.zp NDX
0CB9 | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to main loop
0CBC | 4C 9D 08 | JMP $089D   | SERROR: JMP ERROR           ; handle error
0CBF |          |             | 
0CBF |          |             | ; check characters in operand
0CBF | 20 C2 0C | JSR $0CC2   | CHEK2B: JSR CHEKOP          ; check two bytes against value in accumulator
0CC2 | 8E 05 01 | STX $0105   | CHEKOP: STX SAVX            ; stash X
0CC5 | AE 33 02 | LDX $0233   |         LDX U9F             ; get current index into work buffer
0CC8 | DD 0D 01 | CMP $010D,X |         CMP,X U0AA0         ; check whether this opcode matches the buffer
0CCB | F0 0A    | BEQ $0A     |         BEQ OPOK            ;   matching so far, check the next criteria
0CCD | 68       | PLA         |         PLA                 ; didn't match, so throw away return address
0CCE | 68       | PLA         |         PLA                 ;   on the stack because we're starting over
0CCF | EE 06 01 | INC $0106   | BUMPOP: INC OPCODE          ; check the next opcode
0CD2 | F0 E8    | BEQ $E8     |         BEQ SERROR          ; error if we tried every opcode and none fit
0CD4 | 4C DC 0B | JMP $0BDC   |         JMP ATRYOP          ; start over with new opcode
0CD7 | EE 33 02 | INC $0233   | OPOK:   INC U9F             ; opcode matches so far; check the next criteria
0CDA | AE 05 01 | LDX $0105   |         LDX SAVX            ; restore X
0CDD | 60       | RTS         |         RTS
0CDE |          |             | 
0CDE |          |             | ; -----------------------------------------------------------------------------
0CDE |          |             | ; disassemble [D]
0CDE | B0 08    | BCS $08     | DISASS: BCS DIS0AD          ; if no address was given, start from last address
0CE0 | 20 45 0F | JSR $0F45   |         JSR COPY12          ; copy start address to TMP2
0CE3 | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get end address in TMP0
0CE6 | 90 06    | BCC $06     |         BCC DIS2AD          ; if one was given, skip default
0CE8 | A9 14    | LDA #$14    | DIS0AD: LDA.# $14            ; disassemble 14 bytes by default
0CEA | 85 C1    | STA $C1     |         STA.zp TMP0            ; store length in TMP0
0CEC | D0 05    | BNE $05     |         BNE DISGO           ; skip length calculation
0CEE | 20 4E 0F | JSR $0F4E   | DIS2AD: JSR SUB12           ; calculate number of bytes between start and end
0CF1 | 90 1F    | BCC $1F     |         BCC DERROR          ; error if end address is before start address
0CF3 | 20 78 11 | JSR $1178   | DISGO:  JSR CLINE           ; clear the current line
0CF6 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
0CF9 | F0 14    | BEQ $14     |         BEQ DISEXIT         ; exit early if pressed
0CFB | 20 15 0D | JSR $0D15   |         JSR DSOUT1          ; output disassembly prefix ". "
0CFE | EE 01 01 | INC $0101   |         INC LENGTH
0D01 | AD 01 01 | LDA $0101   |         LDA LENGTH          ; add length of last instruction to start address
0D04 | 20 84 0F | JSR $0F84   |         JSR BUMPAD2
0D07 | AD 01 01 | LDA $0101   |         LDA LENGTH          ; subtract length of last inst from end address
0D0A | 20 5E 0F | JSR $0F5E   |         JSR SUBA2
0D0D | B0 E4    | BCS $E4     |         BCS DISGO
0D0F | 4C 6E 08 | JMP $086E   | DISEXIT: JMP STRT            ; back to mainloop
0D12 | 4C 9D 08 | JMP $089D   | DERROR: JMP ERROR
0D15 |          |             | 
0D15 | A9 2E    | LDA #$2E    | DSOUT1: LDA.# '.'            ; output ". " prefix to allow edit and reassemble
0D17 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0D1A | 20 E2 0E | JSR $0EE2   |         JSR SPACE
0D1D |          |             | 
0D1D | 20 D5 0E | JSR $0ED5   | DISLIN: JSR SHOWAD          ; show the address of the instruction
0D20 | 20 E2 0E | JSR $0EE2   |         JSR SPACE           ; insert a space
0D23 | A0 00    | LDY #$00    |         LDY.# 0              ; no offset
0D25 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; load operand of current instruction
0D27 | 20 9B 0D | JSR $0D9B   |         JSR INSTXX          ; get mnemonic and addressing mode for opcode
0D2A | 48       | PHA         |         PHA                 ; save index into mnemonic table
0D2B | AE 01 01 | LDX $0101   |         LDX LENGTH          ; get length of operand
0D2E | E8       | INX         |         INX                 ; add 1 byte for opcode
0D2F | CA       | DEX         | DSBYT:  DEX                 ; decrement index
0D30 | 10 0E    | BPL $0E     |         BPL DSHEX           ; show hex for byte being disassembled
0D32 | 8C 32 02 | STY $0232   |         STY SAVY            ; save index
0D35 | A0 30    | LDY #$30    |         LDY.# MSG8-MSGBAS    ; skip 3 spaces
0D37 | 20 91 11 | JSR $1191   |         JSR SNDMSG
0D3A | AC 32 02 | LDY $0232   |         LDY SAVY            ; restore index
0D3D | 4C 45 0D | JMP $0D45   |         JMP NXBYT
0D40 | B1 C3    | LDA ($C3),Y | DSHEX:  LDA.i,Y TMP2        ; show hex for byte
0D42 | 20 DF 0E | JSR $0EDF   |         JSR WRBYTE
0D45 |          |             | 
0D45 | C8       | INY         | NXBYT:  INY                 ; next byte
0D46 | C0 03    | CPY #$03    |         CPY.# 3              ; have we output 3 bytes yet?
0D48 | 90 E5    | BCC $E5     |         BCC DSBYT           ; if not, loop
0D4A | 68       | PLA         |         PLA                 ; restore index into mnemonic table
0D4B | A2 03    | LDX #$03    |         LDX.# 3              ; 3 letters in mnemonic
0D4D | 20 E3 0D | JSR $0DE3   |         JSR PROPXX          ; print mnemonic
0D50 | A2 06    | LDX #$06    |         LDX.# 6              ; 6 possible address mode character combos
0D52 | E0 03    | CPX #$03    | PRADR1: CPX.# 3              ; have we checked the third combo yet?
0D54 | D0 16    | BNE $16     |         BNE PRADR3          ; if so, output the leading characters
0D56 | AC 01 01 | LDY $0101   |         LDY LENGTH          ; get the length of the operand
0D59 | F0 11    | BEQ $11     |         BEQ PRADR3          ; if it's zero, there's no operand to print
0D5B | AD 00 01 | LDA $0100   | PRADR2: LDA ACMD            ; otherwise, get the addressing mode
0D5E | C9 E8    | CMP #$E8    |         CMP.# $E8            ; check for relative addressing
0D60 | 08       | PHP         |         PHP                 ; save result of check
0D61 | B1 C3    | LDA ($C3),Y |         LDA.i,Y TMP2        ; get the operand
0D63 | 28       | PLP         |         PLP                 ; restore result of check
0D64 | B0 1D    | BCS $1D     |         BCS RELAD           ; handle a relative address
0D66 | 20 03 0F | JSR $0F03   |         JSR WRTWO           ; output digits from address
0D69 | 88       | DEY         |         DEY
0D6A | D0 EF    | BNE $EF     |         BNE PRADR2          ; repeat for next byte of operand, if there is one
0D6C | 0E 00 01 | ASL $0100   | PRADR3: ASL ACMD            ; check whether addr mode uses the current char
0D6F | 90 0E    | BCC $0E     |         BCC PRADR4          ; if not, skip it
0D71 | BD 23 12 | LDA $1223,X |         LDA,X CHAR1-1       ; look up the first char in the table
0D74 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print first char
0D77 | BD 29 12 | LDA $1229,X |         LDA,X CHAR2-1       ; look up the second char in the table
0D7A | F0 03    | BEQ $03     |         BEQ PRADR4          ; if there's no second character, skip it
0D7C | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print second char
0D7F | CA       | DEX         | PRADR4: DEX                 ; next potential address mode character
0D80 | D0 D0    | BNE $D0     |         BNE PRADR1          ; loop if we haven't checked them all yet
0D82 | 60       | RTS         |         RTS                 ; back to caller
0D83 | 20 8F 0D | JSR $0D8F   | RELAD:  JSR UB64D           ; calculate absolute address from relative
0D86 | 18       | CLC         |         CLC
0D87 | 69 01    | ADC #$01    |         ADC.# 1              ; adjust address relative to next instruction
0D89 | D0 01    | BNE $01     |         BNE RELEND          ; don't increment high byte unless we overflowed
0D8B | E8       | INX         |         INX                 ; increment high byte
0D8C | 4C D9 0E | JMP $0ED9   | RELEND: JMP WRADDR          ; print address
0D8F |          |             | 
0D8F | A6 C4    | LDX $C4     | UB64D:  LDX.zp TMP2+1          ; get high byte of current address
0D91 | A8       | TAY         |         TAY                 ; is relative address positive or negative?
0D92 | 10 01    | BPL $01     |         BPL RELC2           ; if positive, leave high byte alone
0D94 | CA       | DEX         |         DEX                 ; if negative, decrement high byte
0D95 | 65 C3    | ADC $C3     | RELC2:  ADC.zp TMP2            ; add relative address to low byte
0D97 | 90 01    | BCC $01     |         BCC RELC3           ; if there's no carry, we're done
0D99 | E8       | INX         |         INX                 ; if there's a carry, increment the high byte
0D9A | 60       | RTS         | RELC3:  RTS
0D9B |          |             | 
0D9B |          |             | ; -----------------------------------------------------------------------------
0D9B |          |             | ; get opcode mode and length
0D9B |          |             | 
0D9B |          |             | ; Note: the labels are different, but the code of this subroutine is almost
0D9B |          |             | ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
0D9B |          |             | ; the Apple II Red Book. I'm not sure exactly where this code originated
0D9B |          |             | ; (MOS or Apple) but it's clear that this part of Supermon64 and the 
0D9B |          |             | ; Mini-Asssembler share a common heritage.  The comments showing the way the 
0D9B |          |             | ; opcodes are transformed into indexes for the mnemonic lookup table come
0D9B |          |             | ; from the Mini-Assembler source.
0D9B |          |             | 
0D9B | A8       | TAY         | INSTXX: TAY                 ; stash opcode in accumulator in Y for later
0D9C | 4A       | LSR A       |         LSR.A               ; is opcode even or odd?
0D9D | 90 0B    | BCC $0B     |         BCC IEVEN
0D9F | 4A       | LSR A       |         LSR.A
0DA0 | B0 17    | BCS $17     |         BCS ERR             ; invalid opcodes XXXXXX11
0DA2 | C9 22    | CMP #$22    |         CMP.# $22
0DA4 | F0 13    | BEQ $13     |         BEQ ERR             ; invalid opcode 10001001
0DA6 | 29 07    | AND #$07    |         AND.# $07            ; mask bits to 10000XXX
0DA8 | 09 80    | ORA #$80    |         ORA.# $80
0DAA | 4A       | LSR A       | IEVEN:  LSR.A               ; LSB determines whether to use left/right nybble
0DAB | AA       | TAX         |         TAX                 ; get format index using remaining high bytes
0DAC | BD D2 11 | LDA $11D2,X |         LDA,X MODE
0DAF | B0 04    | BCS $04     |         BCS RTMODE          ; look at left or right nybble based on carry bit
0DB1 | 4A       | LSR A       |         LSR.A               ; if carry = 0, use left nybble
0DB2 | 4A       | LSR A       |         LSR.A
0DB3 | 4A       | LSR A       |         LSR.A
0DB4 | 4A       | LSR A       |         LSR.A
0DB5 | 29 0F    | AND #$0F    | RTMODE: AND.# $0F            ; if carry = 1, use right nybble
0DB7 | D0 04    | BNE $04     |         BNE GETFMT
0DB9 | A0 80    | LDY #$80    | ERR:    LDY.# $80            ; substitute 10000000 for invalid opcodes
0DBB | A9 00    | LDA #$00    |         LDA.# 0
0DBD | AA       | TAX         | GETFMT: TAX
0DBE | BD 16 12 | LDA $1216,X |         LDA,X MODE2         ; lookup operand format using selected nybble
0DC1 | 8D 00 01 | STA $0100   |         STA ACMD            ; save for later use
0DC4 | 29 03    | AND #$03    |         AND.# $03            ; lower 2 bits indicate number of bytes in operand
0DC6 | 8D 01 01 | STA $0101   |         STA LENGTH
0DC9 | 98       | TYA         |         TYA                 ; restore original opcode
0DCA | 29 8F    | AND #$8F    |         AND.# $8F            ; mask bits to X000XXXX
0DCC | AA       | TAX         |         TAX                 ; save it
0DCD | 98       | TYA         |         TYA                 ; restore original opcode
0DCE | A0 03    | LDY #$03    |         LDY.# 3
0DD0 | E0 8A    | CPX #$8A    |         CPX.# $8A            ; check if opcode = 1XXX1010
0DD2 | F0 0B    | BEQ $0B     |         BEQ GTFM4
0DD4 | 4A       | LSR A       | GTFM2:  LSR.A               ; transform opcode into index for mnemonic table
0DD5 | 90 08    | BCC $08     |         BCC GTFM4
0DD7 | 4A       | LSR A       |         LSR.A               ; opcodes transformed as follows:
0DD8 | 4A       | LSR A       | GTFM3:  LSR.A               ; 1XXX1010->00101XXX
0DD9 | 09 20    | ORA #$20    |         ORA.# $20            ; XXXYYY01->00111XXX
0DDB | 88       | DEY         |         DEY                 ; XXXYYY10->00111XXX
0DDC | D0 FA    | BNE $FA     |         BNE GTFM3           ; XXXYY100->00110XXX
0DDE | C8       | INY         |         INY                 ; XXXXX000->000XXXXX
0DDF | 88       | DEY         | GTFM4:  DEY
0DE0 | D0 F2    | BNE $F2     |         BNE GTFM2
0DE2 | 60       | RTS         |         RTS
0DE3 |          |             | 
0DE3 |          |             | ; -----------------------------------------------------------------------------
0DE3 |          |             | ; extract and print packed mnemonics
0DE3 | A8       | TAY         | PROPXX: TAY                 ; use index in accumulator to look up mnemonic
0DE4 | B9 30 12 | LDA $1230,Y |         LDA,Y MNEML         ;   and place a temporary copy in STORE
0DE7 | 8D 2F 02 | STA $022F   |         STA STORE
0DEA | B9 70 12 | LDA $1270,Y |         LDA,Y MNEMR
0DED | 8D 30 02 | STA $0230   |         STA STORE+1
0DF0 | A9 00    | LDA #$00    | PRMN1:  LDA.# 0              ; clear accumulator
0DF2 | A0 05    | LDY #$05    |         LDY.# $05            ; shift 5 times
0DF4 | 0E 30 02 | ASL $0230   | PRMN2:  ASL STORE+1         ; shift right byte
0DF7 | 2E 2F 02 | ROL $022F   |         ROL STORE           ; rotate bits from right byte into left byte
0DFA | 2A       | ROL A       |         ROL.A               ; rotate bits from left byte into accumulator
0DFB | 88       | DEY         |         DEY                 ; next bit
0DFC | D0 F6    | BNE $F6     |         BNE PRMN2           ; loop until all bits shifted
0DFE | 69 3F    | ADC #$3F    |         ADC.# $3F            ; calculate ascii code for letter by adding to '?'
0E00 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output letter
0E03 | CA       | DEX         |         DEX                 ; next letter
0E04 | D0 EA    | BNE $EA     |         BNE PRMN1           ; loop until all 3 letters are output
0E06 | 4C E2 0E | JMP $0EE2   |         JMP SPACE           ; output space
0E09 |          |             | 
0E09 |          |             | ; -----------------------------------------------------------------------------
0E09 |          |             | ; read parameters
0E09 | CE 31 02 | DEC $0231   | RDPAR:  DEC CHRPNT          ; back up one char
0E0C | 20 34 0E | JSR $0E34   | GETPAR: JSR RDVAL           ; read the value
0E0F | B0 17    | BCS $17     |         BCS GTERR           ; carry set indicates error
0E11 | 20 28 0F | JSR $0F28   |         JSR GOTCHR          ; check previous character
0E14 | D0 0A    | BNE $0A     |         BNE CKTERM          ; if it's not null, check if it's a valid separator
0E16 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up one char
0E19 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; get number of digits read
0E1C | D0 11    | BNE $11     |         BNE GETGOT          ; found some digits
0E1E | F0 0D    | BEQ $0D     |         BEQ GTNIL           ; didn't find any digits
0E20 | C9 20    | CMP #$20    | CKTERM: CMP.# $20            ; space or comma are valid separators
0E22 | F0 0B    | BEQ $0B     |         BEQ GETGOT          ; anything else is an error
0E24 | C9 2C    | CMP #$2C    |         CMP.# ','
0E26 | F0 07    | BEQ $07     |         BEQ GETGOT
0E28 | 68       | PLA         | GTERR:  PLA                 ; encountered error
0E29 | 68       | PLA         |         PLA                 ; get rid of command vector pushed on stack
0E2A | 4C 9D 08 | JMP $089D   |         JMP ERROR           ; handle error
0E2D | 38       | SEC         | GTNIL:  SEC                 ; set carry to indicate no parameter found
0E2E | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (CLC)
0E2F | 18       | CLC         | GETGOT: CLC                 ; clear carry to indicate paremeter returned
0E30 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; return number of digits in A
0E33 | 60       | RTS         |         RTS                 ; return to address pushed from vector table
0E34 |          |             | 
0E34 |          |             | ; -----------------------------------------------------------------------------
0E34 |          |             | ; read a value in the specified base
0E34 | A9 00    | LDA #$00    | RDVAL:  LDA.# 0              ; clear temp
0E36 | 85 C1    | STA $C1     |         STA.zp TMP0
0E38 | 85 C2    | STA $C2     |         STA.zp TMP0+1
0E3A | 8D 08 01 | STA $0108   |         STA DIGCNT          ; clear digit counter
0E3D | 8A       | TXA         |         TXA                 ; save X and Y
0E3E | 48       | PHA         |         PHA
0E3F | 98       | TYA         |         TYA
0E40 | 48       | PHA         |         PHA
0E41 | 20 2B 0F | JSR $0F2B   | RDVMOR: JSR GETCHR          ; get next character from input buffer
0E44 | F0 1E    | BEQ $1E     |         BEQ RDNILK          ; null at end of buffer
0E46 | C9 20    | CMP #$20    |         CMP.# $20            ; skip spaces
0E48 | F0 F7    | BEQ $F7     |         BEQ RDVMOR
0E4A | A2 03    | LDX #$03    |         LDX.# 3              ; check numeric base [$+&%]
0E4C | DD C3 12 | CMP $12C3,X | GNMODE: CMP,X HIKEY
0E4F | F0 07    | BEQ $07     |         BEQ GOTMOD          ; got a match, set up base
0E51 | CA       | DEX         |         DEX
0E52 | 10 F8    | BPL $F8     |         BPL GNMODE          ; check next base
0E54 | E8       | INX         |         INX                 ; default to hex
0E55 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up one character
0E58 | BC E8 12 | LDY $12E8,X | GOTMOD: LDY,X MODTAB        ; get base value
0E5B | BD EC 12 | LDA $12EC,X |         LDA,X LENTAB        ; get bits per digit
0E5E | 8D 0A 01 | STA $010A   |         STA NUMBIT          ; store bits per digit 
0E61 | 20 2B 0F | JSR $0F2B   | NUDIG:  JSR GETCHR          ; get next char in A
0E64 | F0 63    | BEQ $63     | RDNILK: BEQ RDNIL           ; end of number if no more characters
0E66 | 38       | SEC         |         SEC
0E67 | E9 30    | SBC #$30    |         SBC.# $30            ; subtract ascii value of 0 to get numeric value
0E69 | 90 5E    | BCC $5E     |         BCC RDNIL           ; end of number if character was less than 0
0E6B | C9 0A    | CMP #$0A    |         CMP.# $0A
0E6D | 90 06    | BCC $06     |         BCC DIGMOR          ; not a hex digit if less than A
0E6F | E9 07    | SBC #$07    |         SBC.# $07            ; 7 chars between ascii 9 and A, so subtract 7
0E71 | C9 10    | CMP #$10    |         CMP.# $10            ; end of number if char is greater than F
0E73 | B0 54    | BCS $54     |         BCS RDNIL
0E75 | 8D 09 01 | STA $0109   | DIGMOR: STA INDIG           ; store the digit
0E78 | CC 09 01 | CPY $0109   |         CPY INDIG           ; compare base with the digit
0E7B | 90 4A    | BCC $4A     |         BCC RDERR           ; error if the digit >= the base
0E7D | F0 48    | BEQ $48     |         BEQ RDERR
0E7F | EE 08 01 | INC $0108   |         INC DIGCNT          ; increment the number of digits
0E82 | C0 0A    | CPY #$0A    |         CPY.# 10
0E84 | D0 0A    | BNE $0A     |         BNE NODECM          ; skip the next part if not using base 10
0E86 | A2 01    | LDX #$01    |         LDX.# 1
0E88 | B5 C1    | LDA $C1,X   | DECLP1: LDA.zp,X TMP0          ; stash the previous 16-bit value for later use
0E8A | 9D 0B 01 | STA $010B,X |         STA,X STASH
0E8D | CA       | DEX         |         DEX
0E8E | 10 F8    | BPL $F8     |         BPL DECLP1
0E90 | AE 0A 01 | LDX $010A   | NODECM: LDX NUMBIT          ; number of bits to shift
0E93 | 06 C1    | ASL $C1     | TIMES2: ASL.zp TMP0            ; shift 16-bit value by specified number of bits
0E95 | 26 C2    | ROL $C2     |         ROL.zp TMP0+1
0E97 | B0 2E    | BCS $2E     |         BCS RDERR           ; error if we overflowed 16 bits
0E99 | CA       | DEX         |         DEX
0E9A | D0 F7    | BNE $F7     |         BNE TIMES2          ; shift remaining bits
0E9C | C0 0A    | CPY #$0A    |         CPY.# 10
0E9E | D0 18    | BNE $18     |         BNE NODEC2          ; skip the next part if not using base 10
0EA0 | 0E 0B 01 | ASL $010B   |         ASL STASH           ; shift the previous 16-bit value one bit left
0EA3 | 2E 0C 01 | ROL $010C   |         ROL STASH+1
0EA6 | B0 1F    | BCS $1F     |         BCS RDERR           ; error if we overflowed 16 bits
0EA8 | AD 0B 01 | LDA $010B   |         LDA STASH           ; add shifted previous value to current value
0EAB | 65 C1    | ADC $C1     |         ADC.zp TMP0
0EAD | 85 C1    | STA $C1     |         STA.zp TMP0
0EAF | AD 0C 01 | LDA $010C   |         LDA STASH+1
0EB2 | 65 C2    | ADC $C2     |         ADC.zp TMP0+1
0EB4 | 85 C2    | STA $C2     |         STA.zp TMP0+1
0EB6 | B0 0F    | BCS $0F     |         BCS RDERR           ; error if we overflowed 16 bits
0EB8 | 18       | CLC         | NODEC2: CLC 
0EB9 | AD 09 01 | LDA $0109   |         LDA INDIG           ; load current digit
0EBC | 65 C1    | ADC $C1     |         ADC.zp TMP0            ; add current digit to low byte
0EBE | 85 C1    | STA $C1     |         STA.zp TMP0            ; and store result back in low byte
0EC0 | 8A       | TXA         |         TXA                 ; A=0
0EC1 | 65 C2    | ADC $C2     |         ADC.zp TMP0+1          ; add carry to high byte
0EC3 | 85 C2    | STA $C2     |         STA.zp TMP0+1          ; and store result back in high byte
0EC5 | 90 9A    | BCC $9A     |         BCC NUDIG           ; get next digit if we didn't overflow
0EC7 | 38       | SEC         | RDERR:  SEC                 ; set carry to indicate error
0EC8 | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (CLC)
0EC9 | 18       | CLC         | RDNIL:  CLC                 ; clear carry to indicate success
0ECA | 8C 0A 01 | STY $010A   |         STY NUMBIT          ; save base of number
0ECD | 68       | PLA         |         PLA                 ; restore X and Y
0ECE | A8       | TAY         |         TAY
0ECF | 68       | PLA         |         PLA
0ED0 | AA       | TAX         |         TAX
0ED1 | AD 08 01 | LDA $0108   |         LDA DIGCNT          ; return number of digits in A
0ED4 | 60       | RTS         |         RTS
0ED5 |          |             | 
0ED5 |          |             | ; -----------------------------------------------------------------------------
0ED5 |          |             | ; print address
0ED5 | A5 C3    | LDA $C3     | SHOWAD: LDA.zp TMP2
0ED7 | A6 C4    | LDX $C4     |         LDX.zp TMP2+1
0ED9 |          |             | 
0ED9 | 48       | PHA         | WRADDR: PHA                 ; save low byte
0EDA | 8A       | TXA         |         TXA                 ; put high byte in A
0EDB | 20 03 0F | JSR $0F03   |         JSR WRTWO           ; output high byte
0EDE | 68       | PLA         |         PLA                 ; restore low byte
0EDF |          |             | 
0EDF | 20 03 0F | JSR $0F03   | WRBYTE: JSR WRTWO           ; output byte in A
0EE2 |          |             | 
0EE2 | A9 20    | LDA #$20    | SPACE:  LDA.# $20            ; output space
0EE4 | D0 0F    | BNE $0F     |         BNE FLIP
0EE6 |          |             | 
0EE6 | C9 0D    | CMP #$0D    | CHOUT:  CMP.# $0D            ; output char with special handling of CR
0EE8 | D0 0B    | BNE $0B     |         BNE FLIP
0EEA | A9 0D    | LDA #$0D    | CRLF:   LDA.# $0D            ; load CR in A
0EEC | 24 13    | BIT $13     |         BIT.zp $13             ; check default channel
0EEE | 10 05    | BPL $05     |         BPL FLIP            ; if high bit is clear output CR only
0EF0 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; otherwise output CR+LF
0EF3 | A9 0A    | LDA #$0A    |         LDA.# $0A            ; output LF
0EF5 | 4C D2 FF | JMP $FFD2   | FLIP:   JMP CHROUT
0EF8 |          |             | 
0EF8 | 20 EA 0E | JSR $0EEA   | FRESH:  JSR CRLF            ; output CR
0EFB | A9 20    | LDA #$20    |         LDA.# $20            ; load space in A
0EFD | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0F00 | 4C 81 11 | JMP $1181   |         JMP SNCLR
0F03 |          |             | 
0F03 |          |             | ; -----------------------------------------------------------------------------
0F03 |          |             | ; output two hex digits for byte
0F03 | 8E 05 01 | STX $0105   | WRTWO:  STX SAVX            ; save X
0F06 | 20 13 0F | JSR $0F13   |         JSR ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
0F09 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output upper nybble
0F0C | 8A       | TXA         |         TXA                 ; transfer lower to A
0F0D | AE 05 01 | LDX $0105   |         LDX SAVX            ; restore X
0F10 | 4C D2 FF | JMP $FFD2   |         JMP CHROUT          ; output lower nybble
0F13 |          |             | 
0F13 |          |             | ; -----------------------------------------------------------------------------
0F13 |          |             | ; convert byte in A to hex digits
0F13 | 48       | PHA         | ASCTWO: PHA                 ; save byte
0F14 | 20 1D 0F | JSR $0F1D   |         JSR ASCII           ; do low nybble
0F17 | AA       | TAX         |         TAX                 ; save in X
0F18 | 68       | PLA         |         PLA                 ; restore byte
0F19 | 4A       | LSR A       |         LSR.A               ; shift upper nybble down
0F1A | 4A       | LSR A       |         LSR.A
0F1B | 4A       | LSR A       |         LSR.A
0F1C | 4A       | LSR A       |         LSR.A
0F1D |          |             | 
0F1D |          |             | ; convert low nybble in A to hex digit
0F1D | 29 0F    | AND #$0F    | ASCII:  AND.# $0F            ; clear upper nibble
0F1F | C9 0A    | CMP #$0A    |         CMP.# $0A            ; if less than A, skip next step
0F21 | 90 02    | BCC $02     |         BCC ASC1
0F23 | 69 06    | ADC #$06    |         ADC.# 6              ; skip ascii chars between 9 and A
0F25 | 69 30    | ADC #$30    | ASC1:   ADC.# $30            ; add ascii char 0 to value
0F27 | 60       | RTS         |         RTS
0F28 |          |             | 
0F28 |          |             | ; -----------------------------------------------------------------------------
0F28 |          |             | ; get prev char from input buffer
0F28 | CE 31 02 | DEC $0231   | GOTCHR: DEC CHRPNT
0F2B |          |             | 
0F2B |          |             | ; get next char from input buffer
0F2B | 8E 05 01 | STX $0105   | GETCHR: STX SAVX
0F2E | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; get pointer to next char
0F31 | BD 00 02 | LDA $0200,X |         LDA,X INBUFF        ; load next char in A
0F34 | F0 06    | BEQ $06     |         BEQ NOCHAR          ; null, :, or ? signal end of buffer
0F36 | C9 3A    | CMP #$3A    |         CMP.# ':'        
0F38 | F0 02    | BEQ $02     |         BEQ NOCHAR
0F3A | C9 3F    | CMP #$3F    |         CMP.# '?'
0F3C | 08       | PHP         | NOCHAR: PHP
0F3D | EE 31 02 | INC $0231   |         INC CHRPNT          ; next char
0F40 | AE 05 01 | LDX $0105   |         LDX SAVX
0F43 | 28       | PLP         |         PLP                 ; Z flag will signal last character
0F44 | 60       | RTS         |         RTS
0F45 |          |             | 
0F45 |          |             | ; -----------------------------------------------------------------------------
0F45 |          |             | ; copy TMP0 to TMP2
0F45 | A5 C1    | LDA $C1     | COPY12: LDA.zp TMP0            ; low byte
0F47 | 85 C3    | STA $C3     |         STA.zp TMP2
0F49 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; high byte
0F4B | 85 C4    | STA $C4     |         STA.zp TMP2+1
0F4D | 60       | RTS         |         RTS
0F4E |          |             | 
0F4E |          |             | ; -----------------------------------------------------------------------------
0F4E |          |             | ; subtract TMP2 from TMP0
0F4E | 38       | SEC         | SUB12:  SEC
0F4F | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; subtract low byte
0F51 | E5 C3    | SBC $C3     |         SBC.zp TMP2
0F53 | 85 C1    | STA $C1     |         STA.zp TMP0
0F55 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
0F57 | E5 C4    | SBC $C4     |         SBC.zp TMP2+1          ; subtract high byte
0F59 | 85 C2    | STA $C2     |         STA.zp TMP0+1
0F5B | 60       | RTS         |         RTS
0F5C |          |             | 
0F5C |          |             | ; -----------------------------------------------------------------------------
0F5C |          |             | ; subtract from TMP0
0F5C | A9 01    | LDA #$01    | SUBA1:  LDA.# 1              ; shortcut to decrement by 1
0F5E | 8D 05 01 | STA $0105   | SUBA2:  STA SAVX            ; subtrahend in accumulator
0F61 | 38       | SEC         |         SEC
0F62 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; minuend in low byte
0F64 | ED 05 01 | SBC $0105   |         SBC SAVX
0F67 | 85 C1    | STA $C1     |         STA.zp TMP0
0F69 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; borrow from high byte
0F6B | E9 00    | SBC #$00    |         SBC.# 0
0F6D | 85 C2    | STA $C2     |         STA.zp TMP0+1
0F6F | 60       | RTS         |         RTS
0F70 |          |             | 
0F70 |          |             | ; -----------------------------------------------------------------------------
0F70 |          |             | ; subtract 1 from STORE
0F70 | 38       | SEC         | SUB13:  SEC
0F71 | AD 2F 02 | LDA $022F   |         LDA STORE
0F74 | E9 01    | SBC #$01    |         SBC.# 1              ; decrement low byte
0F76 | 8D 2F 02 | STA $022F   |         STA STORE
0F79 | AD 30 02 | LDA $0230   |         LDA STORE+1
0F7C | E9 00    | SBC #$00    |         SBC.# 0              ; borrow from high byte
0F7E | 8D 30 02 | STA $0230   |         STA STORE+1
0F81 | 60       | RTS         |         RTS
0F82 |          |             | 
0F82 |          |             | ; -----------------------------------------------------------------------------
0F82 |          |             | ; add to TMP2
0F82 | A9 01    | LDA #$01    | ADDA2:  LDA.# 1              ; shortcut to increment by 1
0F84 | 18       | CLC         | BUMPAD2: CLC
0F85 | 65 C3    | ADC $C3     |         ADC.zp TMP2            ; add value in accumulator to low byte
0F87 | 85 C3    | STA $C3     |         STA.zp TMP2
0F89 | 90 02    | BCC $02     |         BCC BUMPEX
0F8B | E6 C4    | INC $C4     |         INC.zp TMP2+1          ; carry to high byte
0F8D | 60       | RTS         | BUMPEX: RTS 
0F8E |          |             | 
0F8E |          |             | ; -----------------------------------------------------------------------------
0F8E |          |             | ; subtract 1 from TMP2
0F8E | 38       | SEC         | SUB21:  SEC
0F8F | A5 C3    | LDA $C3     |         LDA.zp TMP2            ; decrement low byte
0F91 | E9 01    | SBC #$01    |         SBC.# 1
0F93 | 85 C3    | STA $C3     |         STA.zp TMP2
0F95 | A5 C4    | LDA $C4     |         LDA.zp TMP2+1          ; borrow from high byte
0F97 | E9 00    | SBC #$00    |         SBC.# 0
0F99 | 85 C4    | STA $C4     |         STA.zp TMP2+1
0F9B | 60       | RTS         |         RTS
0F9C |          |             | 
0F9C |          |             | ; -----------------------------------------------------------------------------
0F9C |          |             | ; copy TMP0 to PC
0F9C | B0 0A    | BCS $0A     | COPY1P: BCS CPY1PX          ; do nothing if parameter is empty
0F9E | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; copy low byte
0FA0 | A4 C2    | LDY $C2     |         LDY.zp TMP0+1          ; copy high byte
0FA2 | 8D 29 02 | STA $0229   |         STA PCL
0FA5 | 8C 28 02 | STY $0228   |         STY PCH
0FA8 | 60       | RTS         | CPY1PX: RTS 
0FA9 |          |             | 
0FA9 |          |             | ; -----------------------------------------------------------------------------
0FA9 |          |             | ; get start/end addresses and calc difference
0FA9 | B0 23    | BCS $23     | GETDIF: BCS GDIFX           ; exit with error if no parameter given
0FAB | 20 45 0F | JSR $0F45   |         JSR COPY12          ; save start address in TMP2
0FAE | 20 0C 0E | JSR $0E0C   |         JSR GETPAR          ; get end address in TMP0
0FB1 | B0 1B    | BCS $1B     |         BCS GDIFX           ; exit with error if no parameter given
0FB3 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; save end address in STASH
0FB5 | 8D 0B 01 | STA $010B   |         STA STASH
0FB8 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
0FBA | 8D 0C 01 | STA $010C   |         STA STASH+1
0FBD | 20 4E 0F | JSR $0F4E   |         JSR SUB12           ; subtract start address from end address
0FC0 | A5 C1    | LDA $C1     |         LDA.zp TMP0
0FC2 | 8D 2F 02 | STA $022F   |         STA STORE           ; save difference in STORE
0FC5 | A5 C2    | LDA $C2     |         LDA.zp TMP0+1
0FC7 | 8D 30 02 | STA $0230   |         STA STORE+1
0FCA | 90 02    | BCC $02     |         BCC GDIFX           ; error if start address is after end address
0FCC | 18       | CLC         |         CLC                 ; clear carry to indicate success
0FCD | 24       |             |         DATA.b $24           ; BIT ZP opcode consumes next byte (SEC)
0FCE | 38       | SEC         | GDIFX:  SEC                 ; set carry to indicate error
0FCF | 60       | RTS         |         RTS
0FD0 |          |             | 
0FD0 |          |             | ; -----------------------------------------------------------------------------
0FD0 |          |             | ; convert base [$+&%]
0FD0 | 20 09 0E | JSR $0E09   | CONVRT: JSR RDPAR           ; read a parameter
0FD3 | 20 F8 0E | JSR $0EF8   |         JSR FRESH           ; next line and clear
0FD6 | A9 24    | LDA #$24    |         LDA.#  $24;'$'            ; output $ sigil for hex
0FD8 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0FDB | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load the 16-bit value entered
0FDD | A6 C2    | LDX $C2     |         LDX.zp TMP0+1
0FDF | 20 D9 0E | JSR $0ED9   |         JSR WRADDR          ; print it in 4 hex digits
0FE2 | 20 F8 0E | JSR $0EF8   |         JSR FRESH
0FE5 | A9 2B    | LDA #$2B    |         LDA.# '+'            ; output + sigil for decimal
0FE7 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0FEA | 20 1B 10 | JSR $101B   |         JSR CVTDEC          ; convert to BCD using hardware mode
0FED | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
0FEF | A2 06    | LDX #$06    |         LDX.# 6              ; max digits + 1
0FF1 | A0 03    | LDY #$03    |         LDY.# 3              ; bits per digit - 1
0FF3 | 20 55 10 | JSR $1055   |         JSR NMPRNT          ; print result without leading zeros
0FF6 | 20 F8 0E | JSR $0EF8   |         JSR FRESH           ; next line and clear
0FF9 | A9 26    | LDA #$26    |         LDA.# $26 ;'&'            ; print & sigil for octal
0FFB | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
0FFE | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
1000 | A2 08    | LDX #$08    |         LDX.# 8              ; max digits + 1
1002 | A0 02    | LDY #$02    |         LDY.# 2              ; bits per digit - 1
1004 | 20 44 10 | JSR $1044   |         JSR PRINUM          ; output number
1007 | 20 F8 0E | JSR $0EF8   |         JSR FRESH           ; next line and clear
100A | A9 25    | LDA #$25    |         LDA.# '%'            ; print % sigil for binary
100C | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
100F | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit counter
1011 | A2 18    | LDX #$18    |         LDX.# $18            ; max digits + 1
1013 | A0 00    | LDY #$00    |         LDY.# 0              ; bits per digit - 1
1015 | 20 44 10 | JSR $1044   |         JSR PRINUM          ; output number
1018 | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to mainloop
101B |          |             | 
101B |          |             | ; -----------------------------------------------------------------------------
101B |          |             | ; convert binary to BCD
101B |          |             | 
101B | 20 45 0F | JSR $0F45   | CVTDEC: JSR COPY12          ; copy value from TMP0 to TMP2
101E | A9 00    | LDA #$00    |         LDA.# 0
1020 | A2 02    | LDX #$02    |         LDX.# 2              ; clear 3 bytes in work buffer
1022 | 9D 0D 01 | STA $010D,X | DECML1: STA,X U0AA0
1025 | CA       | DEX         |         DEX
1026 | 10 FA    | BPL $FA     |         BPL DECML1
1028 | A0 10    | LDY #$10    |         LDY.# 16             ; 16 bits in input
102A | 08       | PHP         |         PHP                 ; save status register
102B | 78       | SEI         |         SEI                 ; make sure no interrupts occur with BCD enabled
102C | F8       | SED         |         SED
102D | 06 C3    | ASL $C3     | DECML2: ASL.zp TMP2            ; rotate bytes out of input low byte
102F | 26 C4    | ROL $C4     |         ROL.zp TMP2+1          ; .. into high byte and carry bit
1031 | A2 02    | LDX #$02    |         LDX.# 2              ; process 3 bytes
1033 | BD 0D 01 | LDA $010D,X | DECDBL: LDA,X U0AA0         ; load current value of byte
1036 | 7D 0D 01 | ADC $010D,X |         ADC,X U0AA0         ; add it to itself plus the carry bit
1039 | 9D 0D 01 | STA $010D,X |         STA,X U0AA0         ; store it back in the same location
103C | CA       | DEX         |         DEX                 ; decrement byte counter
103D | 10 F4    | BPL $F4     |         BPL DECDBL          ; loop until all bytes processed
103F | 88       | DEY         |         DEY                 ; decrement bit counter
1040 | D0 EB    | BNE $EB     |         BNE DECML2          ; loop until all bits processed
1042 | 28       | PLP         |         PLP                 ; restore processor status
1043 | 60       | RTS         |         RTS
1044 |          |             | 
1044 |          |             | ; load the input value and fall through to print it
1044 | 48       | PHA         | PRINUM: PHA                 ; save accumulator
1045 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; copy input low byte to work buffer
1047 | 8D 0F 01 | STA $010F   |         STA U0AA0+2
104A | A5 C2    | LDA $C2     |         LDA.zp TMP0+1          ; copy input high byte to work buffer
104C | 8D 0E 01 | STA $010E   |         STA U0AA0+1
104F | A9 00    | LDA #$00    |         LDA.# 0              ; clear overflow byte in work buffer
1051 | 8D 0D 01 | STA $010D   |         STA U0AA0
1054 | 68       | PLA         |         PLA                 ; restore accumulator
1055 |          |             | 
1055 |          |             | ; print number in specified base without leading zeros
1055 | 8D 08 01 | STA $0108   | NMPRNT: STA DIGCNT          ; number of digits in accumulator
1058 | 8C 0A 01 | STY $010A   |         STY NUMBIT          ; bits per digit passed in Y register
105B | AC 0A 01 | LDY $010A   | DIGOUT: LDY NUMBIT          ; get bits to process
105E | A9 00    | LDA #$00    |         LDA.# 0              ; clear accumulator
1060 | 0E 0F 01 | ASL $010F   | ROLBIT: ASL U0AA0+2         ; shift bits out of low byte
1063 | 2E 0E 01 | ROL $010E   |         ROL U0AA0+1         ; ... into high byte
1066 | 2E 0D 01 | ROL $010D   |         ROL U0AA0           ; ... into overflow byte
1069 | 2A       | ROL A       |         ROL.A               ; ... into accumulator
106A | 88       | DEY         |         DEY                 ; decrement bit counter
106B | 10 F3    | BPL $F3     |         BPL ROLBIT          ; loop until all bits processed
106D | A8       | TAY         |         TAY                 ; check whether accumulator is 0
106E | D0 09    | BNE $09     |         BNE NZERO           ; if not, print it
1070 | E0 01    | CPX #$01    |         CPX.# 1              ; have we output the max number of digits?
1072 | F0 05    | BEQ $05     |         BEQ NZERO           ; if not, print it
1074 | AC 08 01 | LDY $0108   |         LDY DIGCNT          ; how many digits have we output?
1077 | F0 08    | BEQ $08     |         BEQ ZERSUP          ; skip output if digit is 0
1079 | EE 08 01 | INC $0108   | NZERO:  INC DIGCNT          ; increment digit counter
107C | 09 30    | ORA #$30    |         ORA.# $30            ; add numeric value to ascii '0' to get ascii char
107E | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output character
1081 | CA       | DEX         | ZERSUP: DEX                 ; decrement number of leading zeros
1082 | D0 D7    | BNE $D7     |         BNE DIGOUT          ; next digit
1084 | 60       | RTS         |         RTS
1085 |          |             | 
1085 |          |             | ; -----------------------------------------------------------------------------
1085 |          |             | ; disk status/command [@]
1085 | D0 03    | BNE $03     | DSTAT:  BNE CHGDEV          ; if device address was given, use it
1087 | A2 08    | LDX #$08    |         LDX.# 8              ; otherwise, default to 8
1089 | 2C       |             |         DATA.b $2C           ; absolute BIT opcode consumes next word (LDX TMP0)
108A | A6 C1    | LDX $C1     | CHGDEV: LDX.zp TMP0            ; load device address from parameter
108C | E0 04    | CPX #$04    |         CPX.# 4              ; make sure device address is in range 4-31
108E | 90 58    | BCC $58     |         BCC IOERR
1090 | E0 20    | CPX #$20    |         CPX.# 32
1092 | B0 54    | BCS $54     |         BCS IOERR
1094 | 86 C1    | STX $C1     |         STX.zp TMP0
1096 | A9 00    | LDA #$00    |         LDA.# 0              ; clear status
1098 | 85 90    | STA $90     |         STA.zp SATUS
109A | 85 B7    | STA $B7     |         STA.zp FNLEN           ; empty filename
109C | 20 2B 0F | JSR $0F2B   |         JSR GETCHR          ; get next character
109F | F0 24    | BEQ $24     |         BEQ INSTAT1         ; null, display status
10A1 | CE 31 02 | DEC $0231   |         DEC CHRPNT          ; back up 1 char
10A4 | C9 24    | CMP #$24    |         CMP.#  $24 ;'$'            ; $, display directory
10A6 | F0 43    | BEQ $43     |         BEQ DIRECT
10A8 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; command specified device to listen
10AA | 20 B1 FF | JSR $FFB1   |         JSR LISTEN
10AD | A9 6F    | LDA #$6F    |         LDA.# $6F            ; secondary address 15 (only low nybble used)
10AF | 20 93 FF | JSR $FF93   |         JSR SECOND
10B2 |          |             | 
10B2 |          |             | ; send command to device
10B2 | AE 31 02 | LDX $0231   | DCOMD:  LDX CHRPNT          ; get next character from buffer
10B5 | EE 31 02 | INC $0231   |         INC CHRPNT
10B8 | BD 00 02 | LDA $0200,X |         LDA,X INBUFF
10BB | F0 05    | BEQ $05     |         BEQ INSTAT          ; break out of loop if it's null
10BD | 20 A8 FF | JSR $FFA8   |         JSR CIOUT           ; otherwise output it to the serial bus
10C0 | 90 F0    | BCC $F0     |         BCC DCOMD           ; unconditional loop: CIOUT clears carry before RTS
10C2 |          |             | 
10C2 |          |             | ; get device status
10C2 | 20 AE FF | JSR $FFAE   | INSTAT: JSR UNLSN           ; command device to unlisten
10C5 | 20 EA 0E | JSR $0EEA   | INSTAT1: JSR CRLF            ; new line
10C8 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load device address
10CA | 20 B4 FF | JSR $FFB4   |         JSR TALK            ; command device to talk
10CD | A9 6F    | LDA #$6F    |         LDA.# $6F            ; secondary address 15 (only low nybble used)
10CF | 20 96 FF | JSR $FF96   |         JSR TKSA
10D2 | 20 A5 FF | JSR $FFA5   | RDSTAT: JSR ACPTR           ; read byte from serial bus
10D5 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; print it
10D8 | C9 0D    | CMP #$0D    |         CMP.# $0D            ; if the byte is CR, exit loop
10DA | F0 06    | BEQ $06     |         BEQ DEXIT
10DC | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
10DE | 29 BF    | AND #$BF    |         AND.# $BF            ; ignore EOI bit
10E0 | F0 F0    | BEQ $F0     |         BEQ RDSTAT          ; if no errors, read next byte
10E2 | 20 AB FF | JSR $FFAB   | DEXIT:  JSR UNTLK           ; command device to stop talking
10E5 | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to mainloop
10E8 | 4C 9D 08 | JMP $089D   | IOERR:  JMP ERROR           ; handle error
10EB |          |             | 
10EB |          |             | ; get directory
10EB | A5 C1    | LDA $C1     | DIRECT: LDA.zp TMP0            ; load device address
10ED | 20 B1 FF | JSR $FFB1   |         JSR LISTEN          ; command device to listen
10F0 | A9 F0    | LDA #$F0    |         LDA.# $F0            ; secondary address 0 (only low nybble used)
10F2 | 20 93 FF | JSR $FF93   |         JSR SECOND
10F5 | AE 31 02 | LDX $0231   |         LDX CHRPNT          ; get index of next character
10F8 | BD 00 02 | LDA $0200,X | DIR2:   LDA,X INBUFF        ; get next character from buffer
10FB | F0 06    | BEQ $06     |         BEQ DIR3            ; break if it's null
10FD | 20 A8 FF | JSR $FFA8   |         JSR CIOUT           ; send character to device
1100 | E8       | INX         |         INX                 ; increment characer index
1101 | D0 F5    | BNE $F5     |         BNE DIR2            ; loop if it hasn't wrapped to zero
1103 | 20 AE FF | JSR $FFAE   | DIR3:   JSR UNLSN           ; command device to unlisten
1106 | 20 EA 0E | JSR $0EEA   |         JSR CRLF            ; new line
1109 | A5 C1    | LDA $C1     |         LDA.zp TMP0            ; load device address
110B | 48       | PHA         |         PHA                 ; save on stack
110C | 20 B4 FF | JSR $FFB4   |         JSR TALK            ; command device to talk
110F | A9 60    | LDA #$60    |         LDA.# $60            ; secondary address 0 (only low nybble used)
1111 | 20 96 FF | JSR $FF96   |         JSR TKSA
1114 | A0 03    | LDY #$03    |         LDY.# 3              ; read 3 16-bit values from device
1116 | 8C 2F 02 | STY $022F   | DIRLIN: STY STORE           ;   ignore the first 2; 3rd is file size
1119 | 20 A5 FF | JSR $FFA5   | DLINK:  JSR ACPTR           ; read low byte from device
111C | 85 C1    | STA $C1     |         STA.zp TMP0            ; store it
111E | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
1120 | D0 44    | BNE $44     |         BNE DREXIT          ; exit if error or eof occurred
1122 | 20 A5 FF | JSR $FFA5   |         JSR ACPTR           ; read high byte from device
1125 | 85 C2    | STA $C2     |         STA.zp TMP0+1          ; store it
1127 | A5 90    | LDA $90     |         LDA.zp SATUS           ; check status
1129 | D0 3B    | BNE $3B     |         BNE DREXIT          ; exit if error or eof cocurred
112B | CE 2F 02 | DEC $022F   |         DEC STORE           ; decrement byte count
112E | D0 E9    | BNE $E9     |         BNE DLINK           ; loop if bytes remain
1130 | 20 1B 10 | JSR $101B   |         JSR CVTDEC          ; convert last 16-bit value to decimal
1133 | A9 00    | LDA #$00    |         LDA.# 0              ; clear digit count
1135 | A2 06    | LDX #$06    |         LDX.# 6              ; max 6 digits
1137 | A0 03    | LDY #$03    |         LDY.# 3              ; 3 bits per digit
1139 | 20 55 10 | JSR $1055   |         JSR NMPRNT          ; output number
113C | A9 20    | LDA #$20    |         LDA.# ' '            ; output space
113E | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
1141 | 20 A5 FF | JSR $FFA5   | DNAME:  JSR ACPTR           ; get a filename character from the device
1144 | F0 0A    | BEQ $0A     |         BEQ DMORE           ; if it's null, break out of loop
1146 | A6 90    | LDX $90     |         LDX.zp SATUS           ; check for errors or eof
1148 | D0 1C    | BNE $1C     |         BNE DREXIT          ; if found exit early
114A | 20 D2 FF | JSR $FFD2   |         JSR CHROUT          ; output character
114D | 18       | CLC         |         CLC
114E | 90 F1    | BCC $F1     |         BCC DNAME           ; unconditional branch to read next char
1150 | 20 EA 0E | JSR $0EEA   | DMORE:  JSR CRLF
1153 | 20 E1 FF | JSR $FFE1   |         JSR STOP            ; check for stop key
1156 | F0 0E    | BEQ $0E     |         BEQ DREXIT          ; exit early if pressed
1158 | 20 E4 FF | JSR $FFE4   |         JSR GETIN           ; pause if a key was pressed
115B | F0 05    | BEQ $05     |         BEQ NOPAWS
115D | 20 E4 FF | JSR $FFE4   | PAWS:   JSR GETIN           ; wait until another key is pressed
1160 | F0 FB    | BEQ $FB     |         BEQ PAWS            
1162 | A0 02    | LDY #$02    | NOPAWS: LDY.# 2
1164 | D0 B0    | BNE $B0     |         BNE DIRLIN          ; unconditional branch to read next file
1166 | 20 AB FF | JSR $FFAB   | DREXIT: JSR UNTLK           ; command device to untalk
1169 | 68       | PLA         |         PLA                 ; restore accumulator
116A | 20 B1 FF | JSR $FFB1   |         JSR LISTEN          ; command device to listen
116D | A9 E0    | LDA #$E0    |         LDA.# $E0            ; secondary address 0 (only low nybble is used)
116F | 20 93 FF | JSR $FF93   |         JSR SECOND
1172 | 20 AE FF | JSR $FFAE   |         JSR UNLSN           ; command device to unlisten
1175 | 4C 6E 08 | JMP $086E   |         JMP STRT            ; back to mainloop
1178 |          |             | 
1178 |          |             | ; -----------------------------------------------------------------------------
1178 |          |             | ; print and clear routines
1178 | 20 EA 0E | JSR $0EEA   | CLINE:  JSR CRLF            ; send CR+LF
117B | 4C 81 11 | JMP $1181   |         JMP SNCLR           ; clear line
117E | 20 91 11 | JSR $1191   | SNDCLR: JSR SNDMSG
1181 | A0 28    | LDY #$28    | SNCLR:  LDY.# $28            ; loop 40 times
1183 | A9 20    | LDA #$20    | SNCLP:  LDA.# $20            ; output space character
1185 | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
1188 | A9 14    | LDA #$14    |         LDA.# $14            ; output delete character
118A | 20 D2 FF | JSR $FFD2   |         JSR CHROUT
118D | 88       | DEY         |         DEY
118E | D0 F3    | BNE $F3     |         BNE SNCLP
1190 | 60       | RTS         |         RTS
1191 |          |             | 
1191 |          |             | ; -----------------------------------------------------------------------------
1191 |          |             | ; display message from table
1191 | B9 9F 11 | LDA $119F,Y | SNDMSG: LDA,Y MSGBAS        ; Y contains offset in msg table
1194 | 08       | PHP         |         PHP
1195 | 29 7F    | AND #$7F    |         AND.# $7F            ; strip high bit before output
1197 | 20 E6 0E | JSR $0EE6   |         JSR CHOUT
119A | C8       | INY         |         INY
119B | 28       | PLP         |         PLP
119C | 10 F3    | BPL $F3     |         BPL SNDMSG          ; loop until high bit is set
119E | 60       | RTS         |         RTS
119F |          |             | 
119F |          |             | ; -----------------------------------------------------------------------------
119F |          |             | ; message table; last character has high bit set
119F |          |             | MSGBAS:
119F | 0D       |             | MSG2:   DATA.b $0D               ; header for registers
11A0 |          |             |         ;.TEXT "   PC  SR AC XR YR SP   V1.2"
11A0 | 20       |             |         DATA.b ' '
11A1 | 20       |             |         DATA.b ' '
11A2 | 20       |             |         DATA.b ' '
11A3 | 50       |             |         DATA.b 'P'
11A4 | 43       |             |         DATA.b 'C'
11A5 | 20       |             |         DATA.b ' '
11A6 | 20       |             |         DATA.b ' '
11A7 | 53       |             |         DATA.b 'S'
11A8 | 52       |             |         DATA.b 'R'
11A9 | 20       |             |         DATA.b ' '
11AA | 41       |             |         DATA.b 'A'
11AB | 43       |             |         DATA.b 'C'
11AC | 20       |             |         DATA.b ' '
11AD | 58       |             |         DATA.b 'X'
11AE | 52       |             |         DATA.b 'R'
11AF | 20       |             |         DATA.b ' '
11B0 | 59       |             |         DATA.b 'Y'
11B1 | 52       |             |         DATA.b 'R'
11B2 | 20       |             |         DATA.b ' '
11B3 | 53       |             |         DATA.b 'S'
11B4 | 50       |             |         DATA.b 'P'
11B5 | 20       |             |         DATA.b ' '
11B6 | 20       |             |         DATA.b ' '
11B7 | 20       |             |         DATA.b ' '
11B8 | 56       |             |         DATA.b 'V'
11B9 | 31       |             |         DATA.b '1'
11BA | 2E       |             |         DATA.b '.'
11BB | 32       |             |         DATA.b '2'
11BC | 8D       |             |         DATA.b $0D+$80
11BD |          |             | 
11BD | 1D       |             | MSG3:   DATA.b $1D
11BE | BF       |             |         DATA.b $3F+$80       ; syntax error: move right, display "?"
11BF |          |             | 
11BF |          |             | MSG4:   ;.TEXT "..SYS"           ; SYS call to enter monitor
11BF | 2E       |             |         DATA.b '.'
11C0 | 2E       |             |         DATA.b '.'
11C1 | 53       |             |         DATA.b 'S'
11C2 | 59       |             |         DATA.b 'Y'
11C3 | 53       |             |         DATA.b 'S'
11C4 |          |             | 
11C4 | A0       |             |         DATA.b $20+$80
11C5 |          |             | 
11C5 | 3A       |             | MSG5:   DATA.b $3A
11C6 | 92       |             |         DATA.b $12+$80       ; ":" then RVS ON for memory ASCII dump
11C7 |          |             | 
11C7 |          |             | MSG6:   ;.TEXT " ERRO"           ; I/O error: display " ERROR"
11C7 | 20       |             |         DATA.b ' '
11C8 | 45       |             |         DATA.b 'E'
11C9 | 52       |             |         DATA.b 'R'
11CA | 52       |             |         DATA.b 'R'
11CB | 4F       |             |         DATA.b 'O'
11CC | D2       |             |         DATA.b 'R'+$80
11CD |          |             | 
11CD | 41       |             | MSG7:   DATA.b $41
11CE | A0       |             |         DATA.b $20+$80       ; assemble next instruction: "A " + addr
11CF |          |             | 
11CF |          |             | MSG8:   ; .TEXT "  "              ; pad non-existent byte: skip 3 spaces
11CF | 20       |             |         DATA.b ' '
11D0 | 20       |             |         DATA.b ' '
11D1 | A0       |             |         DATA.b $20+$80
11D2 |          |             | 
11D2 |          |             | 
11D2 |          |             | ; -----------------------------------------------------------------------------
11D2 |          |             | ; addressing mode table - nybbles provide index into MODE2 table
11D2 |          |             | ; for opcodes XXXXXXY0, use XXXXXX as index into table
11D2 |          |             | ; for opcodes WWWXXY01  use $40 + XX as index into table
11D2 |          |             | ; use right nybble if Y=0; use left nybble if Y=1
11D2 |          |             | 
11D2 | 40       |             | MODE:   DATA.b $40
11D3 | 02       |             |         DATA.b $02
11D4 | 45       |             |         DATA.b $45
11D5 | 03       |             |         DATA.b $03   ; even opcodes
11D6 | D0       |             |         DATA.b $D0
11D7 | 08       |             |         DATA.b $08
11D8 | 40       |             |         DATA.b $40
11D9 | 09       |             |         DATA.b $09
11DA | 30       |             |         DATA.b $30
11DB | 22       |             |         DATA.b $22
11DC | 45       |             |         DATA.b $45
11DD | 33       |             |         DATA.b $33
11DE | D0       |             |         DATA.b $D0
11DF | 08       |             |         DATA.b $08
11E0 | 40       |             |         DATA.b $40
11E1 | 09       |             |         DATA.b $09
11E2 | 40       |             |         DATA.b $40
11E3 | 02       |             |         DATA.b $02
11E4 | 45       |             |         DATA.b $45
11E5 | 33       |             |         DATA.b $33
11E6 | D0       |             |         DATA.b $D0
11E7 | 08       |             |         DATA.b $08
11E8 | 40       |             |         DATA.b $40
11E9 | 09       |             |         DATA.b $09
11EA | 40       |             |         DATA.b $40
11EB | 02       |             |         DATA.b $02
11EC | 45       |             |         DATA.b $45
11ED | B3       |             |         DATA.b $B3
11EE | D0       |             |         DATA.b $D0
11EF | 08       |             |         DATA.b $08
11F0 | 40       |             |         DATA.b $40
11F1 | 09       |             |         DATA.b $09
11F2 | 00       |             |         DATA.b $00
11F3 | 22       |             |         DATA.b $22
11F4 | 44       |             |         DATA.b $44
11F5 | 33       |             |         DATA.b $33
11F6 | D0       |             |         DATA.b $D0
11F7 | 8C       |             |         DATA.b $8C
11F8 | 44       |             |         DATA.b $44
11F9 | 00       |             |         DATA.b $00
11FA | 11       |             |         DATA.b $11
11FB | 22       |             |         DATA.b $22
11FC | 44       |             |         DATA.b $44
11FD | 33       |             |         DATA.b $33
11FE | D0       |             |         DATA.b $D0
11FF | 8C       |             |         DATA.b $8C
1200 | 44       |             |         DATA.b $44
1201 | 9A       |             |         DATA.b $9A
1202 | 10       |             |         DATA.b $10
1203 | 22       |             |         DATA.b $22
1204 | 44       |             |         DATA.b $44
1205 | 33       |             |         DATA.b $33
1206 | D0       |             |         DATA.b $D0
1207 | 08       |             |         DATA.b $08
1208 | 40       |             |         DATA.b $40
1209 | 09       |             |         DATA.b $09
120A | 10       |             |         DATA.b $10
120B | 22       |             |         DATA.b $22
120C | 44       |             |         DATA.b $44
120D | 33       |             |         DATA.b $33
120E | D0       |             |         DATA.b $D0
120F | 08       |             |         DATA.b $08
1210 | 40       |             |         DATA.b $40
1211 | 09       |             |         DATA.b $09
1212 | 62       |             |         DATA.b $62
1213 | 13       |             |         DATA.b $13
1214 | 78       |             |         DATA.b $78
1215 | A9       |             |         DATA.b $A9   ; opcodes ending in 01
1216 |          |             | 
1216 |          |             | ; addressing mode format definitions indexed by nybbles from MODE table
1216 |          |             | 
1216 |          |             | ; left 6 bits define which characters appear in the assembly operand
1216 |          |             | ; left 3 bits are before the address; next 3 bits are after
1216 |          |             | 
1216 |          |             | ; right-most 2 bits define length of binary operand
1216 |          |             | 
1216 |          |             | ; index               654 321
1216 |          |             | ; 1st character       $(# ,),  
1216 |          |             | ; 2nd character        $$ X Y    length  format      idx mode
1216 | 00       |             | MODE2:  DATA.b $00   ; 000 000    00                  0   error
1217 | 21       |             |         DATA.b $21   ; 001 000    01      #$00        1   immediate
1218 | 81       |             |         DATA.b $81   ; 100 000    01      $00         2   zero-page
1219 | 82       |             |         DATA.b $82   ; 100 000    10      $0000       3   absolute
121A | 00       |             |         DATA.b $00   ; 000 000    00                  4   implied
121B | 00       |             |         DATA.b $00   ; 000 000    00                  5   accumulator
121C | 59       |             |         DATA.b $59   ; 010 110    01      ($00,X)     6   indirect,X
121D | 4D       |             |         DATA.b $4D   ; 010 011    01      ($00),Y     7   indirect,Y
121E | 91       |             |         DATA.b $91   ; 100 100    01      $00,X       8   zero-page,X
121F | 92       |             |         DATA.b $92   ; 100 100    10      $0000,X     9   absolute,X
1220 | 86       |             |         DATA.b $86   ; 100 001    10      $0000,Y     A   absolute,Y
1221 | 4A       |             |         DATA.b $4A   ; 010 010    10      ($0000)     B   indirect
1222 | 85       |             |         DATA.b $85   ; 100 001    01      $00,Y       C   zero-page,Y
1223 | 9D       |             |         DATA.b $9D   ; 100 111    01      $0000*      D   relative
1224 |          |             | 
1224 |          |             | ; * relative is special-cased so format bits don't match
1224 |          |             | 
1224 |          |             | 
1224 |          |             | ; character lookup tables for the format definitions in MODE2
1224 |          |             | 
1224 | 2C       |             | CHAR1:  DATA.b $2C
1225 | 29       |             |         DATA.b $29
1226 | 2C       |             |         DATA.b $2C       ; ","  ")"  ","
1227 | 23       |             |         DATA.b $23
1228 | 28       |             |         DATA.b $28
1229 | 24       |             |         DATA.b $24       ; "#"  "("  "$"
122A |          |             | 
122A | 59       |             | CHAR2:  DATA.b $59
122B | 00       |             |         DATA.b $00
122C | 58       |             |         DATA.b $58       ; "Y"   0   "X"
122D | 24       |             |         DATA.b $24
122E | 24       |             |         DATA.b $24
122F | 00       |             |         DATA.b $00       ; "$"  "$"   0
1230 |          |             | 
1230 |          |             | ; -----------------------------------------------------------------------------
1230 |          |             | ; 3-letter mnemonics packed into two bytes (5 bits per letter)
1230 |          |             | 
1230 |          |             |         ; left 8 bits
1230 |          |             |         ; XXXXX000 opcodes
1230 | 1C       |             | MNEML:  DATA.b $1C
1231 | 8A       |             |         DATA.b $8A
1232 | 1C       |             |         DATA.b $1C
1233 | 23       |             |         DATA.b $23   ; BRK PHP BPL CLC
1234 | 5D       |             |         DATA.b $5D
1235 | 8B       |             |         DATA.b $8B
1236 | 1B       |             |         DATA.b $1B
1237 | A1       |             |         DATA.b $A1   ; JSR PLP BMI SEC
1238 | 9D       |             |         DATA.b $9D
1239 | 8A       |             |         DATA.b $8A
123A | 1D       |             |         DATA.b $1D
123B | 23       |             |         DATA.b $23   ; RTI PHA BVC CLI
123C | 9D       |             |         DATA.b $9D
123D | 8B       |             |         DATA.b $8B
123E | 1D       |             |         DATA.b $1D
123F | A1       |             |         DATA.b $A1   ; RTS PLA BVS SEI
1240 | 00       |             |         DATA.b $00
1241 | 29       |             |         DATA.b $29
1242 | 19       |             |         DATA.b $19
1243 | AE       |             |         DATA.b $AE   ; ??? DEY BCC TYA
1244 | 69       |             |         DATA.b $69
1245 | A8       |             |         DATA.b $A8
1246 | 19       |             |         DATA.b $19
1247 | 23       |             |         DATA.b $23   ; LDY TAY BCS CLV
1248 | 24       |             |         DATA.b $24
1249 | 53       |             |         DATA.b $53
124A | 1B       |             |         DATA.b $1B
124B | 23       |             |         DATA.b $23   ; CPY INY BNE CLD
124C | 24       |             |         DATA.b $24
124D | 53       |             |         DATA.b $53
124E | 19       |             |         DATA.b $19
124F | A1       |             |         DATA.b $A1   ; CPX INX BEQ SED
1250 |          |             |         ; XXXYY100 opcodes
1250 | 00       |             |         DATA.b $00
1251 | 1A       |             |         DATA.b $1A
1252 | 5B       |             |         DATA.b $5B
1253 | 5B       |             |         DATA.b $5B   ; ??? BIT JMP JMP
1254 | A5       |             |         DATA.b $A5
1255 | 69       |             |         DATA.b $69
1256 | 24       |             |         DATA.b $24
1257 | 24       |             |         DATA.b $24   ; STY LDY CPY CPX
1258 |          |             |         ; 1XXX1010 opcodes
1258 | AE       |             |         DATA.b $AE
1259 | AE       |             |         DATA.b $AE
125A | A8       |             |         DATA.b $A8
125B | AD       |             |         DATA.b $AD   ; TXA TXS TAX TSX
125C | 29       |             |         DATA.b $29
125D | 00       |             |         DATA.b $00
125E | 7C       |             |         DATA.b $7C
125F | 00       |             |         DATA.b $00   ; DEX ??? NOP ???
1260 |          |             |         ; XXXYYY10 opcodes
1260 | 15       |             |         DATA.b $15
1261 | 9C       |             |         DATA.b $9C
1262 | 6D       |             |         DATA.b $6D
1263 | 9C       |             |         DATA.b $9C   ; ASL ROL LSR ROR
1264 | A5       |             |         DATA.b $A5
1265 | 69       |             |         DATA.b $69
1266 | 29       |             |         DATA.b $29
1267 | 53       |             |         DATA.b $53   ; STX LDX DEC INC
1268 |          |             |         ; XXXYYY01 opcodes
1268 | 84       |             |         DATA.b $84
1269 | 13       |             |         DATA.b $13
126A | 34       |             |         DATA.b $34
126B | 11       |             |         DATA.b $11   ; ORA AND EOR ADC
126C | A5       |             |         DATA.b $A5
126D | 69       |             |         DATA.b $69
126E | 23       |             |         DATA.b $23
126F | A0       |             |         DATA.b $A0   ; STA LDA CMP SBC
1270 |          |             | 
1270 |          |             |         ; right 7 bits, left justified
1270 |          |             |         ; XXXXX000 opcodes
1270 | D8       |             | MNEMR:  DATA.b $D8
1271 | 62       |             |         DATA.b $62
1272 | 5A       |             |         DATA.b $5A
1273 | 48       |             |         DATA.b $48   ; BRK PHP BPL CLC
1274 | 26       |             |         DATA.b $26
1275 | 62       |             |         DATA.b $62
1276 | 94       |             |         DATA.b $94
1277 | 88       |             |         DATA.b $88   ; JSR PLP BMI SEC
1278 | 54       |             |         DATA.b $54
1279 | 44       |             |         DATA.b $44
127A | C8       |             |         DATA.b $C8
127B | 54       |             |         DATA.b $54   ; RTI PHA BVC CLI
127C | 68       |             |         DATA.b $68
127D | 44       |             |         DATA.b $44
127E | E8       |             |         DATA.b $E8
127F | 94       |             |         DATA.b $94   ; RTS PLA BVS SEI
1280 | 00       |             |         DATA.b $00
1281 | B4       |             |         DATA.b $B4
1282 | 08       |             |         DATA.b $08
1283 | 84       |             |         DATA.b $84   ; ??? DEY BCC TYA
1284 | 74       |             |         DATA.b $74
1285 | B4       |             |         DATA.b $B4
1286 | 28       |             |         DATA.b $28
1287 | 6E       |             |         DATA.b $6E   ; LDY TAY BCS CLV
1288 | 74       |             |         DATA.b $74
1289 | F4       |             |         DATA.b $F4
128A | CC       |             |         DATA.b $CC
128B | 4A       |             |         DATA.b $4A   ; CPY INY BNE CLD
128C | 72       |             |         DATA.b $72
128D | F2       |             |         DATA.b $F2
128E | A4       |             |         DATA.b $A4
128F | 8A       |             |         DATA.b $8A   ; CPX INX BEQ SED
1290 |          |             |         ; XXXYY100 opcodes
1290 | 00       |             |         DATA.b $00
1291 | AA       |             |         DATA.b $AA
1292 | A2       |             |         DATA.b $A2
1293 | A2       |             |         DATA.b $A2   ; ??? BIT JMP JMP
1294 | 74       |             |         DATA.b $74
1295 | 74       |             |         DATA.b $74
1296 | 74       |             |         DATA.b $74
1297 | 72       |             |         DATA.b $72   ; STY LDY CPY CPX
1298 |          |             |         ; 1XXX1010 opcodes
1298 | 44       |             |         DATA.b $44
1299 | 68       |             |         DATA.b $68
129A | B2       |             |         DATA.b $B2
129B | 32       |             |         DATA.b $32   ; TXA TXS TAX TSX
129C | B2       |             |         DATA.b $B2
129D | 00       |             |         DATA.b $00
129E | 22       |             |         DATA.b $22
129F | 00       |             |         DATA.b $00   ; DEX ??? NOP ???
12A0 |          |             |         ; XXXYYY10 opcodes
12A0 | 1A       |             |         DATA.b $1A
12A1 | 1A       |             |         DATA.b $1A
12A2 | 26       |             |         DATA.b $26
12A3 | 26       |             |         DATA.b $26   ; ASL ROL LSR ROR
12A4 | 72       |             |         DATA.b $72
12A5 | 72       |             |         DATA.b $72
12A6 | 88       |             |         DATA.b $88
12A7 | C8       |             |         DATA.b $C8   ; STX LDX DEC INC
12A8 |          |             |         ; XXXYYY01 opcodes
12A8 | C4       |             |         DATA.b $C4
12A9 | CA       |             |         DATA.b $CA
12AA | 26       |             |         DATA.b $26
12AB | 48       |             |         DATA.b $48   ; ORA AND EOR ADC
12AC | 44       |             |         DATA.b $44
12AD | 44       |             |         DATA.b $44
12AE | A2       |             |         DATA.b $A2
12AF | C8       |             |         DATA.b $C8   ; STA LDA CMP SBC
12B0 | 0D       |             |         DATA.b $0D
12B1 | 20       |             |         DATA.b $20
12B2 | 20       |             |         DATA.b $20
12B3 | 20       |             |         DATA.b $20
12B4 |          |             | 
12B4 |          |             | ; -----------------------------------------------------------------------------
12B4 |          |             | ; single-character commands
12B4 |          |             | KEYW:    ;.TEXT "ACDFGHJMRTX@.>;"
12B4 | 41       |             |         DATA.b 'A'
12B5 | 43       |             |         DATA.b 'C'
12B6 | 44       |             |         DATA.b 'D'
12B7 | 46       |             |         DATA.b 'F'
12B8 | 47       |             |         DATA.b 'G'
12B9 | 48       |             |         DATA.b 'H'
12BA | 4A       |             |         DATA.b 'J'
12BB | 4D       |             |         DATA.b 'M'
12BC | 52       |             |         DATA.b 'R'
12BD | 54       |             |         DATA.b 'T'
12BE | 58       |             |         DATA.b 'X'
12BF | 40       |             |         DATA.b '@'
12C0 | 2E       |             |         DATA.b '.'
12C1 | 3E       |             |         DATA.b '>'
12C2 | 3B       |             |         DATA.b $3b      ; ;
12C3 |          |             | 
12C3 |          |             | HIKEY:  ; .TEXT "$+&%LSV"
12C3 | 24       |             |         DATA.b $24      ; $
12C4 | 2B       |             |         DATA.b '+'
12C5 | 26       |             |         DATA.b $26      ; &
12C6 | 25       |             |         DATA.b '%'
12C7 | 4C       |             |         DATA.b 'L'
12C8 | 53       |             |         DATA.b 'S'
12C9 | 56       |             |         DATA.b 'V'
12CA |          |             | 
12CA |          |             | KEYTOP:
12CA |          |             | 
12CA |          |             | ; vectors corresponding to commands above
12CA | 50 0B    |             | KADDR:  DATA ASSEM-1
12CC | A8 09    |             |         DATA COMPAR-1
12CE | DD 0C    |             |         DATA DISASS-1
12D0 | 2B 0B    |             |         DATA FILL-1
12D2 |          |             | 
12D2 | 33 09    |             |         DATA GOTO-1
12D4 | 2C 0A    |             |         DATA HUNT-1
12D6 | 51 09    |             |         DATA JSUB-1
12D8 | C6 08    |             |         DATA DSPLYM-1
12DA |          |             | 
12DA | 4B 08    |             |         DATA DSPLYR-1
12DC | AB 09    |             |         DATA TRANS-1
12DE | C3 08    |             |         DATA EXIT-1
12E0 | 84 10    |             |         DATA DSTAT-1
12E2 |          |             | 
12E2 | 50 0B    |             |         DATA ASSEM-1
12E4 | 13 09    |             |         DATA ALTM-1
12E6 | FC 08    |             |         DATA ALTR-1
12E8 |          |             | 
12E8 |          |             | ; -----------------------------------------------------------------------------
12E8 | 10       |             | MODTAB: DATA.b $10
12E9 | 0A       |             |         DATA.b $0A
12EA | 08       |             |         DATA.b $08
12EB | 02       |             |         DATA.b 02    ; modulo number systems
12EC | 04       |             | LENTAB: DATA.b $04
12ED | 03       |             |         DATA.b $03
12EE | 03       |             |         DATA.b $03
12EF | 01       |             |         DATA.b $01   ; bits per digit
12F0 |          |             | 
12F0 | 3D 08    |             | LINKAD: DATA BREAK             ; address of brk handler
12F2 | 0D 08    |             | SUPAD:  DATA SUPER             ; address of entry point
12F4 |          |             | 
12F4 |          |             | ; Ending Including 'Supermon64v1.asm'
